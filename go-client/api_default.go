/*
OpenSearch

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2021-11-23
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package opensearch

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiBulkPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	waitForActiveShards *string
	refresh *RefreshEnum
	routing *string
	timeout *string
	type_ *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	pipeline *string
	requireAlias *bool
}

func (r ApiBulkPostRequest) Body(body map[string]interface{}) ApiBulkPostRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r ApiBulkPostRequest) WaitForActiveShards(waitForActiveShards string) ApiBulkPostRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r ApiBulkPostRequest) Refresh(refresh RefreshEnum) ApiBulkPostRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiBulkPostRequest) Routing(routing string) ApiBulkPostRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r ApiBulkPostRequest) Timeout(timeout string) ApiBulkPostRequest {
	r.timeout = &timeout
	return r
}

// Default document type for items which don&#39;t provide one.
func (r ApiBulkPostRequest) Type_(type_ string) ApiBulkPostRequest {
	r.type_ = &type_
	return r
}

// True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
func (r ApiBulkPostRequest) Source(source []string) ApiBulkPostRequest {
	r.source = &source
	return r
}

// Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
func (r ApiBulkPostRequest) SourceExcludes(sourceExcludes []string) ApiBulkPostRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
func (r ApiBulkPostRequest) SourceIncludes(sourceIncludes []string) ApiBulkPostRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r ApiBulkPostRequest) Pipeline(pipeline string) ApiBulkPostRequest {
	r.pipeline = &pipeline
	return r
}

// Sets require_alias for all incoming documents.
func (r ApiBulkPostRequest) RequireAlias(requireAlias bool) ApiBulkPostRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r ApiBulkPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkPostExecute(r)
}

/*
BulkPost Method for BulkPost

Allows to perform multiple index/update/delete operations in a single request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkPostRequest
*/
func (a *DefaultAPIService) BulkPost(ctx context.Context) ApiBulkPostRequest {
	return ApiBulkPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) BulkPostExecute(r ApiBulkPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.BulkPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBulkPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	refresh *RefreshEnum
	routing *string
	timeout *string
	type_ *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	pipeline *string
	requireAlias *bool
}

func (r ApiBulkPostWithIndexRequest) Body(body map[string]interface{}) ApiBulkPostWithIndexRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r ApiBulkPostWithIndexRequest) WaitForActiveShards(waitForActiveShards string) ApiBulkPostWithIndexRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r ApiBulkPostWithIndexRequest) Refresh(refresh RefreshEnum) ApiBulkPostWithIndexRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiBulkPostWithIndexRequest) Routing(routing string) ApiBulkPostWithIndexRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r ApiBulkPostWithIndexRequest) Timeout(timeout string) ApiBulkPostWithIndexRequest {
	r.timeout = &timeout
	return r
}

// Default document type for items which don&#39;t provide one.
func (r ApiBulkPostWithIndexRequest) Type_(type_ string) ApiBulkPostWithIndexRequest {
	r.type_ = &type_
	return r
}

// True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
func (r ApiBulkPostWithIndexRequest) Source(source []string) ApiBulkPostWithIndexRequest {
	r.source = &source
	return r
}

// Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
func (r ApiBulkPostWithIndexRequest) SourceExcludes(sourceExcludes []string) ApiBulkPostWithIndexRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
func (r ApiBulkPostWithIndexRequest) SourceIncludes(sourceIncludes []string) ApiBulkPostWithIndexRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r ApiBulkPostWithIndexRequest) Pipeline(pipeline string) ApiBulkPostWithIndexRequest {
	r.pipeline = &pipeline
	return r
}

// Sets require_alias for all incoming documents.
func (r ApiBulkPostWithIndexRequest) RequireAlias(requireAlias bool) ApiBulkPostWithIndexRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r ApiBulkPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkPostWithIndexExecute(r)
}

/*
BulkPostWithIndex Method for BulkPostWithIndex

Allows to perform multiple index/update/delete operations in a single request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Default index for items which don't provide one.
 @return ApiBulkPostWithIndexRequest
*/
func (a *DefaultAPIService) BulkPostWithIndex(ctx context.Context, index string) ApiBulkPostWithIndexRequest {
	return ApiBulkPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) BulkPostWithIndexExecute(r ApiBulkPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.BulkPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBulkPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	waitForActiveShards *string
	refresh *RefreshEnum
	routing *string
	timeout *string
	type_ *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	pipeline *string
	requireAlias *bool
}

func (r ApiBulkPutRequest) Body(body map[string]interface{}) ApiBulkPutRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r ApiBulkPutRequest) WaitForActiveShards(waitForActiveShards string) ApiBulkPutRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r ApiBulkPutRequest) Refresh(refresh RefreshEnum) ApiBulkPutRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiBulkPutRequest) Routing(routing string) ApiBulkPutRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r ApiBulkPutRequest) Timeout(timeout string) ApiBulkPutRequest {
	r.timeout = &timeout
	return r
}

// Default document type for items which don&#39;t provide one.
func (r ApiBulkPutRequest) Type_(type_ string) ApiBulkPutRequest {
	r.type_ = &type_
	return r
}

// True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
func (r ApiBulkPutRequest) Source(source []string) ApiBulkPutRequest {
	r.source = &source
	return r
}

// Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
func (r ApiBulkPutRequest) SourceExcludes(sourceExcludes []string) ApiBulkPutRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
func (r ApiBulkPutRequest) SourceIncludes(sourceIncludes []string) ApiBulkPutRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r ApiBulkPutRequest) Pipeline(pipeline string) ApiBulkPutRequest {
	r.pipeline = &pipeline
	return r
}

// Sets require_alias for all incoming documents.
func (r ApiBulkPutRequest) RequireAlias(requireAlias bool) ApiBulkPutRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r ApiBulkPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkPutExecute(r)
}

/*
BulkPut Method for BulkPut

Allows to perform multiple index/update/delete operations in a single request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkPutRequest
*/
func (a *DefaultAPIService) BulkPut(ctx context.Context) ApiBulkPutRequest {
	return ApiBulkPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) BulkPutExecute(r ApiBulkPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.BulkPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBulkPutWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	refresh *RefreshEnum
	routing *string
	timeout *string
	type_ *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	pipeline *string
	requireAlias *bool
}

func (r ApiBulkPutWithIndexRequest) Body(body map[string]interface{}) ApiBulkPutWithIndexRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r ApiBulkPutWithIndexRequest) WaitForActiveShards(waitForActiveShards string) ApiBulkPutWithIndexRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r ApiBulkPutWithIndexRequest) Refresh(refresh RefreshEnum) ApiBulkPutWithIndexRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiBulkPutWithIndexRequest) Routing(routing string) ApiBulkPutWithIndexRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r ApiBulkPutWithIndexRequest) Timeout(timeout string) ApiBulkPutWithIndexRequest {
	r.timeout = &timeout
	return r
}

// Default document type for items which don&#39;t provide one.
func (r ApiBulkPutWithIndexRequest) Type_(type_ string) ApiBulkPutWithIndexRequest {
	r.type_ = &type_
	return r
}

// True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
func (r ApiBulkPutWithIndexRequest) Source(source []string) ApiBulkPutWithIndexRequest {
	r.source = &source
	return r
}

// Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
func (r ApiBulkPutWithIndexRequest) SourceExcludes(sourceExcludes []string) ApiBulkPutWithIndexRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
func (r ApiBulkPutWithIndexRequest) SourceIncludes(sourceIncludes []string) ApiBulkPutWithIndexRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r ApiBulkPutWithIndexRequest) Pipeline(pipeline string) ApiBulkPutWithIndexRequest {
	r.pipeline = &pipeline
	return r
}

// Sets require_alias for all incoming documents.
func (r ApiBulkPutWithIndexRequest) RequireAlias(requireAlias bool) ApiBulkPutWithIndexRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r ApiBulkPutWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkPutWithIndexExecute(r)
}

/*
BulkPutWithIndex Method for BulkPutWithIndex

Allows to perform multiple index/update/delete operations in a single request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Default index for items which don't provide one.
 @return ApiBulkPutWithIndexRequest
*/
func (a *DefaultAPIService) BulkPutWithIndex(ctx context.Context, index string) ApiBulkPutWithIndexRequest {
	return ApiBulkPutWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) BulkPutWithIndexExecute(r ApiBulkPutWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.BulkPutWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatAliasesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	h *[]string
	help *bool
	s *[]string
	v *bool
	expandWildcards *ExpandWildcards
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatAliasesRequest) Format(format string) ApiCatAliasesRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatAliasesRequest) Local(local bool) ApiCatAliasesRequest {
	r.local = &local
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatAliasesRequest) H(h []string) ApiCatAliasesRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatAliasesRequest) Help(help bool) ApiCatAliasesRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatAliasesRequest) S(s []string) ApiCatAliasesRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatAliasesRequest) V(v bool) ApiCatAliasesRequest {
	r.v = &v
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiCatAliasesRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiCatAliasesRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiCatAliasesRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatAliasesExecute(r)
}

/*
CatAliases Method for CatAliases

Shows information about currently configured aliases to indices including filter and routing infos.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatAliasesRequest
*/
func (a *DefaultAPIService) CatAliases(ctx context.Context) ApiCatAliasesRequest {
	return ApiCatAliasesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatAliasesExecute(r ApiCatAliasesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatAliases")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/aliases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatAliasesWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	format *string
	local *bool
	h *[]string
	help *bool
	s *[]string
	v *bool
	expandWildcards *ExpandWildcards
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatAliasesWithNameRequest) Format(format string) ApiCatAliasesWithNameRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatAliasesWithNameRequest) Local(local bool) ApiCatAliasesWithNameRequest {
	r.local = &local
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatAliasesWithNameRequest) H(h []string) ApiCatAliasesWithNameRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatAliasesWithNameRequest) Help(help bool) ApiCatAliasesWithNameRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatAliasesWithNameRequest) S(s []string) ApiCatAliasesWithNameRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatAliasesWithNameRequest) V(v bool) ApiCatAliasesWithNameRequest {
	r.v = &v
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiCatAliasesWithNameRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiCatAliasesWithNameRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiCatAliasesWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatAliasesWithNameExecute(r)
}

/*
CatAliasesWithName Method for CatAliasesWithName

Shows information about currently configured aliases to indices including filter and routing infos.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of alias names.
 @return ApiCatAliasesWithNameRequest
*/
func (a *DefaultAPIService) CatAliasesWithName(ctx context.Context, name string) ApiCatAliasesWithNameRequest {
	return ApiCatAliasesWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatAliasesWithNameExecute(r ApiCatAliasesWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatAliasesWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/aliases/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatAllPitSegmentsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiCatAllPitSegmentsRequest) Execute() (*CatAllPitSegmentsResponseContent, *http.Response, error) {
	return r.ApiService.CatAllPitSegmentsExecute(r)
}

/*
CatAllPitSegments Method for CatAllPitSegments

Lists all active point-in-time segments.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatAllPitSegmentsRequest
*/
func (a *DefaultAPIService) CatAllPitSegments(ctx context.Context) ApiCatAllPitSegmentsRequest {
	return ApiCatAllPitSegmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CatAllPitSegmentsResponseContent
func (a *DefaultAPIService) CatAllPitSegmentsExecute(r ApiCatAllPitSegmentsRequest) (*CatAllPitSegmentsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatAllPitSegmentsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatAllPitSegments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/pit_segments/_all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatAllocationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	bytes *Bytes
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatAllocationRequest) Format(format string) ApiCatAllocationRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r ApiCatAllocationRequest) Bytes(bytes Bytes) ApiCatAllocationRequest {
	r.bytes = &bytes
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatAllocationRequest) Local(local bool) ApiCatAllocationRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatAllocationRequest) MasterTimeout(masterTimeout string) ApiCatAllocationRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatAllocationRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatAllocationRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatAllocationRequest) H(h []string) ApiCatAllocationRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatAllocationRequest) Help(help bool) ApiCatAllocationRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatAllocationRequest) S(s []string) ApiCatAllocationRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatAllocationRequest) V(v bool) ApiCatAllocationRequest {
	r.v = &v
	return r
}

func (r ApiCatAllocationRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatAllocationExecute(r)
}

/*
CatAllocation Method for CatAllocation

Provides a snapshot of how many shards are allocated to each data node and how much disk space they are using.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatAllocationRequest
*/
func (a *DefaultAPIService) CatAllocation(ctx context.Context) ApiCatAllocationRequest {
	return ApiCatAllocationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatAllocationExecute(r ApiCatAllocationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatAllocation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/allocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatAllocationWithNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	format *string
	bytes *Bytes
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatAllocationWithNodeIdRequest) Format(format string) ApiCatAllocationWithNodeIdRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r ApiCatAllocationWithNodeIdRequest) Bytes(bytes Bytes) ApiCatAllocationWithNodeIdRequest {
	r.bytes = &bytes
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatAllocationWithNodeIdRequest) Local(local bool) ApiCatAllocationWithNodeIdRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatAllocationWithNodeIdRequest) MasterTimeout(masterTimeout string) ApiCatAllocationWithNodeIdRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatAllocationWithNodeIdRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatAllocationWithNodeIdRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatAllocationWithNodeIdRequest) H(h []string) ApiCatAllocationWithNodeIdRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatAllocationWithNodeIdRequest) Help(help bool) ApiCatAllocationWithNodeIdRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatAllocationWithNodeIdRequest) S(s []string) ApiCatAllocationWithNodeIdRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatAllocationWithNodeIdRequest) V(v bool) ApiCatAllocationWithNodeIdRequest {
	r.v = &v
	return r
}

func (r ApiCatAllocationWithNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatAllocationWithNodeIdExecute(r)
}

/*
CatAllocationWithNodeId Method for CatAllocationWithNodeId

Provides a snapshot of how many shards are allocated to each data node and how much disk space they are using.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information.
 @return ApiCatAllocationWithNodeIdRequest
*/
func (a *DefaultAPIService) CatAllocationWithNodeId(ctx context.Context, nodeId string) ApiCatAllocationWithNodeIdRequest {
	return ApiCatAllocationWithNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatAllocationWithNodeIdExecute(r ApiCatAllocationWithNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatAllocationWithNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/allocation/{node_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatClusterManagerRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatClusterManagerRequest) Format(format string) ApiCatClusterManagerRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatClusterManagerRequest) Local(local bool) ApiCatClusterManagerRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatClusterManagerRequest) MasterTimeout(masterTimeout string) ApiCatClusterManagerRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatClusterManagerRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatClusterManagerRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatClusterManagerRequest) H(h []string) ApiCatClusterManagerRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatClusterManagerRequest) Help(help bool) ApiCatClusterManagerRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatClusterManagerRequest) S(s []string) ApiCatClusterManagerRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatClusterManagerRequest) V(v bool) ApiCatClusterManagerRequest {
	r.v = &v
	return r
}

func (r ApiCatClusterManagerRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatClusterManagerExecute(r)
}

/*
CatClusterManager Method for CatClusterManager

Returns information about the cluster-manager node.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatClusterManagerRequest
*/
func (a *DefaultAPIService) CatClusterManager(ctx context.Context) ApiCatClusterManagerRequest {
	return ApiCatClusterManagerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatClusterManagerExecute(r ApiCatClusterManagerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatClusterManager")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/cluster_manager"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatCountRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatCountRequest) Format(format string) ApiCatCountRequest {
	r.format = &format
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatCountRequest) H(h []string) ApiCatCountRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatCountRequest) Help(help bool) ApiCatCountRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatCountRequest) S(s []string) ApiCatCountRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatCountRequest) V(v bool) ApiCatCountRequest {
	r.v = &v
	return r
}

func (r ApiCatCountRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatCountExecute(r)
}

/*
CatCount Method for CatCount

Provides quick access to the document count of the entire cluster, or individual indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatCountRequest
*/
func (a *DefaultAPIService) CatCount(ctx context.Context) ApiCatCountRequest {
	return ApiCatCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatCountExecute(r ApiCatCountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatCount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatCountWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	format *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatCountWithIndexRequest) Format(format string) ApiCatCountWithIndexRequest {
	r.format = &format
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatCountWithIndexRequest) H(h []string) ApiCatCountWithIndexRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatCountWithIndexRequest) Help(help bool) ApiCatCountWithIndexRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatCountWithIndexRequest) S(s []string) ApiCatCountWithIndexRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatCountWithIndexRequest) V(v bool) ApiCatCountWithIndexRequest {
	r.v = &v
	return r
}

func (r ApiCatCountWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatCountWithIndexExecute(r)
}

/*
CatCountWithIndex Method for CatCountWithIndex

Provides quick access to the document count of the entire cluster, or individual indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to limit the returned information.
 @return ApiCatCountWithIndexRequest
*/
func (a *DefaultAPIService) CatCountWithIndex(ctx context.Context, index string) ApiCatCountWithIndexRequest {
	return ApiCatCountWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatCountWithIndexExecute(r ApiCatCountWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatCountWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/count/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatFielddataRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	bytes *Bytes
	h *[]string
	help *bool
	s *[]string
	v *bool
	fields *[]string
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatFielddataRequest) Format(format string) ApiCatFielddataRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r ApiCatFielddataRequest) Bytes(bytes Bytes) ApiCatFielddataRequest {
	r.bytes = &bytes
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatFielddataRequest) H(h []string) ApiCatFielddataRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatFielddataRequest) Help(help bool) ApiCatFielddataRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatFielddataRequest) S(s []string) ApiCatFielddataRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatFielddataRequest) V(v bool) ApiCatFielddataRequest {
	r.v = &v
	return r
}

// Comma-separated list of fields to return in the output.
func (r ApiCatFielddataRequest) Fields(fields []string) ApiCatFielddataRequest {
	r.fields = &fields
	return r
}

func (r ApiCatFielddataRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatFielddataExecute(r)
}

/*
CatFielddata Method for CatFielddata

Shows how much heap memory is currently being used by fielddata on every data node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatFielddataRequest
*/
func (a *DefaultAPIService) CatFielddata(ctx context.Context) ApiCatFielddataRequest {
	return ApiCatFielddataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatFielddataExecute(r ApiCatFielddataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatFielddata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/fielddata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatFielddataWithFieldsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	fields string
	format *string
	bytes *Bytes
	h *[]string
	help *bool
	s *[]string
	v *bool
	fields2 *[]string
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatFielddataWithFieldsRequest) Format(format string) ApiCatFielddataWithFieldsRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r ApiCatFielddataWithFieldsRequest) Bytes(bytes Bytes) ApiCatFielddataWithFieldsRequest {
	r.bytes = &bytes
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatFielddataWithFieldsRequest) H(h []string) ApiCatFielddataWithFieldsRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatFielddataWithFieldsRequest) Help(help bool) ApiCatFielddataWithFieldsRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatFielddataWithFieldsRequest) S(s []string) ApiCatFielddataWithFieldsRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatFielddataWithFieldsRequest) V(v bool) ApiCatFielddataWithFieldsRequest {
	r.v = &v
	return r
}

// Comma-separated list of fields to return in the output.
func (r ApiCatFielddataWithFieldsRequest) Fields2(fields2 []string) ApiCatFielddataWithFieldsRequest {
	r.fields2 = &fields2
	return r
}

func (r ApiCatFielddataWithFieldsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatFielddataWithFieldsExecute(r)
}

/*
CatFielddataWithFields Method for CatFielddataWithFields

Shows how much heap memory is currently being used by fielddata on every data node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fields Comma-separated list of fields to return the fielddata size.
 @return ApiCatFielddataWithFieldsRequest
*/
func (a *DefaultAPIService) CatFielddataWithFields(ctx context.Context, fields string) ApiCatFielddataWithFieldsRequest {
	return ApiCatFielddataWithFieldsRequest{
		ApiService: a,
		ctx: ctx,
		fields: fields,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatFielddataWithFieldsExecute(r ApiCatFielddataWithFieldsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatFielddataWithFields")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/fielddata/{fields}"
	localVarPath = strings.Replace(localVarPath, "{"+"fields"+"}", url.PathEscape(parameterValueToString(r.fields, "fields")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	if r.fields2 != nil {
		t := *r.fields2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatHealthRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	ts *bool
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatHealthRequest) Format(format string) ApiCatHealthRequest {
	r.format = &format
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatHealthRequest) H(h []string) ApiCatHealthRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatHealthRequest) Help(help bool) ApiCatHealthRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatHealthRequest) S(s []string) ApiCatHealthRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r ApiCatHealthRequest) Time(time Time) ApiCatHealthRequest {
	r.time = &time
	return r
}

// Set to false to disable timestamping.
func (r ApiCatHealthRequest) Ts(ts bool) ApiCatHealthRequest {
	r.ts = &ts
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatHealthRequest) V(v bool) ApiCatHealthRequest {
	r.v = &v
	return r
}

func (r ApiCatHealthRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatHealthExecute(r)
}

/*
CatHealth Method for CatHealth

Returns a concise representation of the cluster health.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatHealthRequest
*/
func (a *DefaultAPIService) CatHealth(ctx context.Context) ApiCatHealthRequest {
	return ApiCatHealthRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatHealthExecute(r ApiCatHealthRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatHealth")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.ts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ts", r.ts, "")
	} else {
		var defaultValue bool = true
		r.ts = &defaultValue
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatHelpRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	help *bool
	s *[]string
}

// Return help information.
func (r ApiCatHelpRequest) Help(help bool) ApiCatHelpRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatHelpRequest) S(s []string) ApiCatHelpRequest {
	r.s = &s
	return r
}

func (r ApiCatHelpRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatHelpExecute(r)
}

/*
CatHelp Method for CatHelp

Returns help for the Cat APIs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatHelpRequest
*/
func (a *DefaultAPIService) CatHelp(ctx context.Context) ApiCatHelpRequest {
	return ApiCatHelpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatHelpExecute(r ApiCatHelpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatHelp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatIndicesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	bytes *Bytes
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	health *Health
	help *bool
	pri *bool
	s *[]string
	time *Time
	v *bool
	includeUnloadedSegments *bool
	expandWildcards *ExpandWildcards
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatIndicesRequest) Format(format string) ApiCatIndicesRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r ApiCatIndicesRequest) Bytes(bytes Bytes) ApiCatIndicesRequest {
	r.bytes = &bytes
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatIndicesRequest) Local(local bool) ApiCatIndicesRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatIndicesRequest) MasterTimeout(masterTimeout string) ApiCatIndicesRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatIndicesRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatIndicesRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatIndicesRequest) H(h []string) ApiCatIndicesRequest {
	r.h = &h
	return r
}

// Health status (&#39;green&#39;, &#39;yellow&#39;, or &#39;red&#39;) to filter only indices matching the specified health status.
func (r ApiCatIndicesRequest) Health(health Health) ApiCatIndicesRequest {
	r.health = &health
	return r
}

// Return help information.
func (r ApiCatIndicesRequest) Help(help bool) ApiCatIndicesRequest {
	r.help = &help
	return r
}

// Set to true to return stats only for primary shards.
func (r ApiCatIndicesRequest) Pri(pri bool) ApiCatIndicesRequest {
	r.pri = &pri
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatIndicesRequest) S(s []string) ApiCatIndicesRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r ApiCatIndicesRequest) Time(time Time) ApiCatIndicesRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatIndicesRequest) V(v bool) ApiCatIndicesRequest {
	r.v = &v
	return r
}

// If set to true segment stats will include stats for segments that are not currently loaded into memory.
func (r ApiCatIndicesRequest) IncludeUnloadedSegments(includeUnloadedSegments bool) ApiCatIndicesRequest {
	r.includeUnloadedSegments = &includeUnloadedSegments
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiCatIndicesRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiCatIndicesRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiCatIndicesRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatIndicesExecute(r)
}

/*
CatIndices Method for CatIndices

Returns information about indices: number of primaries and replicas, document counts, disk size, ...

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatIndicesRequest
*/
func (a *DefaultAPIService) CatIndices(ctx context.Context) ApiCatIndicesRequest {
	return ApiCatIndicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatIndicesExecute(r ApiCatIndicesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatIndices")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/indices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.health != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "health", r.health, "")
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.pri != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pri", r.pri, "")
	} else {
		var defaultValue bool = false
		r.pri = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	if r.includeUnloadedSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unloaded_segments", r.includeUnloadedSegments, "")
	} else {
		var defaultValue bool = false
		r.includeUnloadedSegments = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatIndicesWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	format *string
	bytes *Bytes
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	health *Health
	help *bool
	pri *bool
	s *[]string
	time *Time
	v *bool
	includeUnloadedSegments *bool
	expandWildcards *ExpandWildcards
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatIndicesWithIndexRequest) Format(format string) ApiCatIndicesWithIndexRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r ApiCatIndicesWithIndexRequest) Bytes(bytes Bytes) ApiCatIndicesWithIndexRequest {
	r.bytes = &bytes
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatIndicesWithIndexRequest) Local(local bool) ApiCatIndicesWithIndexRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatIndicesWithIndexRequest) MasterTimeout(masterTimeout string) ApiCatIndicesWithIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatIndicesWithIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatIndicesWithIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatIndicesWithIndexRequest) H(h []string) ApiCatIndicesWithIndexRequest {
	r.h = &h
	return r
}

// Health status (&#39;green&#39;, &#39;yellow&#39;, or &#39;red&#39;) to filter only indices matching the specified health status.
func (r ApiCatIndicesWithIndexRequest) Health(health Health) ApiCatIndicesWithIndexRequest {
	r.health = &health
	return r
}

// Return help information.
func (r ApiCatIndicesWithIndexRequest) Help(help bool) ApiCatIndicesWithIndexRequest {
	r.help = &help
	return r
}

// Set to true to return stats only for primary shards.
func (r ApiCatIndicesWithIndexRequest) Pri(pri bool) ApiCatIndicesWithIndexRequest {
	r.pri = &pri
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatIndicesWithIndexRequest) S(s []string) ApiCatIndicesWithIndexRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r ApiCatIndicesWithIndexRequest) Time(time Time) ApiCatIndicesWithIndexRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatIndicesWithIndexRequest) V(v bool) ApiCatIndicesWithIndexRequest {
	r.v = &v
	return r
}

// If set to true segment stats will include stats for segments that are not currently loaded into memory.
func (r ApiCatIndicesWithIndexRequest) IncludeUnloadedSegments(includeUnloadedSegments bool) ApiCatIndicesWithIndexRequest {
	r.includeUnloadedSegments = &includeUnloadedSegments
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiCatIndicesWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiCatIndicesWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiCatIndicesWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatIndicesWithIndexExecute(r)
}

/*
CatIndicesWithIndex Method for CatIndicesWithIndex

Returns information about indices: number of primaries and replicas, document counts, disk size, ...

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to limit the returned information.
 @return ApiCatIndicesWithIndexRequest
*/
func (a *DefaultAPIService) CatIndicesWithIndex(ctx context.Context, index string) ApiCatIndicesWithIndexRequest {
	return ApiCatIndicesWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatIndicesWithIndexExecute(r ApiCatIndicesWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatIndicesWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/indices/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.health != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "health", r.health, "")
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.pri != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pri", r.pri, "")
	} else {
		var defaultValue bool = false
		r.pri = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	if r.includeUnloadedSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unloaded_segments", r.includeUnloadedSegments, "")
	} else {
		var defaultValue bool = false
		r.includeUnloadedSegments = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatMasterRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatMasterRequest) Format(format string) ApiCatMasterRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatMasterRequest) Local(local bool) ApiCatMasterRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatMasterRequest) MasterTimeout(masterTimeout string) ApiCatMasterRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatMasterRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatMasterRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatMasterRequest) H(h []string) ApiCatMasterRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatMasterRequest) Help(help bool) ApiCatMasterRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatMasterRequest) S(s []string) ApiCatMasterRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatMasterRequest) V(v bool) ApiCatMasterRequest {
	r.v = &v
	return r
}

func (r ApiCatMasterRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatMasterExecute(r)
}

/*
CatMaster Method for CatMaster

Returns information about the cluster-manager node.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatMasterRequest

Deprecated
*/
func (a *DefaultAPIService) CatMaster(ctx context.Context) ApiCatMasterRequest {
	return ApiCatMasterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) CatMasterExecute(r ApiCatMasterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatMaster")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/master"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatNodeattrsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatNodeattrsRequest) Format(format string) ApiCatNodeattrsRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatNodeattrsRequest) Local(local bool) ApiCatNodeattrsRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatNodeattrsRequest) MasterTimeout(masterTimeout string) ApiCatNodeattrsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatNodeattrsRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatNodeattrsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatNodeattrsRequest) H(h []string) ApiCatNodeattrsRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatNodeattrsRequest) Help(help bool) ApiCatNodeattrsRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatNodeattrsRequest) S(s []string) ApiCatNodeattrsRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatNodeattrsRequest) V(v bool) ApiCatNodeattrsRequest {
	r.v = &v
	return r
}

func (r ApiCatNodeattrsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatNodeattrsExecute(r)
}

/*
CatNodeattrs Method for CatNodeattrs

Returns information about custom node attributes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatNodeattrsRequest
*/
func (a *DefaultAPIService) CatNodeattrs(ctx context.Context) ApiCatNodeattrsRequest {
	return ApiCatNodeattrsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatNodeattrsExecute(r ApiCatNodeattrsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatNodeattrs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/nodeattrs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatNodesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	bytes *Bytes
	format *string
	fullId *bool
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	v *bool
}

// The unit in which to display byte values.
func (r ApiCatNodesRequest) Bytes(bytes Bytes) ApiCatNodesRequest {
	r.bytes = &bytes
	return r
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatNodesRequest) Format(format string) ApiCatNodesRequest {
	r.format = &format
	return r
}

// Return the full node ID instead of the shortened version.
func (r ApiCatNodesRequest) FullId(fullId bool) ApiCatNodesRequest {
	r.fullId = &fullId
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatNodesRequest) Local(local bool) ApiCatNodesRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatNodesRequest) MasterTimeout(masterTimeout string) ApiCatNodesRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatNodesRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatNodesRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatNodesRequest) H(h []string) ApiCatNodesRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatNodesRequest) Help(help bool) ApiCatNodesRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatNodesRequest) S(s []string) ApiCatNodesRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r ApiCatNodesRequest) Time(time Time) ApiCatNodesRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatNodesRequest) V(v bool) ApiCatNodesRequest {
	r.v = &v
	return r
}

func (r ApiCatNodesRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatNodesExecute(r)
}

/*
CatNodes Method for CatNodes

Returns basic statistics about performance of cluster nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatNodesRequest
*/
func (a *DefaultAPIService) CatNodes(ctx context.Context) ApiCatNodesRequest {
	return ApiCatNodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatNodesExecute(r ApiCatNodesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatNodes")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/nodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.fullId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "full_id", r.fullId, "")
	} else {
		var defaultValue bool = false
		r.fullId = &defaultValue
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatPendingTasksRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatPendingTasksRequest) Format(format string) ApiCatPendingTasksRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatPendingTasksRequest) Local(local bool) ApiCatPendingTasksRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatPendingTasksRequest) MasterTimeout(masterTimeout string) ApiCatPendingTasksRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatPendingTasksRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatPendingTasksRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatPendingTasksRequest) H(h []string) ApiCatPendingTasksRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatPendingTasksRequest) Help(help bool) ApiCatPendingTasksRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatPendingTasksRequest) S(s []string) ApiCatPendingTasksRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r ApiCatPendingTasksRequest) Time(time Time) ApiCatPendingTasksRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatPendingTasksRequest) V(v bool) ApiCatPendingTasksRequest {
	r.v = &v
	return r
}

func (r ApiCatPendingTasksRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatPendingTasksExecute(r)
}

/*
CatPendingTasks Method for CatPendingTasks

Returns a concise representation of the cluster pending tasks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatPendingTasksRequest
*/
func (a *DefaultAPIService) CatPendingTasks(ctx context.Context) ApiCatPendingTasksRequest {
	return ApiCatPendingTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatPendingTasksExecute(r ApiCatPendingTasksRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatPendingTasks")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/pending_tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatPitSegmentsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	catPitSegmentsBodyParams *CatPitSegmentsBodyParams
}

func (r ApiCatPitSegmentsRequest) CatPitSegmentsBodyParams(catPitSegmentsBodyParams CatPitSegmentsBodyParams) ApiCatPitSegmentsRequest {
	r.catPitSegmentsBodyParams = &catPitSegmentsBodyParams
	return r
}

func (r ApiCatPitSegmentsRequest) Execute() (*CatPitSegmentsResponseContent, *http.Response, error) {
	return r.ApiService.CatPitSegmentsExecute(r)
}

/*
CatPitSegments Method for CatPitSegments

List segments for one or several PITs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatPitSegmentsRequest
*/
func (a *DefaultAPIService) CatPitSegments(ctx context.Context) ApiCatPitSegmentsRequest {
	return ApiCatPitSegmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CatPitSegmentsResponseContent
func (a *DefaultAPIService) CatPitSegmentsExecute(r ApiCatPitSegmentsRequest) (*CatPitSegmentsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatPitSegmentsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatPitSegments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/pit_segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.catPitSegmentsBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatPluginsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatPluginsRequest) Format(format string) ApiCatPluginsRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatPluginsRequest) Local(local bool) ApiCatPluginsRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatPluginsRequest) MasterTimeout(masterTimeout string) ApiCatPluginsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatPluginsRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatPluginsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatPluginsRequest) H(h []string) ApiCatPluginsRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatPluginsRequest) Help(help bool) ApiCatPluginsRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatPluginsRequest) S(s []string) ApiCatPluginsRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatPluginsRequest) V(v bool) ApiCatPluginsRequest {
	r.v = &v
	return r
}

func (r ApiCatPluginsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatPluginsExecute(r)
}

/*
CatPlugins Method for CatPlugins

Returns information about installed plugins across nodes node.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatPluginsRequest
*/
func (a *DefaultAPIService) CatPlugins(ctx context.Context) ApiCatPluginsRequest {
	return ApiCatPluginsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatPluginsExecute(r ApiCatPluginsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatPlugins")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/plugins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatRecoveryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	activeOnly *bool
	bytes *Bytes
	detailed *bool
	h *[]string
	help *bool
	index *[]string
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatRecoveryRequest) Format(format string) ApiCatRecoveryRequest {
	r.format = &format
	return r
}

// If &#x60;true&#x60;, the response only includes ongoing shard recoveries.
func (r ApiCatRecoveryRequest) ActiveOnly(activeOnly bool) ApiCatRecoveryRequest {
	r.activeOnly = &activeOnly
	return r
}

// The unit in which to display byte values.
func (r ApiCatRecoveryRequest) Bytes(bytes Bytes) ApiCatRecoveryRequest {
	r.bytes = &bytes
	return r
}

// If &#x60;true&#x60;, the response includes detailed information about shard recoveries.
func (r ApiCatRecoveryRequest) Detailed(detailed bool) ApiCatRecoveryRequest {
	r.detailed = &detailed
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatRecoveryRequest) H(h []string) ApiCatRecoveryRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatRecoveryRequest) Help(help bool) ApiCatRecoveryRequest {
	r.help = &help
	return r
}

// Comma-separated list or wildcard expression of index names to limit the returned information.
func (r ApiCatRecoveryRequest) Index(index []string) ApiCatRecoveryRequest {
	r.index = &index
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatRecoveryRequest) S(s []string) ApiCatRecoveryRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r ApiCatRecoveryRequest) Time(time Time) ApiCatRecoveryRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatRecoveryRequest) V(v bool) ApiCatRecoveryRequest {
	r.v = &v
	return r
}

func (r ApiCatRecoveryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatRecoveryExecute(r)
}

/*
CatRecovery Method for CatRecovery

Returns information about index shard recoveries, both on-going completed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatRecoveryRequest
*/
func (a *DefaultAPIService) CatRecovery(ctx context.Context) ApiCatRecoveryRequest {
	return ApiCatRecoveryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatRecoveryExecute(r ApiCatRecoveryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatRecovery")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/recovery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_only", r.activeOnly, "")
	} else {
		var defaultValue bool = false
		r.activeOnly = &defaultValue
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.index != nil {
		t := *r.index
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "index", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "index", t, "multi")
		}
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatRecoveryWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	format *string
	activeOnly *bool
	bytes *Bytes
	detailed *bool
	h *[]string
	help *bool
	index2 *[]string
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatRecoveryWithIndexRequest) Format(format string) ApiCatRecoveryWithIndexRequest {
	r.format = &format
	return r
}

// If &#x60;true&#x60;, the response only includes ongoing shard recoveries.
func (r ApiCatRecoveryWithIndexRequest) ActiveOnly(activeOnly bool) ApiCatRecoveryWithIndexRequest {
	r.activeOnly = &activeOnly
	return r
}

// The unit in which to display byte values.
func (r ApiCatRecoveryWithIndexRequest) Bytes(bytes Bytes) ApiCatRecoveryWithIndexRequest {
	r.bytes = &bytes
	return r
}

// If &#x60;true&#x60;, the response includes detailed information about shard recoveries.
func (r ApiCatRecoveryWithIndexRequest) Detailed(detailed bool) ApiCatRecoveryWithIndexRequest {
	r.detailed = &detailed
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatRecoveryWithIndexRequest) H(h []string) ApiCatRecoveryWithIndexRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatRecoveryWithIndexRequest) Help(help bool) ApiCatRecoveryWithIndexRequest {
	r.help = &help
	return r
}

// Comma-separated list or wildcard expression of index names to limit the returned information.
func (r ApiCatRecoveryWithIndexRequest) Index2(index2 []string) ApiCatRecoveryWithIndexRequest {
	r.index2 = &index2
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatRecoveryWithIndexRequest) S(s []string) ApiCatRecoveryWithIndexRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r ApiCatRecoveryWithIndexRequest) Time(time Time) ApiCatRecoveryWithIndexRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatRecoveryWithIndexRequest) V(v bool) ApiCatRecoveryWithIndexRequest {
	r.v = &v
	return r
}

func (r ApiCatRecoveryWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatRecoveryWithIndexExecute(r)
}

/*
CatRecoveryWithIndex Method for CatRecoveryWithIndex

Returns information about index shard recoveries, both on-going completed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list or wildcard expression of index names to limit the returned information.
 @return ApiCatRecoveryWithIndexRequest
*/
func (a *DefaultAPIService) CatRecoveryWithIndex(ctx context.Context, index string) ApiCatRecoveryWithIndexRequest {
	return ApiCatRecoveryWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatRecoveryWithIndexExecute(r ApiCatRecoveryWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatRecoveryWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/recovery/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_only", r.activeOnly, "")
	} else {
		var defaultValue bool = false
		r.activeOnly = &defaultValue
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.index2 != nil {
		t := *r.index2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "index", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "index", t, "multi")
		}
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatRepositoriesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatRepositoriesRequest) Format(format string) ApiCatRepositoriesRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatRepositoriesRequest) Local(local bool) ApiCatRepositoriesRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatRepositoriesRequest) MasterTimeout(masterTimeout string) ApiCatRepositoriesRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatRepositoriesRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatRepositoriesRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatRepositoriesRequest) H(h []string) ApiCatRepositoriesRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatRepositoriesRequest) Help(help bool) ApiCatRepositoriesRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatRepositoriesRequest) S(s []string) ApiCatRepositoriesRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatRepositoriesRequest) V(v bool) ApiCatRepositoriesRequest {
	r.v = &v
	return r
}

func (r ApiCatRepositoriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatRepositoriesExecute(r)
}

/*
CatRepositories Method for CatRepositories

Returns information about snapshot repositories registered in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatRepositoriesRequest
*/
func (a *DefaultAPIService) CatRepositories(ctx context.Context) ApiCatRepositoriesRequest {
	return ApiCatRepositoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatRepositoriesExecute(r ApiCatRepositoriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatRepositories")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/repositories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatSegmentReplicationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	activeOnly *bool
	completedOnly *bool
	bytes *Bytes
	detailed *bool
	shards *[]string
	h *[]string
	help *bool
	index *[]string
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatSegmentReplicationRequest) Format(format string) ApiCatSegmentReplicationRequest {
	r.format = &format
	return r
}

// If &#x60;true&#x60;, the response only includes ongoing segment replication events.
func (r ApiCatSegmentReplicationRequest) ActiveOnly(activeOnly bool) ApiCatSegmentReplicationRequest {
	r.activeOnly = &activeOnly
	return r
}

// If &#x60;true&#x60;, the response only includes latest completed segment replication events.
func (r ApiCatSegmentReplicationRequest) CompletedOnly(completedOnly bool) ApiCatSegmentReplicationRequest {
	r.completedOnly = &completedOnly
	return r
}

// The unit in which to display byte values.
func (r ApiCatSegmentReplicationRequest) Bytes(bytes Bytes) ApiCatSegmentReplicationRequest {
	r.bytes = &bytes
	return r
}

// If &#x60;true&#x60;, the response includes detailed information about segment replications.
func (r ApiCatSegmentReplicationRequest) Detailed(detailed bool) ApiCatSegmentReplicationRequest {
	r.detailed = &detailed
	return r
}

// Comma-separated list of shards to display.
func (r ApiCatSegmentReplicationRequest) Shards(shards []string) ApiCatSegmentReplicationRequest {
	r.shards = &shards
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatSegmentReplicationRequest) H(h []string) ApiCatSegmentReplicationRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatSegmentReplicationRequest) Help(help bool) ApiCatSegmentReplicationRequest {
	r.help = &help
	return r
}

// Comma-separated list or wildcard expression of index names to limit the returned information.
func (r ApiCatSegmentReplicationRequest) Index(index []string) ApiCatSegmentReplicationRequest {
	r.index = &index
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatSegmentReplicationRequest) S(s []string) ApiCatSegmentReplicationRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r ApiCatSegmentReplicationRequest) Time(time Time) ApiCatSegmentReplicationRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatSegmentReplicationRequest) V(v bool) ApiCatSegmentReplicationRequest {
	r.v = &v
	return r
}

func (r ApiCatSegmentReplicationRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatSegmentReplicationExecute(r)
}

/*
CatSegmentReplication Method for CatSegmentReplication

Returns information about both on-going and latest completed Segment Replication events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatSegmentReplicationRequest
*/
func (a *DefaultAPIService) CatSegmentReplication(ctx context.Context) ApiCatSegmentReplicationRequest {
	return ApiCatSegmentReplicationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatSegmentReplicationExecute(r ApiCatSegmentReplicationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatSegmentReplication")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/segment_replication"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_only", r.activeOnly, "")
	} else {
		var defaultValue bool = false
		r.activeOnly = &defaultValue
	}
	if r.completedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completed_only", r.completedOnly, "")
	} else {
		var defaultValue bool = false
		r.completedOnly = &defaultValue
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.shards != nil {
		t := *r.shards
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shards", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shards", t, "multi")
		}
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.index != nil {
		t := *r.index
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "index", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "index", t, "multi")
		}
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatSegmentReplicationWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	format *string
	activeOnly *bool
	completedOnly *bool
	bytes *Bytes
	detailed *bool
	shards *[]string
	h *[]string
	help *bool
	index2 *[]string
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatSegmentReplicationWithIndexRequest) Format(format string) ApiCatSegmentReplicationWithIndexRequest {
	r.format = &format
	return r
}

// If &#x60;true&#x60;, the response only includes ongoing segment replication events.
func (r ApiCatSegmentReplicationWithIndexRequest) ActiveOnly(activeOnly bool) ApiCatSegmentReplicationWithIndexRequest {
	r.activeOnly = &activeOnly
	return r
}

// If &#x60;true&#x60;, the response only includes latest completed segment replication events.
func (r ApiCatSegmentReplicationWithIndexRequest) CompletedOnly(completedOnly bool) ApiCatSegmentReplicationWithIndexRequest {
	r.completedOnly = &completedOnly
	return r
}

// The unit in which to display byte values.
func (r ApiCatSegmentReplicationWithIndexRequest) Bytes(bytes Bytes) ApiCatSegmentReplicationWithIndexRequest {
	r.bytes = &bytes
	return r
}

// If &#x60;true&#x60;, the response includes detailed information about segment replications.
func (r ApiCatSegmentReplicationWithIndexRequest) Detailed(detailed bool) ApiCatSegmentReplicationWithIndexRequest {
	r.detailed = &detailed
	return r
}

// Comma-separated list of shards to display.
func (r ApiCatSegmentReplicationWithIndexRequest) Shards(shards []string) ApiCatSegmentReplicationWithIndexRequest {
	r.shards = &shards
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatSegmentReplicationWithIndexRequest) H(h []string) ApiCatSegmentReplicationWithIndexRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatSegmentReplicationWithIndexRequest) Help(help bool) ApiCatSegmentReplicationWithIndexRequest {
	r.help = &help
	return r
}

// Comma-separated list or wildcard expression of index names to limit the returned information.
func (r ApiCatSegmentReplicationWithIndexRequest) Index2(index2 []string) ApiCatSegmentReplicationWithIndexRequest {
	r.index2 = &index2
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatSegmentReplicationWithIndexRequest) S(s []string) ApiCatSegmentReplicationWithIndexRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r ApiCatSegmentReplicationWithIndexRequest) Time(time Time) ApiCatSegmentReplicationWithIndexRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatSegmentReplicationWithIndexRequest) V(v bool) ApiCatSegmentReplicationWithIndexRequest {
	r.v = &v
	return r
}

func (r ApiCatSegmentReplicationWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatSegmentReplicationWithIndexExecute(r)
}

/*
CatSegmentReplicationWithIndex Method for CatSegmentReplicationWithIndex

Returns information about both on-going and latest completed Segment Replication events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list or wildcard expression of index names to limit the returned information.
 @return ApiCatSegmentReplicationWithIndexRequest
*/
func (a *DefaultAPIService) CatSegmentReplicationWithIndex(ctx context.Context, index string) ApiCatSegmentReplicationWithIndexRequest {
	return ApiCatSegmentReplicationWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatSegmentReplicationWithIndexExecute(r ApiCatSegmentReplicationWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatSegmentReplicationWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/segment_replication/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_only", r.activeOnly, "")
	} else {
		var defaultValue bool = false
		r.activeOnly = &defaultValue
	}
	if r.completedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completed_only", r.completedOnly, "")
	} else {
		var defaultValue bool = false
		r.completedOnly = &defaultValue
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.shards != nil {
		t := *r.shards
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shards", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shards", t, "multi")
		}
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.index2 != nil {
		t := *r.index2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "index", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "index", t, "multi")
		}
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatSegmentsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	bytes *Bytes
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatSegmentsRequest) Format(format string) ApiCatSegmentsRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r ApiCatSegmentsRequest) Bytes(bytes Bytes) ApiCatSegmentsRequest {
	r.bytes = &bytes
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatSegmentsRequest) MasterTimeout(masterTimeout string) ApiCatSegmentsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatSegmentsRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatSegmentsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatSegmentsRequest) H(h []string) ApiCatSegmentsRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatSegmentsRequest) Help(help bool) ApiCatSegmentsRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatSegmentsRequest) S(s []string) ApiCatSegmentsRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatSegmentsRequest) V(v bool) ApiCatSegmentsRequest {
	r.v = &v
	return r
}

func (r ApiCatSegmentsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatSegmentsExecute(r)
}

/*
CatSegments Method for CatSegments

Provides low-level information about the segments in the shards of an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatSegmentsRequest
*/
func (a *DefaultAPIService) CatSegments(ctx context.Context) ApiCatSegmentsRequest {
	return ApiCatSegmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatSegmentsExecute(r ApiCatSegmentsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatSegments")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatSegmentsWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	format *string
	bytes *Bytes
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatSegmentsWithIndexRequest) Format(format string) ApiCatSegmentsWithIndexRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r ApiCatSegmentsWithIndexRequest) Bytes(bytes Bytes) ApiCatSegmentsWithIndexRequest {
	r.bytes = &bytes
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatSegmentsWithIndexRequest) MasterTimeout(masterTimeout string) ApiCatSegmentsWithIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatSegmentsWithIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatSegmentsWithIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatSegmentsWithIndexRequest) H(h []string) ApiCatSegmentsWithIndexRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatSegmentsWithIndexRequest) Help(help bool) ApiCatSegmentsWithIndexRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatSegmentsWithIndexRequest) S(s []string) ApiCatSegmentsWithIndexRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatSegmentsWithIndexRequest) V(v bool) ApiCatSegmentsWithIndexRequest {
	r.v = &v
	return r
}

func (r ApiCatSegmentsWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatSegmentsWithIndexExecute(r)
}

/*
CatSegmentsWithIndex Method for CatSegmentsWithIndex

Provides low-level information about the segments in the shards of an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to limit the returned information.
 @return ApiCatSegmentsWithIndexRequest
*/
func (a *DefaultAPIService) CatSegmentsWithIndex(ctx context.Context, index string) ApiCatSegmentsWithIndexRequest {
	return ApiCatSegmentsWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatSegmentsWithIndexExecute(r ApiCatSegmentsWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatSegmentsWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/segments/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatShardsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	bytes *Bytes
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatShardsRequest) Format(format string) ApiCatShardsRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r ApiCatShardsRequest) Bytes(bytes Bytes) ApiCatShardsRequest {
	r.bytes = &bytes
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatShardsRequest) Local(local bool) ApiCatShardsRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatShardsRequest) MasterTimeout(masterTimeout string) ApiCatShardsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatShardsRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatShardsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatShardsRequest) H(h []string) ApiCatShardsRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatShardsRequest) Help(help bool) ApiCatShardsRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatShardsRequest) S(s []string) ApiCatShardsRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r ApiCatShardsRequest) Time(time Time) ApiCatShardsRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatShardsRequest) V(v bool) ApiCatShardsRequest {
	r.v = &v
	return r
}

func (r ApiCatShardsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatShardsExecute(r)
}

/*
CatShards Method for CatShards

Provides a detailed view of shard allocation on nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatShardsRequest
*/
func (a *DefaultAPIService) CatShards(ctx context.Context) ApiCatShardsRequest {
	return ApiCatShardsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatShardsExecute(r ApiCatShardsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatShards")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/shards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatShardsWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	format *string
	bytes *Bytes
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatShardsWithIndexRequest) Format(format string) ApiCatShardsWithIndexRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r ApiCatShardsWithIndexRequest) Bytes(bytes Bytes) ApiCatShardsWithIndexRequest {
	r.bytes = &bytes
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatShardsWithIndexRequest) Local(local bool) ApiCatShardsWithIndexRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatShardsWithIndexRequest) MasterTimeout(masterTimeout string) ApiCatShardsWithIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatShardsWithIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatShardsWithIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatShardsWithIndexRequest) H(h []string) ApiCatShardsWithIndexRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatShardsWithIndexRequest) Help(help bool) ApiCatShardsWithIndexRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatShardsWithIndexRequest) S(s []string) ApiCatShardsWithIndexRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r ApiCatShardsWithIndexRequest) Time(time Time) ApiCatShardsWithIndexRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatShardsWithIndexRequest) V(v bool) ApiCatShardsWithIndexRequest {
	r.v = &v
	return r
}

func (r ApiCatShardsWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatShardsWithIndexExecute(r)
}

/*
CatShardsWithIndex Method for CatShardsWithIndex

Provides a detailed view of shard allocation on nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to limit the returned information.
 @return ApiCatShardsWithIndexRequest
*/
func (a *DefaultAPIService) CatShardsWithIndex(ctx context.Context, index string) ApiCatShardsWithIndexRequest {
	return ApiCatShardsWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatShardsWithIndexExecute(r ApiCatShardsWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatShardsWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/shards/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatSnapshotsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	ignoreUnavailable *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatSnapshotsRequest) Format(format string) ApiCatSnapshotsRequest {
	r.format = &format
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiCatSnapshotsRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiCatSnapshotsRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatSnapshotsRequest) MasterTimeout(masterTimeout string) ApiCatSnapshotsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatSnapshotsRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatSnapshotsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatSnapshotsRequest) H(h []string) ApiCatSnapshotsRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatSnapshotsRequest) Help(help bool) ApiCatSnapshotsRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatSnapshotsRequest) S(s []string) ApiCatSnapshotsRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r ApiCatSnapshotsRequest) Time(time Time) ApiCatSnapshotsRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatSnapshotsRequest) V(v bool) ApiCatSnapshotsRequest {
	r.v = &v
	return r
}

func (r ApiCatSnapshotsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatSnapshotsExecute(r)
}

/*
CatSnapshots Method for CatSnapshots

Returns all snapshots in a specific repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatSnapshotsRequest
*/
func (a *DefaultAPIService) CatSnapshots(ctx context.Context) ApiCatSnapshotsRequest {
	return ApiCatSnapshotsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatSnapshotsExecute(r ApiCatSnapshotsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatSnapshots")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/snapshots"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatSnapshotsWithRepositoryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	format *string
	ignoreUnavailable *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatSnapshotsWithRepositoryRequest) Format(format string) ApiCatSnapshotsWithRepositoryRequest {
	r.format = &format
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiCatSnapshotsWithRepositoryRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiCatSnapshotsWithRepositoryRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatSnapshotsWithRepositoryRequest) MasterTimeout(masterTimeout string) ApiCatSnapshotsWithRepositoryRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatSnapshotsWithRepositoryRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatSnapshotsWithRepositoryRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatSnapshotsWithRepositoryRequest) H(h []string) ApiCatSnapshotsWithRepositoryRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatSnapshotsWithRepositoryRequest) Help(help bool) ApiCatSnapshotsWithRepositoryRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatSnapshotsWithRepositoryRequest) S(s []string) ApiCatSnapshotsWithRepositoryRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r ApiCatSnapshotsWithRepositoryRequest) Time(time Time) ApiCatSnapshotsWithRepositoryRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatSnapshotsWithRepositoryRequest) V(v bool) ApiCatSnapshotsWithRepositoryRequest {
	r.v = &v
	return r
}

func (r ApiCatSnapshotsWithRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatSnapshotsWithRepositoryExecute(r)
}

/*
CatSnapshotsWithRepository Method for CatSnapshotsWithRepository

Returns all snapshots in a specific repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Comma-separated list of repository names.
 @return ApiCatSnapshotsWithRepositoryRequest
*/
func (a *DefaultAPIService) CatSnapshotsWithRepository(ctx context.Context, repository string) ApiCatSnapshotsWithRepositoryRequest {
	return ApiCatSnapshotsWithRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatSnapshotsWithRepositoryExecute(r ApiCatSnapshotsWithRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatSnapshotsWithRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/snapshots/{repository}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatTasksRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	nodes *[]string
	actions *[]string
	detailed *bool
	parentTaskId *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatTasksRequest) Format(format string) ApiCatTasksRequest {
	r.format = &format
	return r
}

// Comma-separated list of node IDs or names to limit the returned information; use &#x60;_local&#x60; to return information from the node you&#39;re connecting to, leave empty to get information from all nodes.
func (r ApiCatTasksRequest) Nodes(nodes []string) ApiCatTasksRequest {
	r.nodes = &nodes
	return r
}

// Comma-separated list of actions that should be returned. Leave empty to return all.
func (r ApiCatTasksRequest) Actions(actions []string) ApiCatTasksRequest {
	r.actions = &actions
	return r
}

// Return detailed task information.
func (r ApiCatTasksRequest) Detailed(detailed bool) ApiCatTasksRequest {
	r.detailed = &detailed
	return r
}

// Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
func (r ApiCatTasksRequest) ParentTaskId(parentTaskId string) ApiCatTasksRequest {
	r.parentTaskId = &parentTaskId
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatTasksRequest) H(h []string) ApiCatTasksRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatTasksRequest) Help(help bool) ApiCatTasksRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatTasksRequest) S(s []string) ApiCatTasksRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r ApiCatTasksRequest) Time(time Time) ApiCatTasksRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatTasksRequest) V(v bool) ApiCatTasksRequest {
	r.v = &v
	return r
}

func (r ApiCatTasksRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatTasksExecute(r)
}

/*
CatTasks Method for CatTasks

Returns information about the tasks currently executing on one or more nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatTasksRequest
*/
func (a *DefaultAPIService) CatTasks(ctx context.Context) ApiCatTasksRequest {
	return ApiCatTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatTasksExecute(r ApiCatTasksRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatTasks")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.nodes != nil {
		t := *r.nodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", t, "multi")
		}
	}
	if r.actions != nil {
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "multi")
		}
	}
	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.parentTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_task_id", r.parentTaskId, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatTemplatesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatTemplatesRequest) Format(format string) ApiCatTemplatesRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatTemplatesRequest) Local(local bool) ApiCatTemplatesRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatTemplatesRequest) MasterTimeout(masterTimeout string) ApiCatTemplatesRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatTemplatesRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatTemplatesRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatTemplatesRequest) H(h []string) ApiCatTemplatesRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatTemplatesRequest) Help(help bool) ApiCatTemplatesRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatTemplatesRequest) S(s []string) ApiCatTemplatesRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatTemplatesRequest) V(v bool) ApiCatTemplatesRequest {
	r.v = &v
	return r
}

func (r ApiCatTemplatesRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatTemplatesExecute(r)
}

/*
CatTemplates Method for CatTemplates

Returns information about existing templates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatTemplatesRequest
*/
func (a *DefaultAPIService) CatTemplates(ctx context.Context) ApiCatTemplatesRequest {
	return ApiCatTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatTemplatesExecute(r ApiCatTemplatesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatTemplates")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatTemplatesWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatTemplatesWithNameRequest) Format(format string) ApiCatTemplatesWithNameRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatTemplatesWithNameRequest) Local(local bool) ApiCatTemplatesWithNameRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatTemplatesWithNameRequest) MasterTimeout(masterTimeout string) ApiCatTemplatesWithNameRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatTemplatesWithNameRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatTemplatesWithNameRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatTemplatesWithNameRequest) H(h []string) ApiCatTemplatesWithNameRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatTemplatesWithNameRequest) Help(help bool) ApiCatTemplatesWithNameRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatTemplatesWithNameRequest) S(s []string) ApiCatTemplatesWithNameRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatTemplatesWithNameRequest) V(v bool) ApiCatTemplatesWithNameRequest {
	r.v = &v
	return r
}

func (r ApiCatTemplatesWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatTemplatesWithNameExecute(r)
}

/*
CatTemplatesWithName Method for CatTemplatesWithName

Returns information about existing templates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return ApiCatTemplatesWithNameRequest
*/
func (a *DefaultAPIService) CatTemplatesWithName(ctx context.Context, name string) ApiCatTemplatesWithNameRequest {
	return ApiCatTemplatesWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatTemplatesWithNameExecute(r ApiCatTemplatesWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatTemplatesWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/templates/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatThreadPoolRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	size *int32
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatThreadPoolRequest) Format(format string) ApiCatThreadPoolRequest {
	r.format = &format
	return r
}

// The multiplier in which to display values.
func (r ApiCatThreadPoolRequest) Size(size int32) ApiCatThreadPoolRequest {
	r.size = &size
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatThreadPoolRequest) Local(local bool) ApiCatThreadPoolRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatThreadPoolRequest) MasterTimeout(masterTimeout string) ApiCatThreadPoolRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatThreadPoolRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatThreadPoolRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatThreadPoolRequest) H(h []string) ApiCatThreadPoolRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatThreadPoolRequest) Help(help bool) ApiCatThreadPoolRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatThreadPoolRequest) S(s []string) ApiCatThreadPoolRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatThreadPoolRequest) V(v bool) ApiCatThreadPoolRequest {
	r.v = &v
	return r
}

func (r ApiCatThreadPoolRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatThreadPoolExecute(r)
}

/*
CatThreadPool Method for CatThreadPool

Returns cluster-wide thread pool statistics per node.
By default the active, queue and rejected statistics are returned for all thread pools.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCatThreadPoolRequest
*/
func (a *DefaultAPIService) CatThreadPool(ctx context.Context) ApiCatThreadPoolRequest {
	return ApiCatThreadPoolRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatThreadPoolExecute(r ApiCatThreadPoolRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatThreadPool")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/thread_pool"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatThreadPoolWithThreadPoolPatternsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	threadPoolPatterns string
	format *string
	size *int32
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r ApiCatThreadPoolWithThreadPoolPatternsRequest) Format(format string) ApiCatThreadPoolWithThreadPoolPatternsRequest {
	r.format = &format
	return r
}

// The multiplier in which to display values.
func (r ApiCatThreadPoolWithThreadPoolPatternsRequest) Size(size int32) ApiCatThreadPoolWithThreadPoolPatternsRequest {
	r.size = &size
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiCatThreadPoolWithThreadPoolPatternsRequest) Local(local bool) ApiCatThreadPoolWithThreadPoolPatternsRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiCatThreadPoolWithThreadPoolPatternsRequest) MasterTimeout(masterTimeout string) ApiCatThreadPoolWithThreadPoolPatternsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiCatThreadPoolWithThreadPoolPatternsRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiCatThreadPoolWithThreadPoolPatternsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r ApiCatThreadPoolWithThreadPoolPatternsRequest) H(h []string) ApiCatThreadPoolWithThreadPoolPatternsRequest {
	r.h = &h
	return r
}

// Return help information.
func (r ApiCatThreadPoolWithThreadPoolPatternsRequest) Help(help bool) ApiCatThreadPoolWithThreadPoolPatternsRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r ApiCatThreadPoolWithThreadPoolPatternsRequest) S(s []string) ApiCatThreadPoolWithThreadPoolPatternsRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r ApiCatThreadPoolWithThreadPoolPatternsRequest) V(v bool) ApiCatThreadPoolWithThreadPoolPatternsRequest {
	r.v = &v
	return r
}

func (r ApiCatThreadPoolWithThreadPoolPatternsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatThreadPoolWithThreadPoolPatternsExecute(r)
}

/*
CatThreadPoolWithThreadPoolPatterns Method for CatThreadPoolWithThreadPoolPatterns

Returns cluster-wide thread pool statistics per node.
By default the active, queue and rejected statistics are returned for all thread pools.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param threadPoolPatterns Comma-separated list of regular-expressions to filter the thread pools in the output.
 @return ApiCatThreadPoolWithThreadPoolPatternsRequest
*/
func (a *DefaultAPIService) CatThreadPoolWithThreadPoolPatterns(ctx context.Context, threadPoolPatterns string) ApiCatThreadPoolWithThreadPoolPatternsRequest {
	return ApiCatThreadPoolWithThreadPoolPatternsRequest{
		ApiService: a,
		ctx: ctx,
		threadPoolPatterns: threadPoolPatterns,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatThreadPoolWithThreadPoolPatternsExecute(r ApiCatThreadPoolWithThreadPoolPatternsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatThreadPoolWithThreadPoolPatterns")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/thread_pool/{thread_pool_patterns}"
	localVarPath = strings.Replace(localVarPath, "{"+"thread_pool_patterns"+"}", url.PathEscape(parameterValueToString(r.threadPoolPatterns, "threadPoolPatterns")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChangePasswordRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	changePasswordRequestContent *ChangePasswordRequestContent
}

func (r ApiChangePasswordRequest) ChangePasswordRequestContent(changePasswordRequestContent ChangePasswordRequestContent) ApiChangePasswordRequest {
	r.changePasswordRequestContent = &changePasswordRequestContent
	return r
}

func (r ApiChangePasswordRequest) Execute() (*ChangePasswordResponseContent, *http.Response, error) {
	return r.ApiService.ChangePasswordExecute(r)
}

/*
ChangePassword Method for ChangePassword

Changes the password for the current user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChangePasswordRequest
*/
func (a *DefaultAPIService) ChangePassword(ctx context.Context) ApiChangePasswordRequest {
	return ApiChangePasswordRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangePasswordResponseContent
func (a *DefaultAPIService) ChangePasswordExecute(r ApiChangePasswordRequest) (*ChangePasswordResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangePasswordResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ChangePassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.changePasswordRequestContent == nil {
		return localVarReturnValue, nil, reportError("changePasswordRequestContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.changePasswordRequestContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClearScrollRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
}

func (r ApiClearScrollRequest) Body(body map[string]interface{}) ApiClearScrollRequest {
	r.body = &body
	return r
}

func (r ApiClearScrollRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClearScrollExecute(r)
}

/*
ClearScroll Method for ClearScroll

Explicitly clears the search context for a scroll.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClearScrollRequest
*/
func (a *DefaultAPIService) ClearScroll(ctx context.Context) ApiClearScrollRequest {
	return ApiClearScrollRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClearScrollExecute(r ApiClearScrollRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClearScroll")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/scroll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClearScrollWithScrollIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	scrollId string
	body *map[string]interface{}
}

func (r ApiClearScrollWithScrollIdRequest) Body(body map[string]interface{}) ApiClearScrollWithScrollIdRequest {
	r.body = &body
	return r
}

func (r ApiClearScrollWithScrollIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClearScrollWithScrollIdExecute(r)
}

/*
ClearScrollWithScrollId Method for ClearScrollWithScrollId

Explicitly clears the search context for a scroll.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param scrollId Comma-separated list of scroll IDs to clear.
 @return ApiClearScrollWithScrollIdRequest

Deprecated
*/
func (a *DefaultAPIService) ClearScrollWithScrollId(ctx context.Context, scrollId string) ApiClearScrollWithScrollIdRequest {
	return ApiClearScrollWithScrollIdRequest{
		ApiService: a,
		ctx: ctx,
		scrollId: scrollId,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) ClearScrollWithScrollIdExecute(r ApiClearScrollWithScrollIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClearScrollWithScrollId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/scroll/{scroll_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"scroll_id"+"}", url.PathEscape(parameterValueToString(r.scrollId, "scrollId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterAllocationExplainGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	includeYesDecisions *bool
	includeDiskInfo *bool
}

// Return &#39;YES&#39; decisions in explanation.
func (r ApiClusterAllocationExplainGetRequest) IncludeYesDecisions(includeYesDecisions bool) ApiClusterAllocationExplainGetRequest {
	r.includeYesDecisions = &includeYesDecisions
	return r
}

// Return information about disk usage and shard sizes.
func (r ApiClusterAllocationExplainGetRequest) IncludeDiskInfo(includeDiskInfo bool) ApiClusterAllocationExplainGetRequest {
	r.includeDiskInfo = &includeDiskInfo
	return r
}

func (r ApiClusterAllocationExplainGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterAllocationExplainGetExecute(r)
}

/*
ClusterAllocationExplainGet Method for ClusterAllocationExplainGet

Provides explanations for shard allocations in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterAllocationExplainGetRequest
*/
func (a *DefaultAPIService) ClusterAllocationExplainGet(ctx context.Context) ApiClusterAllocationExplainGetRequest {
	return ApiClusterAllocationExplainGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterAllocationExplainGetExecute(r ApiClusterAllocationExplainGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterAllocationExplainGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/allocation/explain"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeYesDecisions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_yes_decisions", r.includeYesDecisions, "")
	} else {
		var defaultValue bool = false
		r.includeYesDecisions = &defaultValue
	}
	if r.includeDiskInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_disk_info", r.includeDiskInfo, "")
	} else {
		var defaultValue bool = false
		r.includeDiskInfo = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterAllocationExplainPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	includeYesDecisions *bool
	includeDiskInfo *bool
	body *map[string]interface{}
}

// Return &#39;YES&#39; decisions in explanation.
func (r ApiClusterAllocationExplainPostRequest) IncludeYesDecisions(includeYesDecisions bool) ApiClusterAllocationExplainPostRequest {
	r.includeYesDecisions = &includeYesDecisions
	return r
}

// Return information about disk usage and shard sizes.
func (r ApiClusterAllocationExplainPostRequest) IncludeDiskInfo(includeDiskInfo bool) ApiClusterAllocationExplainPostRequest {
	r.includeDiskInfo = &includeDiskInfo
	return r
}

func (r ApiClusterAllocationExplainPostRequest) Body(body map[string]interface{}) ApiClusterAllocationExplainPostRequest {
	r.body = &body
	return r
}

func (r ApiClusterAllocationExplainPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterAllocationExplainPostExecute(r)
}

/*
ClusterAllocationExplainPost Method for ClusterAllocationExplainPost

Provides explanations for shard allocations in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterAllocationExplainPostRequest
*/
func (a *DefaultAPIService) ClusterAllocationExplainPost(ctx context.Context) ApiClusterAllocationExplainPostRequest {
	return ApiClusterAllocationExplainPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterAllocationExplainPostExecute(r ApiClusterAllocationExplainPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterAllocationExplainPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/allocation/explain"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeYesDecisions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_yes_decisions", r.includeYesDecisions, "")
	} else {
		var defaultValue bool = false
		r.includeYesDecisions = &defaultValue
	}
	if r.includeDiskInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_disk_info", r.includeDiskInfo, "")
	} else {
		var defaultValue bool = false
		r.includeDiskInfo = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterDeleteComponentTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout.
func (r ApiClusterDeleteComponentTemplateRequest) Timeout(timeout string) ApiClusterDeleteComponentTemplateRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiClusterDeleteComponentTemplateRequest) MasterTimeout(masterTimeout string) ApiClusterDeleteComponentTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiClusterDeleteComponentTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiClusterDeleteComponentTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiClusterDeleteComponentTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterDeleteComponentTemplateExecute(r)
}

/*
ClusterDeleteComponentTemplate Method for ClusterDeleteComponentTemplate

Deletes a component template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return ApiClusterDeleteComponentTemplateRequest
*/
func (a *DefaultAPIService) ClusterDeleteComponentTemplate(ctx context.Context, name string) ApiClusterDeleteComponentTemplateRequest {
	return ApiClusterDeleteComponentTemplateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterDeleteComponentTemplateExecute(r ApiClusterDeleteComponentTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterDeleteComponentTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_component_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterDeleteDecommissionAwarenessRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiClusterDeleteDecommissionAwarenessRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterDeleteDecommissionAwarenessExecute(r)
}

/*
ClusterDeleteDecommissionAwareness Method for ClusterDeleteDecommissionAwareness

Delete any existing decommission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterDeleteDecommissionAwarenessRequest
*/
func (a *DefaultAPIService) ClusterDeleteDecommissionAwareness(ctx context.Context) ApiClusterDeleteDecommissionAwarenessRequest {
	return ApiClusterDeleteDecommissionAwarenessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterDeleteDecommissionAwarenessExecute(r ApiClusterDeleteDecommissionAwarenessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterDeleteDecommissionAwareness")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/decommission/awareness/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterDeleteVotingConfigExclusionsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	waitForRemoval *bool
}

// Specifies whether to wait for all excluded nodes to be removed from the cluster before clearing the voting configuration exclusions list.
func (r ApiClusterDeleteVotingConfigExclusionsRequest) WaitForRemoval(waitForRemoval bool) ApiClusterDeleteVotingConfigExclusionsRequest {
	r.waitForRemoval = &waitForRemoval
	return r
}

func (r ApiClusterDeleteVotingConfigExclusionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterDeleteVotingConfigExclusionsExecute(r)
}

/*
ClusterDeleteVotingConfigExclusions Method for ClusterDeleteVotingConfigExclusions

Clears cluster voting config exclusions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterDeleteVotingConfigExclusionsRequest
*/
func (a *DefaultAPIService) ClusterDeleteVotingConfigExclusions(ctx context.Context) ApiClusterDeleteVotingConfigExclusionsRequest {
	return ApiClusterDeleteVotingConfigExclusionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterDeleteVotingConfigExclusionsExecute(r ApiClusterDeleteVotingConfigExclusionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterDeleteVotingConfigExclusions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/voting_config_exclusions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.waitForRemoval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_removal", r.waitForRemoval, "")
	} else {
		var defaultValue bool = true
		r.waitForRemoval = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterDeleteWeightedRoutingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiClusterDeleteWeightedRoutingRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterDeleteWeightedRoutingExecute(r)
}

/*
ClusterDeleteWeightedRouting Method for ClusterDeleteWeightedRouting

Delete weighted shard routing weights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterDeleteWeightedRoutingRequest
*/
func (a *DefaultAPIService) ClusterDeleteWeightedRouting(ctx context.Context) ApiClusterDeleteWeightedRoutingRequest {
	return ApiClusterDeleteWeightedRoutingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterDeleteWeightedRoutingExecute(r ApiClusterDeleteWeightedRoutingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterDeleteWeightedRouting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/routing/awareness/weights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterExistsComponentTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	masterTimeout *string
	local *bool
}

// Operation timeout for connection to master node.
func (r ApiClusterExistsComponentTemplateRequest) MasterTimeout(masterTimeout string) ApiClusterExistsComponentTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiClusterExistsComponentTemplateRequest) Local(local bool) ApiClusterExistsComponentTemplateRequest {
	r.local = &local
	return r
}

func (r ApiClusterExistsComponentTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterExistsComponentTemplateExecute(r)
}

/*
ClusterExistsComponentTemplate Method for ClusterExistsComponentTemplate

Returns information about whether a particular component template exist.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return ApiClusterExistsComponentTemplateRequest
*/
func (a *DefaultAPIService) ClusterExistsComponentTemplate(ctx context.Context, name string) ApiClusterExistsComponentTemplateRequest {
	return ApiClusterExistsComponentTemplateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterExistsComponentTemplateExecute(r ApiClusterExistsComponentTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterExistsComponentTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_component_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterGetComponentTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Operation timeout for connection to master node.
func (r ApiClusterGetComponentTemplateRequest) MasterTimeout(masterTimeout string) ApiClusterGetComponentTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiClusterGetComponentTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiClusterGetComponentTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiClusterGetComponentTemplateRequest) Local(local bool) ApiClusterGetComponentTemplateRequest {
	r.local = &local
	return r
}

func (r ApiClusterGetComponentTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterGetComponentTemplateExecute(r)
}

/*
ClusterGetComponentTemplate Method for ClusterGetComponentTemplate

Returns one or more component templates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterGetComponentTemplateRequest
*/
func (a *DefaultAPIService) ClusterGetComponentTemplate(ctx context.Context) ApiClusterGetComponentTemplateRequest {
	return ApiClusterGetComponentTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterGetComponentTemplateExecute(r ApiClusterGetComponentTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterGetComponentTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_component_template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterGetComponentTemplateWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Operation timeout for connection to master node.
func (r ApiClusterGetComponentTemplateWithNameRequest) MasterTimeout(masterTimeout string) ApiClusterGetComponentTemplateWithNameRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiClusterGetComponentTemplateWithNameRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiClusterGetComponentTemplateWithNameRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiClusterGetComponentTemplateWithNameRequest) Local(local bool) ApiClusterGetComponentTemplateWithNameRequest {
	r.local = &local
	return r
}

func (r ApiClusterGetComponentTemplateWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterGetComponentTemplateWithNameExecute(r)
}

/*
ClusterGetComponentTemplateWithName Method for ClusterGetComponentTemplateWithName

Returns one or more component templates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The Comma-separated names of the component templates.
 @return ApiClusterGetComponentTemplateWithNameRequest
*/
func (a *DefaultAPIService) ClusterGetComponentTemplateWithName(ctx context.Context, name string) ApiClusterGetComponentTemplateWithNameRequest {
	return ApiClusterGetComponentTemplateWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterGetComponentTemplateWithNameExecute(r ApiClusterGetComponentTemplateWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterGetComponentTemplateWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_component_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterGetDecommissionAwarenessRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	awarenessAttributeName string
}

func (r ApiClusterGetDecommissionAwarenessRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterGetDecommissionAwarenessExecute(r)
}

/*
ClusterGetDecommissionAwareness Method for ClusterGetDecommissionAwareness

Get details and status of decommissioned attribute.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awarenessAttributeName Awareness attribute name.
 @return ApiClusterGetDecommissionAwarenessRequest
*/
func (a *DefaultAPIService) ClusterGetDecommissionAwareness(ctx context.Context, awarenessAttributeName string) ApiClusterGetDecommissionAwarenessRequest {
	return ApiClusterGetDecommissionAwarenessRequest{
		ApiService: a,
		ctx: ctx,
		awarenessAttributeName: awarenessAttributeName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterGetDecommissionAwarenessExecute(r ApiClusterGetDecommissionAwarenessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterGetDecommissionAwareness")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/decommission/awareness/{awareness_attribute_name}/_status"
	localVarPath = strings.Replace(localVarPath, "{"+"awareness_attribute_name"+"}", url.PathEscape(parameterValueToString(r.awarenessAttributeName, "awarenessAttributeName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterGetSettingsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	flatSettings *bool
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	includeDefaults *bool
}

// Return settings in flat format.
func (r ApiClusterGetSettingsRequest) FlatSettings(flatSettings bool) ApiClusterGetSettingsRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r ApiClusterGetSettingsRequest) MasterTimeout(masterTimeout string) ApiClusterGetSettingsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiClusterGetSettingsRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiClusterGetSettingsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r ApiClusterGetSettingsRequest) Timeout(timeout string) ApiClusterGetSettingsRequest {
	r.timeout = &timeout
	return r
}

// Whether to return all default clusters setting.
func (r ApiClusterGetSettingsRequest) IncludeDefaults(includeDefaults bool) ApiClusterGetSettingsRequest {
	r.includeDefaults = &includeDefaults
	return r
}

func (r ApiClusterGetSettingsRequest) Execute() (*ClusterGetSettingsResponseContent, *http.Response, error) {
	return r.ApiService.ClusterGetSettingsExecute(r)
}

/*
ClusterGetSettings Method for ClusterGetSettings

Returns cluster settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterGetSettingsRequest
*/
func (a *DefaultAPIService) ClusterGetSettings(ctx context.Context) ApiClusterGetSettingsRequest {
	return ApiClusterGetSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClusterGetSettingsResponseContent
func (a *DefaultAPIService) ClusterGetSettingsExecute(r ApiClusterGetSettingsRequest) (*ClusterGetSettingsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterGetSettingsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterGetSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	} else {
		var defaultValue bool = false
		r.includeDefaults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClusterGetWeightedRoutingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	attribute string
}

func (r ApiClusterGetWeightedRoutingRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterGetWeightedRoutingExecute(r)
}

/*
ClusterGetWeightedRouting Method for ClusterGetWeightedRouting

Fetches weighted shard routing weights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attribute Awareness attribute name.
 @return ApiClusterGetWeightedRoutingRequest
*/
func (a *DefaultAPIService) ClusterGetWeightedRouting(ctx context.Context, attribute string) ApiClusterGetWeightedRoutingRequest {
	return ApiClusterGetWeightedRoutingRequest{
		ApiService: a,
		ctx: ctx,
		attribute: attribute,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterGetWeightedRoutingExecute(r ApiClusterGetWeightedRoutingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterGetWeightedRouting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/routing/awareness/{attribute}/weights"
	localVarPath = strings.Replace(localVarPath, "{"+"attribute"+"}", url.PathEscape(parameterValueToString(r.attribute, "attribute")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterHealthRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	expandWildcards *ExpandWildcards
	level *ClusterHealthLevel
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	waitForActiveShards *string
	waitForNodes *string
	waitForEvents *WaitForEvents
	waitForNoRelocatingShards *bool
	waitForNoInitializingShards *bool
	waitForStatus *WaitForStatus
	awarenessAttribute *string
	ensureNodeCommissioned *bool
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiClusterHealthRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiClusterHealthRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify the level of detail for returned information.
func (r ApiClusterHealthRequest) Level(level ClusterHealthLevel) ApiClusterHealthRequest {
	r.level = &level
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiClusterHealthRequest) Local(local bool) ApiClusterHealthRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiClusterHealthRequest) MasterTimeout(masterTimeout string) ApiClusterHealthRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiClusterHealthRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiClusterHealthRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r ApiClusterHealthRequest) Timeout(timeout string) ApiClusterHealthRequest {
	r.timeout = &timeout
	return r
}

// Wait until the specified number of shards is active.
func (r ApiClusterHealthRequest) WaitForActiveShards(waitForActiveShards string) ApiClusterHealthRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Wait until the specified number of nodes is available.
func (r ApiClusterHealthRequest) WaitForNodes(waitForNodes string) ApiClusterHealthRequest {
	r.waitForNodes = &waitForNodes
	return r
}

// Wait until all currently queued events with the given priority are processed.
func (r ApiClusterHealthRequest) WaitForEvents(waitForEvents WaitForEvents) ApiClusterHealthRequest {
	r.waitForEvents = &waitForEvents
	return r
}

// Whether to wait until there are no relocating shards in the cluster.
func (r ApiClusterHealthRequest) WaitForNoRelocatingShards(waitForNoRelocatingShards bool) ApiClusterHealthRequest {
	r.waitForNoRelocatingShards = &waitForNoRelocatingShards
	return r
}

// Whether to wait until there are no initializing shards in the cluster.
func (r ApiClusterHealthRequest) WaitForNoInitializingShards(waitForNoInitializingShards bool) ApiClusterHealthRequest {
	r.waitForNoInitializingShards = &waitForNoInitializingShards
	return r
}

// Wait until cluster is in a specific state.
func (r ApiClusterHealthRequest) WaitForStatus(waitForStatus WaitForStatus) ApiClusterHealthRequest {
	r.waitForStatus = &waitForStatus
	return r
}

// The awareness attribute for which the health is required.
func (r ApiClusterHealthRequest) AwarenessAttribute(awarenessAttribute string) ApiClusterHealthRequest {
	r.awarenessAttribute = &awarenessAttribute
	return r
}

// Checks whether local node is commissioned or not. If set to true on a local call it will throw exception if node is decommissioned.
func (r ApiClusterHealthRequest) EnsureNodeCommissioned(ensureNodeCommissioned bool) ApiClusterHealthRequest {
	r.ensureNodeCommissioned = &ensureNodeCommissioned
	return r
}

func (r ApiClusterHealthRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterHealthExecute(r)
}

/*
ClusterHealth Method for ClusterHealth

Returns basic information about the health of the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterHealthRequest
*/
func (a *DefaultAPIService) ClusterHealth(ctx context.Context) ApiClusterHealthRequest {
	return ApiClusterHealthRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterHealthExecute(r ApiClusterHealthRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterHealth")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	if r.waitForNodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_nodes", r.waitForNodes, "")
	}
	if r.waitForEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_events", r.waitForEvents, "")
	}
	if r.waitForNoRelocatingShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_no_relocating_shards", r.waitForNoRelocatingShards, "")
	}
	if r.waitForNoInitializingShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_no_initializing_shards", r.waitForNoInitializingShards, "")
	}
	if r.waitForStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_status", r.waitForStatus, "")
	}
	if r.awarenessAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "awareness_attribute", r.awarenessAttribute, "")
	}
	if r.ensureNodeCommissioned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ensure_node_commissioned", r.ensureNodeCommissioned, "")
	} else {
		var defaultValue bool = false
		r.ensureNodeCommissioned = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterHealthWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	expandWildcards *ExpandWildcards
	level *ClusterHealthLevel
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	waitForActiveShards *string
	waitForNodes *string
	waitForEvents *WaitForEvents
	waitForNoRelocatingShards *bool
	waitForNoInitializingShards *bool
	waitForStatus *WaitForStatus
	awarenessAttribute *string
	ensureNodeCommissioned *bool
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiClusterHealthWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiClusterHealthWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify the level of detail for returned information.
func (r ApiClusterHealthWithIndexRequest) Level(level ClusterHealthLevel) ApiClusterHealthWithIndexRequest {
	r.level = &level
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiClusterHealthWithIndexRequest) Local(local bool) ApiClusterHealthWithIndexRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiClusterHealthWithIndexRequest) MasterTimeout(masterTimeout string) ApiClusterHealthWithIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiClusterHealthWithIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiClusterHealthWithIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r ApiClusterHealthWithIndexRequest) Timeout(timeout string) ApiClusterHealthWithIndexRequest {
	r.timeout = &timeout
	return r
}

// Wait until the specified number of shards is active.
func (r ApiClusterHealthWithIndexRequest) WaitForActiveShards(waitForActiveShards string) ApiClusterHealthWithIndexRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Wait until the specified number of nodes is available.
func (r ApiClusterHealthWithIndexRequest) WaitForNodes(waitForNodes string) ApiClusterHealthWithIndexRequest {
	r.waitForNodes = &waitForNodes
	return r
}

// Wait until all currently queued events with the given priority are processed.
func (r ApiClusterHealthWithIndexRequest) WaitForEvents(waitForEvents WaitForEvents) ApiClusterHealthWithIndexRequest {
	r.waitForEvents = &waitForEvents
	return r
}

// Whether to wait until there are no relocating shards in the cluster.
func (r ApiClusterHealthWithIndexRequest) WaitForNoRelocatingShards(waitForNoRelocatingShards bool) ApiClusterHealthWithIndexRequest {
	r.waitForNoRelocatingShards = &waitForNoRelocatingShards
	return r
}

// Whether to wait until there are no initializing shards in the cluster.
func (r ApiClusterHealthWithIndexRequest) WaitForNoInitializingShards(waitForNoInitializingShards bool) ApiClusterHealthWithIndexRequest {
	r.waitForNoInitializingShards = &waitForNoInitializingShards
	return r
}

// Wait until cluster is in a specific state.
func (r ApiClusterHealthWithIndexRequest) WaitForStatus(waitForStatus WaitForStatus) ApiClusterHealthWithIndexRequest {
	r.waitForStatus = &waitForStatus
	return r
}

// The awareness attribute for which the health is required.
func (r ApiClusterHealthWithIndexRequest) AwarenessAttribute(awarenessAttribute string) ApiClusterHealthWithIndexRequest {
	r.awarenessAttribute = &awarenessAttribute
	return r
}

// Checks whether local node is commissioned or not. If set to true on a local call it will throw exception if node is decommissioned.
func (r ApiClusterHealthWithIndexRequest) EnsureNodeCommissioned(ensureNodeCommissioned bool) ApiClusterHealthWithIndexRequest {
	r.ensureNodeCommissioned = &ensureNodeCommissioned
	return r
}

func (r ApiClusterHealthWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterHealthWithIndexExecute(r)
}

/*
ClusterHealthWithIndex Method for ClusterHealthWithIndex

Returns basic information about the health of the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Limit the information returned to specific indicies.
 @return ApiClusterHealthWithIndexRequest
*/
func (a *DefaultAPIService) ClusterHealthWithIndex(ctx context.Context, index string) ApiClusterHealthWithIndexRequest {
	return ApiClusterHealthWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterHealthWithIndexExecute(r ApiClusterHealthWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterHealthWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/health/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	if r.waitForNodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_nodes", r.waitForNodes, "")
	}
	if r.waitForEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_events", r.waitForEvents, "")
	}
	if r.waitForNoRelocatingShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_no_relocating_shards", r.waitForNoRelocatingShards, "")
	}
	if r.waitForNoInitializingShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_no_initializing_shards", r.waitForNoInitializingShards, "")
	}
	if r.waitForStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_status", r.waitForStatus, "")
	}
	if r.awarenessAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "awareness_attribute", r.awarenessAttribute, "")
	}
	if r.ensureNodeCommissioned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ensure_node_commissioned", r.ensureNodeCommissioned, "")
	} else {
		var defaultValue bool = false
		r.ensureNodeCommissioned = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterPendingTasksRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiClusterPendingTasksRequest) Local(local bool) ApiClusterPendingTasksRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiClusterPendingTasksRequest) MasterTimeout(masterTimeout string) ApiClusterPendingTasksRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiClusterPendingTasksRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiClusterPendingTasksRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiClusterPendingTasksRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterPendingTasksExecute(r)
}

/*
ClusterPendingTasks Method for ClusterPendingTasks

Returns a list of any cluster-level changes (e.g. create index, update mapping,
allocate or fail shard) which have not yet been executed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterPendingTasksRequest
*/
func (a *DefaultAPIService) ClusterPendingTasks(ctx context.Context) ApiClusterPendingTasksRequest {
	return ApiClusterPendingTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterPendingTasksExecute(r ApiClusterPendingTasksRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterPendingTasks")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/pending_tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterPostVotingConfigExclusionsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeIds *string
	nodeNames *string
	timeout *string
}

// Comma-separated list of the persistent ids of the nodes to exclude from the voting configuration. If specified, you may not also specify ?node_names.
func (r ApiClusterPostVotingConfigExclusionsRequest) NodeIds(nodeIds string) ApiClusterPostVotingConfigExclusionsRequest {
	r.nodeIds = &nodeIds
	return r
}

// Comma-separated list of the names of the nodes to exclude from the voting configuration. If specified, you may not also specify ?node_ids.
func (r ApiClusterPostVotingConfigExclusionsRequest) NodeNames(nodeNames string) ApiClusterPostVotingConfigExclusionsRequest {
	r.nodeNames = &nodeNames
	return r
}

// Operation timeout.
func (r ApiClusterPostVotingConfigExclusionsRequest) Timeout(timeout string) ApiClusterPostVotingConfigExclusionsRequest {
	r.timeout = &timeout
	return r
}

func (r ApiClusterPostVotingConfigExclusionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterPostVotingConfigExclusionsExecute(r)
}

/*
ClusterPostVotingConfigExclusions Method for ClusterPostVotingConfigExclusions

Updates the cluster voting config exclusions by node ids or node names.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterPostVotingConfigExclusionsRequest
*/
func (a *DefaultAPIService) ClusterPostVotingConfigExclusions(ctx context.Context) ApiClusterPostVotingConfigExclusionsRequest {
	return ApiClusterPostVotingConfigExclusionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterPostVotingConfigExclusionsExecute(r ApiClusterPostVotingConfigExclusionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterPostVotingConfigExclusions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/voting_config_exclusions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodeIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_ids", r.nodeIds, "")
	}
	if r.nodeNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_names", r.nodeNames, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterPutComponentTemplatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	body *map[string]interface{}
	create *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r ApiClusterPutComponentTemplatePostRequest) Body(body map[string]interface{}) ApiClusterPutComponentTemplatePostRequest {
	r.body = &body
	return r
}

// Whether the index template should only be added if new or can also replace an existing one.
func (r ApiClusterPutComponentTemplatePostRequest) Create(create bool) ApiClusterPutComponentTemplatePostRequest {
	r.create = &create
	return r
}

// Operation timeout.
func (r ApiClusterPutComponentTemplatePostRequest) Timeout(timeout string) ApiClusterPutComponentTemplatePostRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiClusterPutComponentTemplatePostRequest) MasterTimeout(masterTimeout string) ApiClusterPutComponentTemplatePostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiClusterPutComponentTemplatePostRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiClusterPutComponentTemplatePostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiClusterPutComponentTemplatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterPutComponentTemplatePostExecute(r)
}

/*
ClusterPutComponentTemplatePost Method for ClusterPutComponentTemplatePost

Creates or updates a component template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return ApiClusterPutComponentTemplatePostRequest
*/
func (a *DefaultAPIService) ClusterPutComponentTemplatePost(ctx context.Context, name string) ApiClusterPutComponentTemplatePostRequest {
	return ApiClusterPutComponentTemplatePostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterPutComponentTemplatePostExecute(r ApiClusterPutComponentTemplatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterPutComponentTemplatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_component_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterPutComponentTemplatePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	body *map[string]interface{}
	create *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r ApiClusterPutComponentTemplatePutRequest) Body(body map[string]interface{}) ApiClusterPutComponentTemplatePutRequest {
	r.body = &body
	return r
}

// Whether the index template should only be added if new or can also replace an existing one.
func (r ApiClusterPutComponentTemplatePutRequest) Create(create bool) ApiClusterPutComponentTemplatePutRequest {
	r.create = &create
	return r
}

// Operation timeout.
func (r ApiClusterPutComponentTemplatePutRequest) Timeout(timeout string) ApiClusterPutComponentTemplatePutRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiClusterPutComponentTemplatePutRequest) MasterTimeout(masterTimeout string) ApiClusterPutComponentTemplatePutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiClusterPutComponentTemplatePutRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiClusterPutComponentTemplatePutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiClusterPutComponentTemplatePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterPutComponentTemplatePutExecute(r)
}

/*
ClusterPutComponentTemplatePut Method for ClusterPutComponentTemplatePut

Creates or updates a component template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return ApiClusterPutComponentTemplatePutRequest
*/
func (a *DefaultAPIService) ClusterPutComponentTemplatePut(ctx context.Context, name string) ApiClusterPutComponentTemplatePutRequest {
	return ApiClusterPutComponentTemplatePutRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterPutComponentTemplatePutExecute(r ApiClusterPutComponentTemplatePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterPutComponentTemplatePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_component_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterPutDecommissionAwarenessRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	awarenessAttributeName string
	awarenessAttributeValue string
}

func (r ApiClusterPutDecommissionAwarenessRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterPutDecommissionAwarenessExecute(r)
}

/*
ClusterPutDecommissionAwareness Method for ClusterPutDecommissionAwareness

Decommissions an awareness attribute.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awarenessAttributeName Awareness attribute name.
 @param awarenessAttributeValue Awareness attribute value.
 @return ApiClusterPutDecommissionAwarenessRequest
*/
func (a *DefaultAPIService) ClusterPutDecommissionAwareness(ctx context.Context, awarenessAttributeName string, awarenessAttributeValue string) ApiClusterPutDecommissionAwarenessRequest {
	return ApiClusterPutDecommissionAwarenessRequest{
		ApiService: a,
		ctx: ctx,
		awarenessAttributeName: awarenessAttributeName,
		awarenessAttributeValue: awarenessAttributeValue,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterPutDecommissionAwarenessExecute(r ApiClusterPutDecommissionAwarenessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterPutDecommissionAwareness")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/decommission/awareness/{awareness_attribute_name}/{awareness_attribute_value}"
	localVarPath = strings.Replace(localVarPath, "{"+"awareness_attribute_name"+"}", url.PathEscape(parameterValueToString(r.awarenessAttributeName, "awarenessAttributeName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awareness_attribute_value"+"}", url.PathEscape(parameterValueToString(r.awarenessAttributeValue, "awarenessAttributeValue")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterPutSettingsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	clusterPutSettingsBodyParams *ClusterPutSettingsBodyParams
	flatSettings *bool
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
}

func (r ApiClusterPutSettingsRequest) ClusterPutSettingsBodyParams(clusterPutSettingsBodyParams ClusterPutSettingsBodyParams) ApiClusterPutSettingsRequest {
	r.clusterPutSettingsBodyParams = &clusterPutSettingsBodyParams
	return r
}

// Return settings in flat format.
func (r ApiClusterPutSettingsRequest) FlatSettings(flatSettings bool) ApiClusterPutSettingsRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r ApiClusterPutSettingsRequest) MasterTimeout(masterTimeout string) ApiClusterPutSettingsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiClusterPutSettingsRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiClusterPutSettingsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r ApiClusterPutSettingsRequest) Timeout(timeout string) ApiClusterPutSettingsRequest {
	r.timeout = &timeout
	return r
}

func (r ApiClusterPutSettingsRequest) Execute() (*ClusterPutSettingsResponseContent, *http.Response, error) {
	return r.ApiService.ClusterPutSettingsExecute(r)
}

/*
ClusterPutSettings Method for ClusterPutSettings

Updates the cluster settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterPutSettingsRequest
*/
func (a *DefaultAPIService) ClusterPutSettings(ctx context.Context) ApiClusterPutSettingsRequest {
	return ApiClusterPutSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClusterPutSettingsResponseContent
func (a *DefaultAPIService) ClusterPutSettingsExecute(r ApiClusterPutSettingsRequest) (*ClusterPutSettingsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterPutSettingsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterPutSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterPutSettingsBodyParams == nil {
		return localVarReturnValue, nil, reportError("clusterPutSettingsBodyParams is required and must be specified")
	}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clusterPutSettingsBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClusterPutWeightedRoutingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	attribute string
}

func (r ApiClusterPutWeightedRoutingRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterPutWeightedRoutingExecute(r)
}

/*
ClusterPutWeightedRouting Method for ClusterPutWeightedRouting

Updates weighted shard routing weights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attribute Awareness attribute name.
 @return ApiClusterPutWeightedRoutingRequest
*/
func (a *DefaultAPIService) ClusterPutWeightedRouting(ctx context.Context, attribute string) ApiClusterPutWeightedRoutingRequest {
	return ApiClusterPutWeightedRoutingRequest{
		ApiService: a,
		ctx: ctx,
		attribute: attribute,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterPutWeightedRoutingExecute(r ApiClusterPutWeightedRoutingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterPutWeightedRouting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/routing/awareness/{attribute}/weights"
	localVarPath = strings.Replace(localVarPath, "{"+"attribute"+"}", url.PathEscape(parameterValueToString(r.attribute, "attribute")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterRemoteInfoRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiClusterRemoteInfoRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterRemoteInfoExecute(r)
}

/*
ClusterRemoteInfo Method for ClusterRemoteInfo

Returns the information about configured remote clusters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterRemoteInfoRequest
*/
func (a *DefaultAPIService) ClusterRemoteInfo(ctx context.Context) ApiClusterRemoteInfoRequest {
	return ApiClusterRemoteInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterRemoteInfoExecute(r ApiClusterRemoteInfoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterRemoteInfo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_remote/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterRerouteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	dryRun *bool
	explain *bool
	retryFailed *bool
	metric *[]ClusterRerouteMetricMember
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	body *map[string]interface{}
}

// Simulate the operation only and return the resulting state.
func (r ApiClusterRerouteRequest) DryRun(dryRun bool) ApiClusterRerouteRequest {
	r.dryRun = &dryRun
	return r
}

// Return an explanation of why the commands can or cannot be executed.
func (r ApiClusterRerouteRequest) Explain(explain bool) ApiClusterRerouteRequest {
	r.explain = &explain
	return r
}

// Retries allocation of shards that are blocked due to too many subsequent allocation failures.
func (r ApiClusterRerouteRequest) RetryFailed(retryFailed bool) ApiClusterRerouteRequest {
	r.retryFailed = &retryFailed
	return r
}

// Limit the information returned to the specified metrics. Defaults to all but metadata.
func (r ApiClusterRerouteRequest) Metric(metric []ClusterRerouteMetricMember) ApiClusterRerouteRequest {
	r.metric = &metric
	return r
}

// Operation timeout for connection to master node.
func (r ApiClusterRerouteRequest) MasterTimeout(masterTimeout string) ApiClusterRerouteRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiClusterRerouteRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiClusterRerouteRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r ApiClusterRerouteRequest) Timeout(timeout string) ApiClusterRerouteRequest {
	r.timeout = &timeout
	return r
}

func (r ApiClusterRerouteRequest) Body(body map[string]interface{}) ApiClusterRerouteRequest {
	r.body = &body
	return r
}

func (r ApiClusterRerouteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterRerouteExecute(r)
}

/*
ClusterReroute Method for ClusterReroute

Allows to manually change the allocation of individual shards in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterRerouteRequest
*/
func (a *DefaultAPIService) ClusterReroute(ctx context.Context) ApiClusterRerouteRequest {
	return ApiClusterRerouteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterRerouteExecute(r ApiClusterRerouteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterReroute")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/reroute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dry_run", r.dryRun, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.retryFailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retry_failed", r.retryFailed, "")
	}
	if r.metric != nil {
		t := *r.metric
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "metric", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "metric", t, "multi")
		}
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterStateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	flatSettings *bool
	waitForMetadataVersion *int32
	waitForTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiClusterStateRequest) Local(local bool) ApiClusterStateRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiClusterStateRequest) MasterTimeout(masterTimeout string) ApiClusterStateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiClusterStateRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiClusterStateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return settings in flat format.
func (r ApiClusterStateRequest) FlatSettings(flatSettings bool) ApiClusterStateRequest {
	r.flatSettings = &flatSettings
	return r
}

// Wait for the metadata version to be equal or greater than the specified metadata version.
func (r ApiClusterStateRequest) WaitForMetadataVersion(waitForMetadataVersion int32) ApiClusterStateRequest {
	r.waitForMetadataVersion = &waitForMetadataVersion
	return r
}

// The maximum time to wait for wait_for_metadata_version before timing out.
func (r ApiClusterStateRequest) WaitForTimeout(waitForTimeout string) ApiClusterStateRequest {
	r.waitForTimeout = &waitForTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiClusterStateRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiClusterStateRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiClusterStateRequest) AllowNoIndices(allowNoIndices bool) ApiClusterStateRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiClusterStateRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiClusterStateRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiClusterStateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterStateExecute(r)
}

/*
ClusterState Method for ClusterState

Returns a comprehensive information about the state of the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterStateRequest
*/
func (a *DefaultAPIService) ClusterState(ctx context.Context) ApiClusterStateRequest {
	return ApiClusterStateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterStateExecute(r ApiClusterStateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterState")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/state"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.waitForMetadataVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_metadata_version", r.waitForMetadataVersion, "")
	}
	if r.waitForTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_timeout", r.waitForTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterStateWithIndexMetricRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	metric string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	flatSettings *bool
	waitForMetadataVersion *int32
	waitForTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiClusterStateWithIndexMetricRequest) Local(local bool) ApiClusterStateWithIndexMetricRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiClusterStateWithIndexMetricRequest) MasterTimeout(masterTimeout string) ApiClusterStateWithIndexMetricRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiClusterStateWithIndexMetricRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiClusterStateWithIndexMetricRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return settings in flat format.
func (r ApiClusterStateWithIndexMetricRequest) FlatSettings(flatSettings bool) ApiClusterStateWithIndexMetricRequest {
	r.flatSettings = &flatSettings
	return r
}

// Wait for the metadata version to be equal or greater than the specified metadata version.
func (r ApiClusterStateWithIndexMetricRequest) WaitForMetadataVersion(waitForMetadataVersion int32) ApiClusterStateWithIndexMetricRequest {
	r.waitForMetadataVersion = &waitForMetadataVersion
	return r
}

// The maximum time to wait for wait_for_metadata_version before timing out.
func (r ApiClusterStateWithIndexMetricRequest) WaitForTimeout(waitForTimeout string) ApiClusterStateWithIndexMetricRequest {
	r.waitForTimeout = &waitForTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiClusterStateWithIndexMetricRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiClusterStateWithIndexMetricRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiClusterStateWithIndexMetricRequest) AllowNoIndices(allowNoIndices bool) ApiClusterStateWithIndexMetricRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiClusterStateWithIndexMetricRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiClusterStateWithIndexMetricRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiClusterStateWithIndexMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterStateWithIndexMetricExecute(r)
}

/*
ClusterStateWithIndexMetric Method for ClusterStateWithIndexMetric

Returns a comprehensive information about the state of the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param metric Limit the information returned to the specified metrics.
 @return ApiClusterStateWithIndexMetricRequest
*/
func (a *DefaultAPIService) ClusterStateWithIndexMetric(ctx context.Context, index string, metric string) ApiClusterStateWithIndexMetricRequest {
	return ApiClusterStateWithIndexMetricRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		metric: metric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterStateWithIndexMetricExecute(r ApiClusterStateWithIndexMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterStateWithIndexMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/state/{metric}/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.waitForMetadataVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_metadata_version", r.waitForMetadataVersion, "")
	}
	if r.waitForTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_timeout", r.waitForTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterStateWithMetricRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	flatSettings *bool
	waitForMetadataVersion *int32
	waitForTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiClusterStateWithMetricRequest) Local(local bool) ApiClusterStateWithMetricRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r ApiClusterStateWithMetricRequest) MasterTimeout(masterTimeout string) ApiClusterStateWithMetricRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiClusterStateWithMetricRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiClusterStateWithMetricRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return settings in flat format.
func (r ApiClusterStateWithMetricRequest) FlatSettings(flatSettings bool) ApiClusterStateWithMetricRequest {
	r.flatSettings = &flatSettings
	return r
}

// Wait for the metadata version to be equal or greater than the specified metadata version.
func (r ApiClusterStateWithMetricRequest) WaitForMetadataVersion(waitForMetadataVersion int32) ApiClusterStateWithMetricRequest {
	r.waitForMetadataVersion = &waitForMetadataVersion
	return r
}

// The maximum time to wait for wait_for_metadata_version before timing out.
func (r ApiClusterStateWithMetricRequest) WaitForTimeout(waitForTimeout string) ApiClusterStateWithMetricRequest {
	r.waitForTimeout = &waitForTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiClusterStateWithMetricRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiClusterStateWithMetricRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiClusterStateWithMetricRequest) AllowNoIndices(allowNoIndices bool) ApiClusterStateWithMetricRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiClusterStateWithMetricRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiClusterStateWithMetricRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiClusterStateWithMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterStateWithMetricExecute(r)
}

/*
ClusterStateWithMetric Method for ClusterStateWithMetric

Returns a comprehensive information about the state of the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned to the specified metrics.
 @return ApiClusterStateWithMetricRequest
*/
func (a *DefaultAPIService) ClusterStateWithMetric(ctx context.Context, metric string) ApiClusterStateWithMetricRequest {
	return ApiClusterStateWithMetricRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterStateWithMetricExecute(r ApiClusterStateWithMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterStateWithMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/state/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.waitForMetadataVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_metadata_version", r.waitForMetadataVersion, "")
	}
	if r.waitForTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_timeout", r.waitForTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterStatsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	flatSettings *bool
	timeout *string
}

// Return settings in flat format.
func (r ApiClusterStatsRequest) FlatSettings(flatSettings bool) ApiClusterStatsRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout.
func (r ApiClusterStatsRequest) Timeout(timeout string) ApiClusterStatsRequest {
	r.timeout = &timeout
	return r
}

func (r ApiClusterStatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterStatsExecute(r)
}

/*
ClusterStats Method for ClusterStats

Returns high-level overview of cluster statistics.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClusterStatsRequest
*/
func (a *DefaultAPIService) ClusterStats(ctx context.Context) ApiClusterStatsRequest {
	return ApiClusterStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterStatsExecute(r ApiClusterStatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterStats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClusterStatsWithNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	flatSettings *bool
	timeout *string
}

// Return settings in flat format.
func (r ApiClusterStatsWithNodeIdRequest) FlatSettings(flatSettings bool) ApiClusterStatsWithNodeIdRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout.
func (r ApiClusterStatsWithNodeIdRequest) Timeout(timeout string) ApiClusterStatsWithNodeIdRequest {
	r.timeout = &timeout
	return r
}

func (r ApiClusterStatsWithNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterStatsWithNodeIdExecute(r)
}

/*
ClusterStatsWithNodeId Method for ClusterStatsWithNodeId

Returns high-level overview of cluster statistics.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return ApiClusterStatsWithNodeIdRequest
*/
func (a *DefaultAPIService) ClusterStatsWithNodeId(ctx context.Context, nodeId string) ApiClusterStatsWithNodeIdRequest {
	return ApiClusterStatsWithNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterStatsWithNodeIdExecute(r ApiClusterStatsWithNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterStatsWithNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/stats/nodes/{node_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCountGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	minScore *int32
	preference *string
	routing *[]string
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	terminateAfter *int32
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiCountGetRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiCountGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r ApiCountGetRequest) IgnoreThrottled(ignoreThrottled bool) ApiCountGetRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiCountGetRequest) AllowNoIndices(allowNoIndices bool) ApiCountGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiCountGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiCountGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Include only documents with a specific &#x60;_score&#x60; value in the result.
func (r ApiCountGetRequest) MinScore(minScore int32) ApiCountGetRequest {
	r.minScore = &minScore
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiCountGetRequest) Preference(preference string) ApiCountGetRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r ApiCountGetRequest) Routing(routing []string) ApiCountGetRequest {
	r.routing = &routing
	return r
}

// Query in the Lucene query string syntax.
func (r ApiCountGetRequest) Q(q string) ApiCountGetRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r ApiCountGetRequest) Analyzer(analyzer string) ApiCountGetRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r ApiCountGetRequest) AnalyzeWildcard(analyzeWildcard bool) ApiCountGetRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiCountGetRequest) DefaultOperator(defaultOperator DefaultOperator) ApiCountGetRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r ApiCountGetRequest) Df(df string) ApiCountGetRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiCountGetRequest) Lenient(lenient bool) ApiCountGetRequest {
	r.lenient = &lenient
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r ApiCountGetRequest) TerminateAfter(terminateAfter int32) ApiCountGetRequest {
	r.terminateAfter = &terminateAfter
	return r
}

func (r ApiCountGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountGetExecute(r)
}

/*
CountGet Method for CountGet

Returns number of documents matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCountGetRequest
*/
func (a *DefaultAPIService) CountGet(ctx context.Context) ApiCountGetRequest {
	return ApiCountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CountGetExecute(r ApiCountGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CountGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.minScore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_score", r.minScore, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCountGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	minScore *int32
	preference *string
	routing *[]string
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	terminateAfter *int32
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiCountGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiCountGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r ApiCountGetWithIndexRequest) IgnoreThrottled(ignoreThrottled bool) ApiCountGetWithIndexRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiCountGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiCountGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiCountGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiCountGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Include only documents with a specific &#x60;_score&#x60; value in the result.
func (r ApiCountGetWithIndexRequest) MinScore(minScore int32) ApiCountGetWithIndexRequest {
	r.minScore = &minScore
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiCountGetWithIndexRequest) Preference(preference string) ApiCountGetWithIndexRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r ApiCountGetWithIndexRequest) Routing(routing []string) ApiCountGetWithIndexRequest {
	r.routing = &routing
	return r
}

// Query in the Lucene query string syntax.
func (r ApiCountGetWithIndexRequest) Q(q string) ApiCountGetWithIndexRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r ApiCountGetWithIndexRequest) Analyzer(analyzer string) ApiCountGetWithIndexRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r ApiCountGetWithIndexRequest) AnalyzeWildcard(analyzeWildcard bool) ApiCountGetWithIndexRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiCountGetWithIndexRequest) DefaultOperator(defaultOperator DefaultOperator) ApiCountGetWithIndexRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r ApiCountGetWithIndexRequest) Df(df string) ApiCountGetWithIndexRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiCountGetWithIndexRequest) Lenient(lenient bool) ApiCountGetWithIndexRequest {
	r.lenient = &lenient
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r ApiCountGetWithIndexRequest) TerminateAfter(terminateAfter int32) ApiCountGetWithIndexRequest {
	r.terminateAfter = &terminateAfter
	return r
}

func (r ApiCountGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountGetWithIndexExecute(r)
}

/*
CountGetWithIndex Method for CountGetWithIndex

Returns number of documents matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to restrict the results.
 @return ApiCountGetWithIndexRequest
*/
func (a *DefaultAPIService) CountGetWithIndex(ctx context.Context, index string) ApiCountGetWithIndexRequest {
	return ApiCountGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CountGetWithIndexExecute(r ApiCountGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CountGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_count"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.minScore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_score", r.minScore, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCountPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	minScore *int32
	preference *string
	routing *[]string
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	terminateAfter *int32
	body *map[string]interface{}
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiCountPostRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiCountPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r ApiCountPostRequest) IgnoreThrottled(ignoreThrottled bool) ApiCountPostRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiCountPostRequest) AllowNoIndices(allowNoIndices bool) ApiCountPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiCountPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiCountPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Include only documents with a specific &#x60;_score&#x60; value in the result.
func (r ApiCountPostRequest) MinScore(minScore int32) ApiCountPostRequest {
	r.minScore = &minScore
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiCountPostRequest) Preference(preference string) ApiCountPostRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r ApiCountPostRequest) Routing(routing []string) ApiCountPostRequest {
	r.routing = &routing
	return r
}

// Query in the Lucene query string syntax.
func (r ApiCountPostRequest) Q(q string) ApiCountPostRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r ApiCountPostRequest) Analyzer(analyzer string) ApiCountPostRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r ApiCountPostRequest) AnalyzeWildcard(analyzeWildcard bool) ApiCountPostRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiCountPostRequest) DefaultOperator(defaultOperator DefaultOperator) ApiCountPostRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r ApiCountPostRequest) Df(df string) ApiCountPostRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiCountPostRequest) Lenient(lenient bool) ApiCountPostRequest {
	r.lenient = &lenient
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r ApiCountPostRequest) TerminateAfter(terminateAfter int32) ApiCountPostRequest {
	r.terminateAfter = &terminateAfter
	return r
}

func (r ApiCountPostRequest) Body(body map[string]interface{}) ApiCountPostRequest {
	r.body = &body
	return r
}

func (r ApiCountPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountPostExecute(r)
}

/*
CountPost Method for CountPost

Returns number of documents matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCountPostRequest
*/
func (a *DefaultAPIService) CountPost(ctx context.Context) ApiCountPostRequest {
	return ApiCountPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CountPostExecute(r ApiCountPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CountPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.minScore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_score", r.minScore, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCountPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	minScore *int32
	preference *string
	routing *[]string
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	terminateAfter *int32
	body *map[string]interface{}
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiCountPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiCountPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r ApiCountPostWithIndexRequest) IgnoreThrottled(ignoreThrottled bool) ApiCountPostWithIndexRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiCountPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiCountPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiCountPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiCountPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Include only documents with a specific &#x60;_score&#x60; value in the result.
func (r ApiCountPostWithIndexRequest) MinScore(minScore int32) ApiCountPostWithIndexRequest {
	r.minScore = &minScore
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiCountPostWithIndexRequest) Preference(preference string) ApiCountPostWithIndexRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r ApiCountPostWithIndexRequest) Routing(routing []string) ApiCountPostWithIndexRequest {
	r.routing = &routing
	return r
}

// Query in the Lucene query string syntax.
func (r ApiCountPostWithIndexRequest) Q(q string) ApiCountPostWithIndexRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r ApiCountPostWithIndexRequest) Analyzer(analyzer string) ApiCountPostWithIndexRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r ApiCountPostWithIndexRequest) AnalyzeWildcard(analyzeWildcard bool) ApiCountPostWithIndexRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiCountPostWithIndexRequest) DefaultOperator(defaultOperator DefaultOperator) ApiCountPostWithIndexRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r ApiCountPostWithIndexRequest) Df(df string) ApiCountPostWithIndexRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiCountPostWithIndexRequest) Lenient(lenient bool) ApiCountPostWithIndexRequest {
	r.lenient = &lenient
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r ApiCountPostWithIndexRequest) TerminateAfter(terminateAfter int32) ApiCountPostWithIndexRequest {
	r.terminateAfter = &terminateAfter
	return r
}

func (r ApiCountPostWithIndexRequest) Body(body map[string]interface{}) ApiCountPostWithIndexRequest {
	r.body = &body
	return r
}

func (r ApiCountPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountPostWithIndexExecute(r)
}

/*
CountPostWithIndex Method for CountPostWithIndex

Returns number of documents matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to restrict the results.
 @return ApiCountPostWithIndexRequest
*/
func (a *DefaultAPIService) CountPostWithIndex(ctx context.Context, index string) ApiCountPostWithIndexRequest {
	return ApiCountPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CountPostWithIndexExecute(r ApiCountPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CountPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_count"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.minScore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_score", r.minScore, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateActionGroupRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	actionGroup string
	actionGroup2 *ActionGroup
}

func (r ApiCreateActionGroupRequest) ActionGroup2(actionGroup2 ActionGroup) ApiCreateActionGroupRequest {
	r.actionGroup2 = &actionGroup2
	return r
}

func (r ApiCreateActionGroupRequest) Execute() (*CreateActionGroupResponseContent, *http.Response, error) {
	return r.ApiService.CreateActionGroupExecute(r)
}

/*
CreateActionGroup Method for CreateActionGroup

Creates or replaces the specified action group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionGroup The name of the action group to create or replace
 @return ApiCreateActionGroupRequest
*/
func (a *DefaultAPIService) CreateActionGroup(ctx context.Context, actionGroup string) ApiCreateActionGroupRequest {
	return ApiCreateActionGroupRequest{
		ApiService: a,
		ctx: ctx,
		actionGroup: actionGroup,
	}
}

// Execute executes the request
//  @return CreateActionGroupResponseContent
func (a *DefaultAPIService) CreateActionGroupExecute(r ApiCreateActionGroupRequest) (*CreateActionGroupResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateActionGroupResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateActionGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/actiongroups/{action_group}"
	localVarPath = strings.Replace(localVarPath, "{"+"action_group"+"}", url.PathEscape(parameterValueToString(r.actionGroup, "actionGroup")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionGroup2 == nil {
		return localVarReturnValue, nil, reportError("actionGroup2 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionGroup2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePitRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	allowPartialPitCreation *bool
	keepAlive *string
	preference *string
	routing *[]string
	expandWildcards *ExpandWildcards
}

// Allow if point in time can be created with partial failures.
func (r ApiCreatePitRequest) AllowPartialPitCreation(allowPartialPitCreation bool) ApiCreatePitRequest {
	r.allowPartialPitCreation = &allowPartialPitCreation
	return r
}

// Specify the keep alive for point in time.
func (r ApiCreatePitRequest) KeepAlive(keepAlive string) ApiCreatePitRequest {
	r.keepAlive = &keepAlive
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiCreatePitRequest) Preference(preference string) ApiCreatePitRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r ApiCreatePitRequest) Routing(routing []string) ApiCreatePitRequest {
	r.routing = &routing
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiCreatePitRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiCreatePitRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiCreatePitRequest) Execute() (*CreatePitResponseContent, *http.Response, error) {
	return r.ApiService.CreatePitExecute(r)
}

/*
CreatePit Method for CreatePit

Creates point in time context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiCreatePitRequest
*/
func (a *DefaultAPIService) CreatePit(ctx context.Context, index string) ApiCreatePitRequest {
	return ApiCreatePitRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
//  @return CreatePitResponseContent
func (a *DefaultAPIService) CreatePitExecute(r ApiCreatePitRequest) (*CreatePitResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePitResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreatePit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_search/point_in_time"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowPartialPitCreation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_partial_pit_creation", r.allowPartialPitCreation, "")
	}
	if r.keepAlive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keep_alive", r.keepAlive, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	refresh *RefreshEnum
	routing *string
	timeout *string
	version *int32
	versionType *VersionType
	pipeline *string
}

func (r ApiCreatePostRequest) Body(body map[string]interface{}) ApiCreatePostRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r ApiCreatePostRequest) WaitForActiveShards(waitForActiveShards string) ApiCreatePostRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r ApiCreatePostRequest) Refresh(refresh RefreshEnum) ApiCreatePostRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiCreatePostRequest) Routing(routing string) ApiCreatePostRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r ApiCreatePostRequest) Timeout(timeout string) ApiCreatePostRequest {
	r.timeout = &timeout
	return r
}

// Explicit version number for concurrency control.
func (r ApiCreatePostRequest) Version(version int32) ApiCreatePostRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiCreatePostRequest) VersionType(versionType VersionType) ApiCreatePostRequest {
	r.versionType = &versionType
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r ApiCreatePostRequest) Pipeline(pipeline string) ApiCreatePostRequest {
	r.pipeline = &pipeline
	return r
}

func (r ApiCreatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreatePostExecute(r)
}

/*
CreatePost Method for CreatePost

Creates a new document in the index.

Returns a 409 response when a document with a same ID already exists in the index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return ApiCreatePostRequest
*/
func (a *DefaultAPIService) CreatePost(ctx context.Context, id string, index string) ApiCreatePostRequest {
	return ApiCreatePostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CreatePostExecute(r ApiCreatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_create/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreatePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	refresh *RefreshEnum
	routing *string
	timeout *string
	version *int32
	versionType *VersionType
	pipeline *string
}

func (r ApiCreatePutRequest) Body(body map[string]interface{}) ApiCreatePutRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r ApiCreatePutRequest) WaitForActiveShards(waitForActiveShards string) ApiCreatePutRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r ApiCreatePutRequest) Refresh(refresh RefreshEnum) ApiCreatePutRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiCreatePutRequest) Routing(routing string) ApiCreatePutRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r ApiCreatePutRequest) Timeout(timeout string) ApiCreatePutRequest {
	r.timeout = &timeout
	return r
}

// Explicit version number for concurrency control.
func (r ApiCreatePutRequest) Version(version int32) ApiCreatePutRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiCreatePutRequest) VersionType(versionType VersionType) ApiCreatePutRequest {
	r.versionType = &versionType
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r ApiCreatePutRequest) Pipeline(pipeline string) ApiCreatePutRequest {
	r.pipeline = &pipeline
	return r
}

func (r ApiCreatePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreatePutExecute(r)
}

/*
CreatePut Method for CreatePut

Creates a new document in the index.

Returns a 409 response when a document with a same ID already exists in the index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return ApiCreatePutRequest
*/
func (a *DefaultAPIService) CreatePut(ctx context.Context, id string, index string) ApiCreatePutRequest {
	return ApiCreatePutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CreatePutExecute(r ApiCreatePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreatePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_create/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateRoleRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
	role2 *Role
}

func (r ApiCreateRoleRequest) Role2(role2 Role) ApiCreateRoleRequest {
	r.role2 = &role2
	return r
}

func (r ApiCreateRoleRequest) Execute() (*CreateRoleResponseContent, *http.Response, error) {
	return r.ApiService.CreateRoleExecute(r)
}

/*
CreateRole Method for CreateRole

Creates or replaces the specified role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return ApiCreateRoleRequest
*/
func (a *DefaultAPIService) CreateRole(ctx context.Context, role string) ApiCreateRoleRequest {
	return ApiCreateRoleRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return CreateRoleResponseContent
func (a *DefaultAPIService) CreateRoleExecute(r ApiCreateRoleRequest) (*CreateRoleResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateRoleResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/roles/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.role2 == nil {
		return localVarReturnValue, nil, reportError("role2 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.role2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRoleMappingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
	roleMapping *RoleMapping
}

func (r ApiCreateRoleMappingRequest) RoleMapping(roleMapping RoleMapping) ApiCreateRoleMappingRequest {
	r.roleMapping = &roleMapping
	return r
}

func (r ApiCreateRoleMappingRequest) Execute() (*CreateRoleMappingResponseContent, *http.Response, error) {
	return r.ApiService.CreateRoleMappingExecute(r)
}

/*
CreateRoleMapping Method for CreateRoleMapping

Creates or replaces the specified role mapping.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return ApiCreateRoleMappingRequest
*/
func (a *DefaultAPIService) CreateRoleMapping(ctx context.Context, role string) ApiCreateRoleMappingRequest {
	return ApiCreateRoleMappingRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return CreateRoleMappingResponseContent
func (a *DefaultAPIService) CreateRoleMappingExecute(r ApiCreateRoleMappingRequest) (*CreateRoleMappingResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateRoleMappingResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateRoleMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/rolesmapping/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleMapping == nil {
		return localVarReturnValue, nil, reportError("roleMapping is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTenantRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	tenant string
	createTenantParams *CreateTenantParams
}

func (r ApiCreateTenantRequest) CreateTenantParams(createTenantParams CreateTenantParams) ApiCreateTenantRequest {
	r.createTenantParams = &createTenantParams
	return r
}

func (r ApiCreateTenantRequest) Execute() (*CreateTenantResponseContent, *http.Response, error) {
	return r.ApiService.CreateTenantExecute(r)
}

/*
CreateTenant Method for CreateTenant

Creates or replaces the specified tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @return ApiCreateTenantRequest
*/
func (a *DefaultAPIService) CreateTenant(ctx context.Context, tenant string) ApiCreateTenantRequest {
	return ApiCreateTenantRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
	}
}

// Execute executes the request
//  @return CreateTenantResponseContent
func (a *DefaultAPIService) CreateTenantExecute(r ApiCreateTenantRequest) (*CreateTenantResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTenantResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateTenant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/tenants/{tenant}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTenantParams == nil {
		return localVarReturnValue, nil, reportError("createTenantParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTenantParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUserRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	username string
	user *User
}

func (r ApiCreateUserRequest) User(user User) ApiCreateUserRequest {
	r.user = &user
	return r
}

func (r ApiCreateUserRequest) Execute() (*CreateUserResponseContent, *http.Response, error) {
	return r.ApiService.CreateUserExecute(r)
}

/*
CreateUser Method for CreateUser

Creates or replaces the specified user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username
 @return ApiCreateUserRequest
*/
func (a *DefaultAPIService) CreateUser(ctx context.Context, username string) ApiCreateUserRequest {
	return ApiCreateUserRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return CreateUserResponseContent
func (a *DefaultAPIService) CreateUserExecute(r ApiCreateUserRequest) (*CreateUserResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateUserResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/internalusers/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterValueToString(r.username, "username")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.user == nil {
		return localVarReturnValue, nil, reportError("user is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.user
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDanglingIndicesDeleteDanglingIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	indexUuid string
	acceptDataLoss *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Must be set to true in order to delete the dangling index.
func (r ApiDanglingIndicesDeleteDanglingIndexRequest) AcceptDataLoss(acceptDataLoss bool) ApiDanglingIndicesDeleteDanglingIndexRequest {
	r.acceptDataLoss = &acceptDataLoss
	return r
}

// Operation timeout.
func (r ApiDanglingIndicesDeleteDanglingIndexRequest) Timeout(timeout string) ApiDanglingIndicesDeleteDanglingIndexRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiDanglingIndicesDeleteDanglingIndexRequest) MasterTimeout(masterTimeout string) ApiDanglingIndicesDeleteDanglingIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiDanglingIndicesDeleteDanglingIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiDanglingIndicesDeleteDanglingIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiDanglingIndicesDeleteDanglingIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.DanglingIndicesDeleteDanglingIndexExecute(r)
}

/*
DanglingIndicesDeleteDanglingIndex Method for DanglingIndicesDeleteDanglingIndex

Deletes the specified dangling index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexUuid The UUID of the dangling index.
 @return ApiDanglingIndicesDeleteDanglingIndexRequest
*/
func (a *DefaultAPIService) DanglingIndicesDeleteDanglingIndex(ctx context.Context, indexUuid string) ApiDanglingIndicesDeleteDanglingIndexRequest {
	return ApiDanglingIndicesDeleteDanglingIndexRequest{
		ApiService: a,
		ctx: ctx,
		indexUuid: indexUuid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DanglingIndicesDeleteDanglingIndexExecute(r ApiDanglingIndicesDeleteDanglingIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DanglingIndicesDeleteDanglingIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_dangling/{index_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"index_uuid"+"}", url.PathEscape(parameterValueToString(r.indexUuid, "indexUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.acceptDataLoss != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accept_data_loss", r.acceptDataLoss, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDanglingIndicesImportDanglingIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	indexUuid string
	acceptDataLoss *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Must be set to true in order to import the dangling index.
func (r ApiDanglingIndicesImportDanglingIndexRequest) AcceptDataLoss(acceptDataLoss bool) ApiDanglingIndicesImportDanglingIndexRequest {
	r.acceptDataLoss = &acceptDataLoss
	return r
}

// Operation timeout.
func (r ApiDanglingIndicesImportDanglingIndexRequest) Timeout(timeout string) ApiDanglingIndicesImportDanglingIndexRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiDanglingIndicesImportDanglingIndexRequest) MasterTimeout(masterTimeout string) ApiDanglingIndicesImportDanglingIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiDanglingIndicesImportDanglingIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiDanglingIndicesImportDanglingIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiDanglingIndicesImportDanglingIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.DanglingIndicesImportDanglingIndexExecute(r)
}

/*
DanglingIndicesImportDanglingIndex Method for DanglingIndicesImportDanglingIndex

Imports the specified dangling index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexUuid The UUID of the dangling index.
 @return ApiDanglingIndicesImportDanglingIndexRequest
*/
func (a *DefaultAPIService) DanglingIndicesImportDanglingIndex(ctx context.Context, indexUuid string) ApiDanglingIndicesImportDanglingIndexRequest {
	return ApiDanglingIndicesImportDanglingIndexRequest{
		ApiService: a,
		ctx: ctx,
		indexUuid: indexUuid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DanglingIndicesImportDanglingIndexExecute(r ApiDanglingIndicesImportDanglingIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DanglingIndicesImportDanglingIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_dangling/{index_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"index_uuid"+"}", url.PathEscape(parameterValueToString(r.indexUuid, "indexUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.acceptDataLoss != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accept_data_loss", r.acceptDataLoss, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDanglingIndicesListDanglingIndicesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiDanglingIndicesListDanglingIndicesRequest) Execute() (*http.Response, error) {
	return r.ApiService.DanglingIndicesListDanglingIndicesExecute(r)
}

/*
DanglingIndicesListDanglingIndices Method for DanglingIndicesListDanglingIndices

Returns all dangling indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDanglingIndicesListDanglingIndicesRequest
*/
func (a *DefaultAPIService) DanglingIndicesListDanglingIndices(ctx context.Context) ApiDanglingIndicesListDanglingIndicesRequest {
	return ApiDanglingIndicesListDanglingIndicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DanglingIndicesListDanglingIndicesExecute(r ApiDanglingIndicesListDanglingIndicesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DanglingIndicesListDanglingIndices")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_dangling"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	waitForActiveShards *string
	refresh *RefreshEnum
	routing *string
	timeout *string
	ifSeqNo *int32
	ifPrimaryTerm *int32
	version *int32
	versionType *VersionType
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r ApiDeleteRequest) WaitForActiveShards(waitForActiveShards string) ApiDeleteRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r ApiDeleteRequest) Refresh(refresh RefreshEnum) ApiDeleteRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiDeleteRequest) Routing(routing string) ApiDeleteRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r ApiDeleteRequest) Timeout(timeout string) ApiDeleteRequest {
	r.timeout = &timeout
	return r
}

// only perform the operation if the last operation that has changed the document has the specified sequence number.
func (r ApiDeleteRequest) IfSeqNo(ifSeqNo int32) ApiDeleteRequest {
	r.ifSeqNo = &ifSeqNo
	return r
}

// only perform the operation if the last operation that has changed the document has the specified primary term.
func (r ApiDeleteRequest) IfPrimaryTerm(ifPrimaryTerm int32) ApiDeleteRequest {
	r.ifPrimaryTerm = &ifPrimaryTerm
	return r
}

// Explicit version number for concurrency control.
func (r ApiDeleteRequest) Version(version int32) ApiDeleteRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiDeleteRequest) VersionType(versionType VersionType) ApiDeleteRequest {
	r.versionType = &versionType
	return r
}

func (r ApiDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteExecute(r)
}

/*
Delete Method for Delete

Removes a document from the index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return ApiDeleteRequest
*/
func (a *DefaultAPIService) Delete(ctx context.Context, id string, index string) ApiDeleteRequest {
	return ApiDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DeleteExecute(r ApiDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Delete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_doc/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.ifSeqNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_seq_no", r.ifSeqNo, "")
	}
	if r.ifPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_primary_term", r.ifPrimaryTerm, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteActionGroupRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	actionGroup string
}

func (r ApiDeleteActionGroupRequest) Execute() (*DeleteActionGroupResponseContent, *http.Response, error) {
	return r.ApiService.DeleteActionGroupExecute(r)
}

/*
DeleteActionGroup Method for DeleteActionGroup

Delete a specified action group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionGroup Action group to delete.
 @return ApiDeleteActionGroupRequest
*/
func (a *DefaultAPIService) DeleteActionGroup(ctx context.Context, actionGroup string) ApiDeleteActionGroupRequest {
	return ApiDeleteActionGroupRequest{
		ApiService: a,
		ctx: ctx,
		actionGroup: actionGroup,
	}
}

// Execute executes the request
//  @return DeleteActionGroupResponseContent
func (a *DefaultAPIService) DeleteActionGroupExecute(r ApiDeleteActionGroupRequest) (*DeleteActionGroupResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteActionGroupResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteActionGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/actiongroups/{action_group}"
	localVarPath = strings.Replace(localVarPath, "{"+"action_group"+"}", url.PathEscape(parameterValueToString(r.actionGroup, "actionGroup")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAllPitsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiDeleteAllPitsRequest) Execute() (*DeleteAllPitsResponseContent, *http.Response, error) {
	return r.ApiService.DeleteAllPitsExecute(r)
}

/*
DeleteAllPits Method for DeleteAllPits

Deletes all active point in time searches.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteAllPitsRequest
*/
func (a *DefaultAPIService) DeleteAllPits(ctx context.Context) ApiDeleteAllPitsRequest {
	return ApiDeleteAllPitsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteAllPitsResponseContent
func (a *DefaultAPIService) DeleteAllPitsExecute(r ApiDeleteAllPitsRequest) (*DeleteAllPitsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteAllPitsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteAllPits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/point_in_time/_all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteByQueryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	from *int32
	ignoreUnavailable *bool
	allowNoIndices *bool
	conflicts *Conflicts
	expandWildcards *ExpandWildcards
	lenient *bool
	preference *string
	q *string
	routing *[]string
	scroll *string
	searchType *SearchType
	searchTimeout *string
	size *int32
	maxDocs *int32
	sort *[]string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	terminateAfter *int32
	stats *[]string
	version *bool
	requestCache *bool
	refresh *bool
	timeout *string
	waitForActiveShards *string
	scrollSize *int32
	waitForCompletion *bool
	requestsPerSecond *int32
	slices *string
}

func (r ApiDeleteByQueryRequest) Body(body map[string]interface{}) ApiDeleteByQueryRequest {
	r.body = &body
	return r
}

// The analyzer to use for the query string.
func (r ApiDeleteByQueryRequest) Analyzer(analyzer string) ApiDeleteByQueryRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r ApiDeleteByQueryRequest) AnalyzeWildcard(analyzeWildcard bool) ApiDeleteByQueryRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiDeleteByQueryRequest) DefaultOperator(defaultOperator DefaultOperator) ApiDeleteByQueryRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r ApiDeleteByQueryRequest) Df(df string) ApiDeleteByQueryRequest {
	r.df = &df
	return r
}

// Starting offset.
func (r ApiDeleteByQueryRequest) From(from int32) ApiDeleteByQueryRequest {
	r.from = &from
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiDeleteByQueryRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiDeleteByQueryRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiDeleteByQueryRequest) AllowNoIndices(allowNoIndices bool) ApiDeleteByQueryRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// What to do when the operation encounters version conflicts?.
func (r ApiDeleteByQueryRequest) Conflicts(conflicts Conflicts) ApiDeleteByQueryRequest {
	r.conflicts = &conflicts
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiDeleteByQueryRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiDeleteByQueryRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiDeleteByQueryRequest) Lenient(lenient bool) ApiDeleteByQueryRequest {
	r.lenient = &lenient
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiDeleteByQueryRequest) Preference(preference string) ApiDeleteByQueryRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r ApiDeleteByQueryRequest) Q(q string) ApiDeleteByQueryRequest {
	r.q = &q
	return r
}

// Comma-separated list of specific routing values.
func (r ApiDeleteByQueryRequest) Routing(routing []string) ApiDeleteByQueryRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiDeleteByQueryRequest) Scroll(scroll string) ApiDeleteByQueryRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r ApiDeleteByQueryRequest) SearchType(searchType SearchType) ApiDeleteByQueryRequest {
	r.searchType = &searchType
	return r
}

// Explicit timeout for each search request. Defaults to no timeout.
func (r ApiDeleteByQueryRequest) SearchTimeout(searchTimeout string) ApiDeleteByQueryRequest {
	r.searchTimeout = &searchTimeout
	return r
}

// Deprecated, please use &#x60;max_docs&#x60; instead.
func (r ApiDeleteByQueryRequest) Size(size int32) ApiDeleteByQueryRequest {
	r.size = &size
	return r
}

// Maximum number of documents to process (default: all documents).
func (r ApiDeleteByQueryRequest) MaxDocs(maxDocs int32) ApiDeleteByQueryRequest {
	r.maxDocs = &maxDocs
	return r
}

// Comma-separated list of &lt;field&gt;:&lt;direction&gt; pairs.
func (r ApiDeleteByQueryRequest) Sort(sort []string) ApiDeleteByQueryRequest {
	r.sort = &sort
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiDeleteByQueryRequest) Source(source []string) ApiDeleteByQueryRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiDeleteByQueryRequest) SourceExcludes(sourceExcludes []string) ApiDeleteByQueryRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiDeleteByQueryRequest) SourceIncludes(sourceIncludes []string) ApiDeleteByQueryRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r ApiDeleteByQueryRequest) TerminateAfter(terminateAfter int32) ApiDeleteByQueryRequest {
	r.terminateAfter = &terminateAfter
	return r
}

// Specific &#39;tag&#39; of the request for logging and statistical purposes.
func (r ApiDeleteByQueryRequest) Stats(stats []string) ApiDeleteByQueryRequest {
	r.stats = &stats
	return r
}

// Whether to return document version as part of a hit.
func (r ApiDeleteByQueryRequest) Version(version bool) ApiDeleteByQueryRequest {
	r.version = &version
	return r
}

// Specify if request cache should be used for this request or not, defaults to index level setting.
func (r ApiDeleteByQueryRequest) RequestCache(requestCache bool) ApiDeleteByQueryRequest {
	r.requestCache = &requestCache
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r ApiDeleteByQueryRequest) Refresh(refresh bool) ApiDeleteByQueryRequest {
	r.refresh = &refresh
	return r
}

// Time each individual bulk request should wait for shards that are unavailable.
func (r ApiDeleteByQueryRequest) Timeout(timeout string) ApiDeleteByQueryRequest {
	r.timeout = &timeout
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r ApiDeleteByQueryRequest) WaitForActiveShards(waitForActiveShards string) ApiDeleteByQueryRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Size on the scroll request powering the operation.
func (r ApiDeleteByQueryRequest) ScrollSize(scrollSize int32) ApiDeleteByQueryRequest {
	r.scrollSize = &scrollSize
	return r
}

// Should this request wait until the operation has completed before returning.
func (r ApiDeleteByQueryRequest) WaitForCompletion(waitForCompletion bool) ApiDeleteByQueryRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

// The throttle for this request in sub-requests per second. -1 means no throttle.
func (r ApiDeleteByQueryRequest) RequestsPerSecond(requestsPerSecond int32) ApiDeleteByQueryRequest {
	r.requestsPerSecond = &requestsPerSecond
	return r
}

// The number of slices this task should be divided into. Defaults to 1, meaning the task isn&#39;t sliced into subtasks. Can be set to &#x60;auto&#x60;.
func (r ApiDeleteByQueryRequest) Slices(slices string) ApiDeleteByQueryRequest {
	r.slices = &slices
	return r
}

func (r ApiDeleteByQueryRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteByQueryExecute(r)
}

/*
DeleteByQuery Method for DeleteByQuery

Deletes documents matching the provided query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiDeleteByQueryRequest
*/
func (a *DefaultAPIService) DeleteByQuery(ctx context.Context, index string) ApiDeleteByQueryRequest {
	return ApiDeleteByQueryRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DeleteByQueryExecute(r ApiDeleteByQueryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteByQuery")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_delete_by_query"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	} else {
		var defaultValue int32 = 0
		r.from = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.searchTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_timeout", r.searchTimeout, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.maxDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_docs", r.maxDocs, "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	if r.stats != nil {
		t := *r.stats
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stats", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stats", t, "multi")
		}
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.requestCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_cache", r.requestCache, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	} else {
		var defaultValue string = "1m"
		r.timeout = &defaultValue
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.scrollSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll_size", r.scrollSize, "")
	} else {
		var defaultValue int32 = 100
		r.scrollSize = &defaultValue
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = true
		r.waitForCompletion = &defaultValue
	}
	if r.requestsPerSecond != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requests_per_second", r.requestsPerSecond, "")
	} else {
		var defaultValue int32 = 0
		r.requestsPerSecond = &defaultValue
	}
	if r.slices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slices", r.slices, "")
	} else {
		var defaultValue string = "1"
		r.slices = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteByQueryRethrottleRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	requestsPerSecond *int32
}

// The throttle for this request in sub-requests per second. -1 means no throttle.
func (r ApiDeleteByQueryRethrottleRequest) RequestsPerSecond(requestsPerSecond int32) ApiDeleteByQueryRethrottleRequest {
	r.requestsPerSecond = &requestsPerSecond
	return r
}

func (r ApiDeleteByQueryRethrottleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteByQueryRethrottleExecute(r)
}

/*
DeleteByQueryRethrottle Method for DeleteByQueryRethrottle

Changes the number of requests per second for a particular Delete By Query operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id to rethrottle.
 @return ApiDeleteByQueryRethrottleRequest
*/
func (a *DefaultAPIService) DeleteByQueryRethrottle(ctx context.Context, taskId string) ApiDeleteByQueryRethrottleRequest {
	return ApiDeleteByQueryRethrottleRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DeleteByQueryRethrottleExecute(r ApiDeleteByQueryRethrottleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteByQueryRethrottle")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_delete_by_query/{task_id}/_rethrottle"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestsPerSecond == nil {
		return nil, reportError("requestsPerSecond is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "requests_per_second", r.requestsPerSecond, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDistinguishedNamesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	clusterName string
}

func (r ApiDeleteDistinguishedNamesRequest) Execute() (*DeleteDistinguishedNamesResponseContent, *http.Response, error) {
	return r.ApiService.DeleteDistinguishedNamesExecute(r)
}

/*
DeleteDistinguishedNames Method for DeleteDistinguishedNames

Deletes all distinguished names in the specified cluster’s or node’s allow list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName
 @return ApiDeleteDistinguishedNamesRequest
*/
func (a *DefaultAPIService) DeleteDistinguishedNames(ctx context.Context, clusterName string) ApiDeleteDistinguishedNamesRequest {
	return ApiDeleteDistinguishedNamesRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return DeleteDistinguishedNamesResponseContent
func (a *DefaultAPIService) DeleteDistinguishedNamesExecute(r ApiDeleteDistinguishedNamesRequest) (*DeleteDistinguishedNamesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteDistinguishedNamesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteDistinguishedNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/nodesdn/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePitRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	deletePitBodyParams *DeletePitBodyParams
}

func (r ApiDeletePitRequest) DeletePitBodyParams(deletePitBodyParams DeletePitBodyParams) ApiDeletePitRequest {
	r.deletePitBodyParams = &deletePitBodyParams
	return r
}

func (r ApiDeletePitRequest) Execute() (*DeletePitResponseContent, *http.Response, error) {
	return r.ApiService.DeletePitExecute(r)
}

/*
DeletePit Method for DeletePit

Deletes one or more point in time searches based on the IDs passed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeletePitRequest
*/
func (a *DefaultAPIService) DeletePit(ctx context.Context) ApiDeletePitRequest {
	return ApiDeletePitRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeletePitResponseContent
func (a *DefaultAPIService) DeletePitExecute(r ApiDeletePitRequest) (*DeletePitResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeletePitResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeletePit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/point_in_time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deletePitBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRoleRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
}

func (r ApiDeleteRoleRequest) Execute() (*DeleteRoleResponseContent, *http.Response, error) {
	return r.ApiService.DeleteRoleExecute(r)
}

/*
DeleteRole Method for DeleteRole

Delete the specified role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return ApiDeleteRoleRequest
*/
func (a *DefaultAPIService) DeleteRole(ctx context.Context, role string) ApiDeleteRoleRequest {
	return ApiDeleteRoleRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return DeleteRoleResponseContent
func (a *DefaultAPIService) DeleteRoleExecute(r ApiDeleteRoleRequest) (*DeleteRoleResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteRoleResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/roles/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRoleMappingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
}

func (r ApiDeleteRoleMappingRequest) Execute() (*DeleteRoleMappingResponseContent, *http.Response, error) {
	return r.ApiService.DeleteRoleMappingExecute(r)
}

/*
DeleteRoleMapping Method for DeleteRoleMapping

Deletes the specified role mapping.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return ApiDeleteRoleMappingRequest
*/
func (a *DefaultAPIService) DeleteRoleMapping(ctx context.Context, role string) ApiDeleteRoleMappingRequest {
	return ApiDeleteRoleMappingRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return DeleteRoleMappingResponseContent
func (a *DefaultAPIService) DeleteRoleMappingExecute(r ApiDeleteRoleMappingRequest) (*DeleteRoleMappingResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteRoleMappingResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteRoleMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/rolesmapping/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteScriptRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout.
func (r ApiDeleteScriptRequest) Timeout(timeout string) ApiDeleteScriptRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiDeleteScriptRequest) MasterTimeout(masterTimeout string) ApiDeleteScriptRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiDeleteScriptRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiDeleteScriptRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiDeleteScriptRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteScriptExecute(r)
}

/*
DeleteScript Method for DeleteScript

Deletes a script.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Script ID.
 @return ApiDeleteScriptRequest
*/
func (a *DefaultAPIService) DeleteScript(ctx context.Context, id string) ApiDeleteScriptRequest {
	return ApiDeleteScriptRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DeleteScriptExecute(r ApiDeleteScriptRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteScript")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTenantRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	tenant string
}

func (r ApiDeleteTenantRequest) Execute() (*DeleteTenantResponseContent, *http.Response, error) {
	return r.ApiService.DeleteTenantExecute(r)
}

/*
DeleteTenant Method for DeleteTenant

Delete the specified tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @return ApiDeleteTenantRequest
*/
func (a *DefaultAPIService) DeleteTenant(ctx context.Context, tenant string) ApiDeleteTenantRequest {
	return ApiDeleteTenantRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
	}
}

// Execute executes the request
//  @return DeleteTenantResponseContent
func (a *DefaultAPIService) DeleteTenantExecute(r ApiDeleteTenantRequest) (*DeleteTenantResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteTenantResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteTenant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/tenants/{tenant}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteUserRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	username string
}

func (r ApiDeleteUserRequest) Execute() (*DeleteUserResponseContent, *http.Response, error) {
	return r.ApiService.DeleteUserExecute(r)
}

/*
DeleteUser Method for DeleteUser

Delete the specified user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username
 @return ApiDeleteUserRequest
*/
func (a *DefaultAPIService) DeleteUser(ctx context.Context, username string) ApiDeleteUserRequest {
	return ApiDeleteUserRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return DeleteUserResponseContent
func (a *DefaultAPIService) DeleteUserExecute(r ApiDeleteUserRequest) (*DeleteUserResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteUserResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/internalusers/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterValueToString(r.username, "username")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExistsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	storedFields *[]string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	version *int32
	versionType *VersionType
}

// Comma-separated list of stored fields to return.
func (r ApiExistsRequest) StoredFields(storedFields []string) ApiExistsRequest {
	r.storedFields = &storedFields
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiExistsRequest) Preference(preference string) ApiExistsRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r ApiExistsRequest) Realtime(realtime bool) ApiExistsRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r ApiExistsRequest) Refresh(refresh bool) ApiExistsRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiExistsRequest) Routing(routing string) ApiExistsRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiExistsRequest) Source(source []string) ApiExistsRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiExistsRequest) SourceExcludes(sourceExcludes []string) ApiExistsRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiExistsRequest) SourceIncludes(sourceIncludes []string) ApiExistsRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// Explicit version number for concurrency control.
func (r ApiExistsRequest) Version(version int32) ApiExistsRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiExistsRequest) VersionType(versionType VersionType) ApiExistsRequest {
	r.versionType = &versionType
	return r
}

func (r ApiExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExistsExecute(r)
}

/*
Exists Method for Exists

Returns information about whether a document exists in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return ApiExistsRequest
*/
func (a *DefaultAPIService) Exists(ctx context.Context, id string, index string) ApiExistsRequest {
	return ApiExistsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ExistsExecute(r ApiExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Exists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_doc/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExistsSourceRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	version *int32
	versionType *VersionType
}

// Specify the node or shard the operation should be performed on.
func (r ApiExistsSourceRequest) Preference(preference string) ApiExistsSourceRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r ApiExistsSourceRequest) Realtime(realtime bool) ApiExistsSourceRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r ApiExistsSourceRequest) Refresh(refresh bool) ApiExistsSourceRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiExistsSourceRequest) Routing(routing string) ApiExistsSourceRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiExistsSourceRequest) Source(source []string) ApiExistsSourceRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiExistsSourceRequest) SourceExcludes(sourceExcludes []string) ApiExistsSourceRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiExistsSourceRequest) SourceIncludes(sourceIncludes []string) ApiExistsSourceRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// Explicit version number for concurrency control.
func (r ApiExistsSourceRequest) Version(version int32) ApiExistsSourceRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiExistsSourceRequest) VersionType(versionType VersionType) ApiExistsSourceRequest {
	r.versionType = &versionType
	return r
}

func (r ApiExistsSourceRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExistsSourceExecute(r)
}

/*
ExistsSource Method for ExistsSource

Returns information about whether a document source exists in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return ApiExistsSourceRequest
*/
func (a *DefaultAPIService) ExistsSource(ctx context.Context, id string, index string) ApiExistsSourceRequest {
	return ApiExistsSourceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ExistsSourceExecute(r ApiExistsSourceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ExistsSource")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_source/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExplainGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	analyzeWildcard *bool
	analyzer *string
	defaultOperator *DefaultOperator
	df *string
	storedFields *[]string
	lenient *bool
	preference *string
	q *string
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
}

// Specify whether wildcards and prefix queries in the query string query should be analyzed.
func (r ApiExplainGetRequest) AnalyzeWildcard(analyzeWildcard bool) ApiExplainGetRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The analyzer to use for the query string.
func (r ApiExplainGetRequest) Analyzer(analyzer string) ApiExplainGetRequest {
	r.analyzer = &analyzer
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiExplainGetRequest) DefaultOperator(defaultOperator DefaultOperator) ApiExplainGetRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The default field for query string query.
func (r ApiExplainGetRequest) Df(df string) ApiExplainGetRequest {
	r.df = &df
	return r
}

// Comma-separated list of stored fields to return.
func (r ApiExplainGetRequest) StoredFields(storedFields []string) ApiExplainGetRequest {
	r.storedFields = &storedFields
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiExplainGetRequest) Lenient(lenient bool) ApiExplainGetRequest {
	r.lenient = &lenient
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiExplainGetRequest) Preference(preference string) ApiExplainGetRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r ApiExplainGetRequest) Q(q string) ApiExplainGetRequest {
	r.q = &q
	return r
}

// Routing value.
func (r ApiExplainGetRequest) Routing(routing string) ApiExplainGetRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiExplainGetRequest) Source(source []string) ApiExplainGetRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiExplainGetRequest) SourceExcludes(sourceExcludes []string) ApiExplainGetRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiExplainGetRequest) SourceIncludes(sourceIncludes []string) ApiExplainGetRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

func (r ApiExplainGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExplainGetExecute(r)
}

/*
ExplainGet Method for ExplainGet

Returns information about why a specific matches (or doesn't match) a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return ApiExplainGetRequest
*/
func (a *DefaultAPIService) ExplainGet(ctx context.Context, id string, index string) ApiExplainGetRequest {
	return ApiExplainGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ExplainGetExecute(r ApiExplainGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ExplainGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_explain/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	} else {
		var defaultValue string = "_all"
		r.df = &defaultValue
	}
	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExplainPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	analyzeWildcard *bool
	analyzer *string
	defaultOperator *DefaultOperator
	df *string
	storedFields *[]string
	lenient *bool
	preference *string
	q *string
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	body *map[string]interface{}
}

// Specify whether wildcards and prefix queries in the query string query should be analyzed.
func (r ApiExplainPostRequest) AnalyzeWildcard(analyzeWildcard bool) ApiExplainPostRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The analyzer to use for the query string.
func (r ApiExplainPostRequest) Analyzer(analyzer string) ApiExplainPostRequest {
	r.analyzer = &analyzer
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiExplainPostRequest) DefaultOperator(defaultOperator DefaultOperator) ApiExplainPostRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The default field for query string query.
func (r ApiExplainPostRequest) Df(df string) ApiExplainPostRequest {
	r.df = &df
	return r
}

// Comma-separated list of stored fields to return.
func (r ApiExplainPostRequest) StoredFields(storedFields []string) ApiExplainPostRequest {
	r.storedFields = &storedFields
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiExplainPostRequest) Lenient(lenient bool) ApiExplainPostRequest {
	r.lenient = &lenient
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiExplainPostRequest) Preference(preference string) ApiExplainPostRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r ApiExplainPostRequest) Q(q string) ApiExplainPostRequest {
	r.q = &q
	return r
}

// Routing value.
func (r ApiExplainPostRequest) Routing(routing string) ApiExplainPostRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiExplainPostRequest) Source(source []string) ApiExplainPostRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiExplainPostRequest) SourceExcludes(sourceExcludes []string) ApiExplainPostRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiExplainPostRequest) SourceIncludes(sourceIncludes []string) ApiExplainPostRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

func (r ApiExplainPostRequest) Body(body map[string]interface{}) ApiExplainPostRequest {
	r.body = &body
	return r
}

func (r ApiExplainPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExplainPostExecute(r)
}

/*
ExplainPost Method for ExplainPost

Returns information about why a specific matches (or doesn't match) a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return ApiExplainPostRequest
*/
func (a *DefaultAPIService) ExplainPost(ctx context.Context, id string, index string) ApiExplainPostRequest {
	return ApiExplainPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ExplainPostExecute(r ApiExplainPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ExplainPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_explain/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	} else {
		var defaultValue string = "_all"
		r.df = &defaultValue
	}
	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFieldCapsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	fields *[]string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	includeUnmapped *bool
}

// Comma-separated list of field names.
func (r ApiFieldCapsGetRequest) Fields(fields []string) ApiFieldCapsGetRequest {
	r.fields = &fields
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiFieldCapsGetRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiFieldCapsGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiFieldCapsGetRequest) AllowNoIndices(allowNoIndices bool) ApiFieldCapsGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiFieldCapsGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiFieldCapsGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Indicates whether unmapped fields should be included in the response.
func (r ApiFieldCapsGetRequest) IncludeUnmapped(includeUnmapped bool) ApiFieldCapsGetRequest {
	r.includeUnmapped = &includeUnmapped
	return r
}

func (r ApiFieldCapsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.FieldCapsGetExecute(r)
}

/*
FieldCapsGet Method for FieldCapsGet

Returns the information about the capabilities of fields among multiple indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFieldCapsGetRequest
*/
func (a *DefaultAPIService) FieldCapsGet(ctx context.Context) ApiFieldCapsGetRequest {
	return ApiFieldCapsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) FieldCapsGetExecute(r ApiFieldCapsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.FieldCapsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_field_caps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.includeUnmapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unmapped", r.includeUnmapped, "")
	} else {
		var defaultValue bool = false
		r.includeUnmapped = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFieldCapsGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	fields *[]string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	includeUnmapped *bool
}

// Comma-separated list of field names.
func (r ApiFieldCapsGetWithIndexRequest) Fields(fields []string) ApiFieldCapsGetWithIndexRequest {
	r.fields = &fields
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiFieldCapsGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiFieldCapsGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiFieldCapsGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiFieldCapsGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiFieldCapsGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiFieldCapsGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Indicates whether unmapped fields should be included in the response.
func (r ApiFieldCapsGetWithIndexRequest) IncludeUnmapped(includeUnmapped bool) ApiFieldCapsGetWithIndexRequest {
	r.includeUnmapped = &includeUnmapped
	return r
}

func (r ApiFieldCapsGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.FieldCapsGetWithIndexExecute(r)
}

/*
FieldCapsGetWithIndex Method for FieldCapsGetWithIndex

Returns the information about the capabilities of fields among multiple indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiFieldCapsGetWithIndexRequest
*/
func (a *DefaultAPIService) FieldCapsGetWithIndex(ctx context.Context, index string) ApiFieldCapsGetWithIndexRequest {
	return ApiFieldCapsGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) FieldCapsGetWithIndexExecute(r ApiFieldCapsGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.FieldCapsGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_field_caps"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.includeUnmapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unmapped", r.includeUnmapped, "")
	} else {
		var defaultValue bool = false
		r.includeUnmapped = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFieldCapsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	fields *[]string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	includeUnmapped *bool
	body *map[string]interface{}
}

// Comma-separated list of field names.
func (r ApiFieldCapsPostRequest) Fields(fields []string) ApiFieldCapsPostRequest {
	r.fields = &fields
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiFieldCapsPostRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiFieldCapsPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiFieldCapsPostRequest) AllowNoIndices(allowNoIndices bool) ApiFieldCapsPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiFieldCapsPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiFieldCapsPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Indicates whether unmapped fields should be included in the response.
func (r ApiFieldCapsPostRequest) IncludeUnmapped(includeUnmapped bool) ApiFieldCapsPostRequest {
	r.includeUnmapped = &includeUnmapped
	return r
}

func (r ApiFieldCapsPostRequest) Body(body map[string]interface{}) ApiFieldCapsPostRequest {
	r.body = &body
	return r
}

func (r ApiFieldCapsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FieldCapsPostExecute(r)
}

/*
FieldCapsPost Method for FieldCapsPost

Returns the information about the capabilities of fields among multiple indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFieldCapsPostRequest
*/
func (a *DefaultAPIService) FieldCapsPost(ctx context.Context) ApiFieldCapsPostRequest {
	return ApiFieldCapsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) FieldCapsPostExecute(r ApiFieldCapsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.FieldCapsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_field_caps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.includeUnmapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unmapped", r.includeUnmapped, "")
	} else {
		var defaultValue bool = false
		r.includeUnmapped = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFieldCapsPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	fields *[]string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	includeUnmapped *bool
	body *map[string]interface{}
}

// Comma-separated list of field names.
func (r ApiFieldCapsPostWithIndexRequest) Fields(fields []string) ApiFieldCapsPostWithIndexRequest {
	r.fields = &fields
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiFieldCapsPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiFieldCapsPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiFieldCapsPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiFieldCapsPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiFieldCapsPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiFieldCapsPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Indicates whether unmapped fields should be included in the response.
func (r ApiFieldCapsPostWithIndexRequest) IncludeUnmapped(includeUnmapped bool) ApiFieldCapsPostWithIndexRequest {
	r.includeUnmapped = &includeUnmapped
	return r
}

func (r ApiFieldCapsPostWithIndexRequest) Body(body map[string]interface{}) ApiFieldCapsPostWithIndexRequest {
	r.body = &body
	return r
}

func (r ApiFieldCapsPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.FieldCapsPostWithIndexExecute(r)
}

/*
FieldCapsPostWithIndex Method for FieldCapsPostWithIndex

Returns the information about the capabilities of fields among multiple indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiFieldCapsPostWithIndexRequest
*/
func (a *DefaultAPIService) FieldCapsPostWithIndex(ctx context.Context, index string) ApiFieldCapsPostWithIndexRequest {
	return ApiFieldCapsPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) FieldCapsPostWithIndexExecute(r ApiFieldCapsPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.FieldCapsPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_field_caps"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.includeUnmapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unmapped", r.includeUnmapped, "")
	} else {
		var defaultValue bool = false
		r.includeUnmapped = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFlushCacheRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiFlushCacheRequest) Execute() (*FlushCacheResponseContent, *http.Response, error) {
	return r.ApiService.FlushCacheExecute(r)
}

/*
FlushCache Method for FlushCache

Flushes the Security plugin user, authentication, and authorization cache.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlushCacheRequest
*/
func (a *DefaultAPIService) FlushCache(ctx context.Context) ApiFlushCacheRequest {
	return ApiFlushCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlushCacheResponseContent
func (a *DefaultAPIService) FlushCacheExecute(r ApiFlushCacheRequest) (*FlushCacheResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlushCacheResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.FlushCache")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	storedFields *[]string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	version *int32
	versionType *VersionType
}

// Comma-separated list of stored fields to return.
func (r ApiGetRequest) StoredFields(storedFields []string) ApiGetRequest {
	r.storedFields = &storedFields
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiGetRequest) Preference(preference string) ApiGetRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r ApiGetRequest) Realtime(realtime bool) ApiGetRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r ApiGetRequest) Refresh(refresh bool) ApiGetRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiGetRequest) Routing(routing string) ApiGetRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiGetRequest) Source(source []string) ApiGetRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiGetRequest) SourceExcludes(sourceExcludes []string) ApiGetRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiGetRequest) SourceIncludes(sourceIncludes []string) ApiGetRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// Explicit version number for concurrency control.
func (r ApiGetRequest) Version(version int32) ApiGetRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiGetRequest) VersionType(versionType VersionType) ApiGetRequest {
	r.versionType = &versionType
	return r
}

func (r ApiGetRequest) Execute() (*GetResponseContent, *http.Response, error) {
	return r.ApiService.GetExecute(r)
}

/*
Get Method for Get

Returns a document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return ApiGetRequest
*/
func (a *DefaultAPIService) Get(ctx context.Context, id string, index string) ApiGetRequest {
	return ApiGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
//  @return GetResponseContent
func (a *DefaultAPIService) GetExecute(r ApiGetRequest) (*GetResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Get")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_doc/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountDetailsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetAccountDetailsRequest) Execute() (*AccountDetails, *http.Response, error) {
	return r.ApiService.GetAccountDetailsExecute(r)
}

/*
GetAccountDetails Method for GetAccountDetails

Returns account details for the current user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountDetailsRequest
*/
func (a *DefaultAPIService) GetAccountDetails(ctx context.Context) ApiGetAccountDetailsRequest {
	return ApiGetAccountDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountDetails
func (a *DefaultAPIService) GetAccountDetailsExecute(r ApiGetAccountDetailsRequest) (*AccountDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetAccountDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActionGroupRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	actionGroup string
}

func (r ApiGetActionGroupRequest) Execute() (*map[string]ActionGroup, *http.Response, error) {
	return r.ApiService.GetActionGroupExecute(r)
}

/*
GetActionGroup Method for GetActionGroup

Retrieves one action group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionGroup Action group to retrieve.
 @return ApiGetActionGroupRequest
*/
func (a *DefaultAPIService) GetActionGroup(ctx context.Context, actionGroup string) ApiGetActionGroupRequest {
	return ApiGetActionGroupRequest{
		ApiService: a,
		ctx: ctx,
		actionGroup: actionGroup,
	}
}

// Execute executes the request
//  @return map[string]ActionGroup
func (a *DefaultAPIService) GetActionGroupExecute(r ApiGetActionGroupRequest) (*map[string]ActionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]ActionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetActionGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/actiongroups/{action_group}"
	localVarPath = strings.Replace(localVarPath, "{"+"action_group"+"}", url.PathEscape(parameterValueToString(r.actionGroup, "actionGroup")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActionGroupsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetActionGroupsRequest) Execute() (*map[string]ActionGroup, *http.Response, error) {
	return r.ApiService.GetActionGroupsExecute(r)
}

/*
GetActionGroups Method for GetActionGroups

Retrieves all action groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetActionGroupsRequest
*/
func (a *DefaultAPIService) GetActionGroups(ctx context.Context) ApiGetActionGroupsRequest {
	return ApiGetActionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]ActionGroup
func (a *DefaultAPIService) GetActionGroupsExecute(r ApiGetActionGroupsRequest) (*map[string]ActionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]ActionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetActionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/actiongroups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllPitsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetAllPitsRequest) Execute() (*GetAllPitsResponseContent, *http.Response, error) {
	return r.ApiService.GetAllPitsExecute(r)
}

/*
GetAllPits Method for GetAllPits

Lists all active point in time searches.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllPitsRequest
*/
func (a *DefaultAPIService) GetAllPits(ctx context.Context) ApiGetAllPitsRequest {
	return ApiGetAllPitsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAllPitsResponseContent
func (a *DefaultAPIService) GetAllPitsExecute(r ApiGetAllPitsRequest) (*GetAllPitsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllPitsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetAllPits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/point_in_time/_all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuditConfigurationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetAuditConfigurationRequest) Execute() (*AuditConfigWithReadOnly, *http.Response, error) {
	return r.ApiService.GetAuditConfigurationExecute(r)
}

/*
GetAuditConfiguration Method for GetAuditConfiguration

Retrieves the audit configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAuditConfigurationRequest
*/
func (a *DefaultAPIService) GetAuditConfiguration(ctx context.Context) ApiGetAuditConfigurationRequest {
	return ApiGetAuditConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuditConfigWithReadOnly
func (a *DefaultAPIService) GetAuditConfigurationExecute(r ApiGetAuditConfigurationRequest) (*AuditConfigWithReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuditConfigWithReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetAuditConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/audit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCertificatesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetCertificatesRequest) Execute() (*GetCertificatesResponseContent, *http.Response, error) {
	return r.ApiService.GetCertificatesExecute(r)
}

/*
GetCertificates Method for GetCertificates

Retrieves the cluster’s security certificates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCertificatesRequest
*/
func (a *DefaultAPIService) GetCertificates(ctx context.Context) ApiGetCertificatesRequest {
	return ApiGetCertificatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCertificatesResponseContent
func (a *DefaultAPIService) GetCertificatesExecute(r ApiGetCertificatesRequest) (*GetCertificatesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCertificatesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetCertificates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/ssl/certs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfigurationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetConfigurationRequest) Execute() (*DynamicConfig, *http.Response, error) {
	return r.ApiService.GetConfigurationExecute(r)
}

/*
GetConfiguration Method for GetConfiguration

Returns the current Security plugin configuration in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConfigurationRequest
*/
func (a *DefaultAPIService) GetConfiguration(ctx context.Context) ApiGetConfigurationRequest {
	return ApiGetConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicConfig
func (a *DefaultAPIService) GetConfigurationExecute(r ApiGetConfigurationRequest) (*DynamicConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/securityconfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDistinguishedNamesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetDistinguishedNamesRequest) Execute() (*map[string]DistinguishedNames, *http.Response, error) {
	return r.ApiService.GetDistinguishedNamesExecute(r)
}

/*
GetDistinguishedNames Method for GetDistinguishedNames

Retrieves all distinguished names in the allow list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDistinguishedNamesRequest
*/
func (a *DefaultAPIService) GetDistinguishedNames(ctx context.Context) ApiGetDistinguishedNamesRequest {
	return ApiGetDistinguishedNamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]DistinguishedNames
func (a *DefaultAPIService) GetDistinguishedNamesExecute(r ApiGetDistinguishedNamesRequest) (*map[string]DistinguishedNames, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]DistinguishedNames
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetDistinguishedNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/nodesdn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDistinguishedNamesWithClusterNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	clusterName string
}

func (r ApiGetDistinguishedNamesWithClusterNameRequest) Execute() (*map[string]DistinguishedNames, *http.Response, error) {
	return r.ApiService.GetDistinguishedNamesWithClusterNameExecute(r)
}

/*
GetDistinguishedNamesWithClusterName Method for GetDistinguishedNamesWithClusterName

Retrieve distinguished names of a specified cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName
 @return ApiGetDistinguishedNamesWithClusterNameRequest
*/
func (a *DefaultAPIService) GetDistinguishedNamesWithClusterName(ctx context.Context, clusterName string) ApiGetDistinguishedNamesWithClusterNameRequest {
	return ApiGetDistinguishedNamesWithClusterNameRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return map[string]DistinguishedNames
func (a *DefaultAPIService) GetDistinguishedNamesWithClusterNameExecute(r ApiGetDistinguishedNamesWithClusterNameRequest) (*map[string]DistinguishedNames, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]DistinguishedNames
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetDistinguishedNamesWithClusterName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/nodesdn/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoleRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
}

func (r ApiGetRoleRequest) Execute() (*map[string]Role, *http.Response, error) {
	return r.ApiService.GetRoleExecute(r)
}

/*
GetRole Method for GetRole

Retrieves one role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return ApiGetRoleRequest
*/
func (a *DefaultAPIService) GetRole(ctx context.Context, role string) ApiGetRoleRequest {
	return ApiGetRoleRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return map[string]Role
func (a *DefaultAPIService) GetRoleExecute(r ApiGetRoleRequest) (*map[string]Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/roles/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoleMappingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
}

func (r ApiGetRoleMappingRequest) Execute() (*map[string]RoleMapping, *http.Response, error) {
	return r.ApiService.GetRoleMappingExecute(r)
}

/*
GetRoleMapping Method for GetRoleMapping

Retrieves one role mapping.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return ApiGetRoleMappingRequest
*/
func (a *DefaultAPIService) GetRoleMapping(ctx context.Context, role string) ApiGetRoleMappingRequest {
	return ApiGetRoleMappingRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return map[string]RoleMapping
func (a *DefaultAPIService) GetRoleMappingExecute(r ApiGetRoleMappingRequest) (*map[string]RoleMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]RoleMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRoleMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/rolesmapping/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoleMappingsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRoleMappingsRequest) Execute() (*map[string]RoleMapping, *http.Response, error) {
	return r.ApiService.GetRoleMappingsExecute(r)
}

/*
GetRoleMappings Method for GetRoleMappings

Retrieves all role mappings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRoleMappingsRequest
*/
func (a *DefaultAPIService) GetRoleMappings(ctx context.Context) ApiGetRoleMappingsRequest {
	return ApiGetRoleMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]RoleMapping
func (a *DefaultAPIService) GetRoleMappingsExecute(r ApiGetRoleMappingsRequest) (*map[string]RoleMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]RoleMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRoleMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/rolesmapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRolesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRolesRequest) Execute() (*map[string]Role, *http.Response, error) {
	return r.ApiService.GetRolesExecute(r)
}

/*
GetRoles Method for GetRoles

Retrieves all roles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRolesRequest
*/
func (a *DefaultAPIService) GetRoles(ctx context.Context) ApiGetRolesRequest {
	return ApiGetRolesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]Role
func (a *DefaultAPIService) GetRolesExecute(r ApiGetRolesRequest) (*map[string]Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetScriptRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout for connection to master node.
func (r ApiGetScriptRequest) MasterTimeout(masterTimeout string) ApiGetScriptRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiGetScriptRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiGetScriptRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiGetScriptRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetScriptExecute(r)
}

/*
GetScript Method for GetScript

Returns a script.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Script ID.
 @return ApiGetScriptRequest
*/
func (a *DefaultAPIService) GetScript(ctx context.Context, id string) ApiGetScriptRequest {
	return ApiGetScriptRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) GetScriptExecute(r ApiGetScriptRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetScript")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetScriptContextRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetScriptContextRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetScriptContextExecute(r)
}

/*
GetScriptContext Method for GetScriptContext

Returns all script contexts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetScriptContextRequest
*/
func (a *DefaultAPIService) GetScriptContext(ctx context.Context) ApiGetScriptContextRequest {
	return ApiGetScriptContextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) GetScriptContextExecute(r ApiGetScriptContextRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetScriptContext")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_script_context"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetScriptLanguagesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetScriptLanguagesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetScriptLanguagesExecute(r)
}

/*
GetScriptLanguages Method for GetScriptLanguages

Returns available script types, languages and contexts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetScriptLanguagesRequest
*/
func (a *DefaultAPIService) GetScriptLanguages(ctx context.Context) ApiGetScriptLanguagesRequest {
	return ApiGetScriptLanguagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) GetScriptLanguagesExecute(r ApiGetScriptLanguagesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetScriptLanguages")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_script_language"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSourceRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	version *int32
	versionType *VersionType
}

// Specify the node or shard the operation should be performed on.
func (r ApiGetSourceRequest) Preference(preference string) ApiGetSourceRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r ApiGetSourceRequest) Realtime(realtime bool) ApiGetSourceRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r ApiGetSourceRequest) Refresh(refresh bool) ApiGetSourceRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiGetSourceRequest) Routing(routing string) ApiGetSourceRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiGetSourceRequest) Source(source []string) ApiGetSourceRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiGetSourceRequest) SourceExcludes(sourceExcludes []string) ApiGetSourceRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiGetSourceRequest) SourceIncludes(sourceIncludes []string) ApiGetSourceRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// Explicit version number for concurrency control.
func (r ApiGetSourceRequest) Version(version int32) ApiGetSourceRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiGetSourceRequest) VersionType(versionType VersionType) ApiGetSourceRequest {
	r.versionType = &versionType
	return r
}

func (r ApiGetSourceRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSourceExecute(r)
}

/*
GetSource Method for GetSource

Returns the source of a document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return ApiGetSourceRequest
*/
func (a *DefaultAPIService) GetSource(ctx context.Context, id string, index string) ApiGetSourceRequest {
	return ApiGetSourceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) GetSourceExecute(r ApiGetSourceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetSource")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_source/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetTenantRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	tenant string
}

func (r ApiGetTenantRequest) Execute() (*map[string]Tenant, *http.Response, error) {
	return r.ApiService.GetTenantExecute(r)
}

/*
GetTenant Method for GetTenant

Retrieves one tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @return ApiGetTenantRequest
*/
func (a *DefaultAPIService) GetTenant(ctx context.Context, tenant string) ApiGetTenantRequest {
	return ApiGetTenantRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
	}
}

// Execute executes the request
//  @return map[string]Tenant
func (a *DefaultAPIService) GetTenantExecute(r ApiGetTenantRequest) (*map[string]Tenant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]Tenant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetTenant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/tenants/{tenant}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTenantsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetTenantsRequest) Execute() (*map[string]Tenant, *http.Response, error) {
	return r.ApiService.GetTenantsExecute(r)
}

/*
GetTenants Method for GetTenants

Retrieves all tenants.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTenantsRequest
*/
func (a *DefaultAPIService) GetTenants(ctx context.Context) ApiGetTenantsRequest {
	return ApiGetTenantsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]Tenant
func (a *DefaultAPIService) GetTenantsExecute(r ApiGetTenantsRequest) (*map[string]Tenant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]Tenant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetTenants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/tenants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	username string
}

func (r ApiGetUserRequest) Execute() (*map[string]User, *http.Response, error) {
	return r.ApiService.GetUserExecute(r)
}

/*
GetUser Method for GetUser

Retrieve one internal user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username
 @return ApiGetUserRequest
*/
func (a *DefaultAPIService) GetUser(ctx context.Context, username string) ApiGetUserRequest {
	return ApiGetUserRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return map[string]User
func (a *DefaultAPIService) GetUserExecute(r ApiGetUserRequest) (*map[string]User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/internalusers/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterValueToString(r.username, "username")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetUsersRequest) Execute() (*map[string]User, *http.Response, error) {
	return r.ApiService.GetUsersExecute(r)
}

/*
GetUsers Method for GetUsers

Retrieve all internal users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsersRequest
*/
func (a *DefaultAPIService) GetUsers(ctx context.Context) ApiGetUsersRequest {
	return ApiGetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]User
func (a *DefaultAPIService) GetUsersExecute(r ApiGetUsersRequest) (*map[string]User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/internalusers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndexPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	opType *OpType
	refresh *RefreshEnum
	routing *string
	timeout *string
	version *int32
	versionType *VersionType
	ifSeqNo *int32
	ifPrimaryTerm *int32
	pipeline *string
	requireAlias *bool
}

func (r ApiIndexPostRequest) Body(body map[string]interface{}) ApiIndexPostRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r ApiIndexPostRequest) WaitForActiveShards(waitForActiveShards string) ApiIndexPostRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Explicit operation type. Defaults to &#x60;index&#x60; for requests with an explicit document ID, and to &#x60;create&#x60;for requests without an explicit document ID.
func (r ApiIndexPostRequest) OpType(opType OpType) ApiIndexPostRequest {
	r.opType = &opType
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r ApiIndexPostRequest) Refresh(refresh RefreshEnum) ApiIndexPostRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiIndexPostRequest) Routing(routing string) ApiIndexPostRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r ApiIndexPostRequest) Timeout(timeout string) ApiIndexPostRequest {
	r.timeout = &timeout
	return r
}

// Explicit version number for concurrency control.
func (r ApiIndexPostRequest) Version(version int32) ApiIndexPostRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiIndexPostRequest) VersionType(versionType VersionType) ApiIndexPostRequest {
	r.versionType = &versionType
	return r
}

// only perform the operation if the last operation that has changed the document has the specified sequence number.
func (r ApiIndexPostRequest) IfSeqNo(ifSeqNo int32) ApiIndexPostRequest {
	r.ifSeqNo = &ifSeqNo
	return r
}

// only perform the operation if the last operation that has changed the document has the specified primary term.
func (r ApiIndexPostRequest) IfPrimaryTerm(ifPrimaryTerm int32) ApiIndexPostRequest {
	r.ifPrimaryTerm = &ifPrimaryTerm
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r ApiIndexPostRequest) Pipeline(pipeline string) ApiIndexPostRequest {
	r.pipeline = &pipeline
	return r
}

// When true, requires destination to be an alias.
func (r ApiIndexPostRequest) RequireAlias(requireAlias bool) ApiIndexPostRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r ApiIndexPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndexPostExecute(r)
}

/*
IndexPost Method for IndexPost

Creates or updates a document in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Index name.
 @return ApiIndexPostRequest
*/
func (a *DefaultAPIService) IndexPost(ctx context.Context, index string) ApiIndexPostRequest {
	return ApiIndexPostRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndexPostExecute(r ApiIndexPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndexPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_doc"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.opType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "op_type", r.opType, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	if r.ifSeqNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_seq_no", r.ifSeqNo, "")
	}
	if r.ifPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_primary_term", r.ifPrimaryTerm, "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndexPostWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	opType *OpType
	refresh *RefreshEnum
	routing *string
	timeout *string
	version *int32
	versionType *VersionType
	ifSeqNo *int32
	ifPrimaryTerm *int32
	pipeline *string
	requireAlias *bool
}

func (r ApiIndexPostWithIdRequest) Body(body map[string]interface{}) ApiIndexPostWithIdRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r ApiIndexPostWithIdRequest) WaitForActiveShards(waitForActiveShards string) ApiIndexPostWithIdRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Explicit operation type. Defaults to &#x60;index&#x60; for requests with an explicit document ID, and to &#x60;create&#x60;for requests without an explicit document ID.
func (r ApiIndexPostWithIdRequest) OpType(opType OpType) ApiIndexPostWithIdRequest {
	r.opType = &opType
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r ApiIndexPostWithIdRequest) Refresh(refresh RefreshEnum) ApiIndexPostWithIdRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiIndexPostWithIdRequest) Routing(routing string) ApiIndexPostWithIdRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r ApiIndexPostWithIdRequest) Timeout(timeout string) ApiIndexPostWithIdRequest {
	r.timeout = &timeout
	return r
}

// Explicit version number for concurrency control.
func (r ApiIndexPostWithIdRequest) Version(version int32) ApiIndexPostWithIdRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiIndexPostWithIdRequest) VersionType(versionType VersionType) ApiIndexPostWithIdRequest {
	r.versionType = &versionType
	return r
}

// only perform the operation if the last operation that has changed the document has the specified sequence number.
func (r ApiIndexPostWithIdRequest) IfSeqNo(ifSeqNo int32) ApiIndexPostWithIdRequest {
	r.ifSeqNo = &ifSeqNo
	return r
}

// only perform the operation if the last operation that has changed the document has the specified primary term.
func (r ApiIndexPostWithIdRequest) IfPrimaryTerm(ifPrimaryTerm int32) ApiIndexPostWithIdRequest {
	r.ifPrimaryTerm = &ifPrimaryTerm
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r ApiIndexPostWithIdRequest) Pipeline(pipeline string) ApiIndexPostWithIdRequest {
	r.pipeline = &pipeline
	return r
}

// When true, requires destination to be an alias.
func (r ApiIndexPostWithIdRequest) RequireAlias(requireAlias bool) ApiIndexPostWithIdRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r ApiIndexPostWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndexPostWithIdExecute(r)
}

/*
IndexPostWithId Method for IndexPostWithId

Creates or updates a document in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return ApiIndexPostWithIdRequest
*/
func (a *DefaultAPIService) IndexPostWithId(ctx context.Context, id string, index string) ApiIndexPostWithIdRequest {
	return ApiIndexPostWithIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndexPostWithIdExecute(r ApiIndexPostWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndexPostWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_doc/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.opType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "op_type", r.opType, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	if r.ifSeqNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_seq_no", r.ifSeqNo, "")
	}
	if r.ifPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_primary_term", r.ifPrimaryTerm, "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndexPutWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	opType *OpType
	refresh *RefreshEnum
	routing *string
	timeout *string
	version *int32
	versionType *VersionType
	ifSeqNo *int32
	ifPrimaryTerm *int32
	pipeline *string
	requireAlias *bool
}

func (r ApiIndexPutWithIdRequest) Body(body map[string]interface{}) ApiIndexPutWithIdRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r ApiIndexPutWithIdRequest) WaitForActiveShards(waitForActiveShards string) ApiIndexPutWithIdRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Explicit operation type. Defaults to &#x60;index&#x60; for requests with an explicit document ID, and to &#x60;create&#x60;for requests without an explicit document ID.
func (r ApiIndexPutWithIdRequest) OpType(opType OpType) ApiIndexPutWithIdRequest {
	r.opType = &opType
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r ApiIndexPutWithIdRequest) Refresh(refresh RefreshEnum) ApiIndexPutWithIdRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiIndexPutWithIdRequest) Routing(routing string) ApiIndexPutWithIdRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r ApiIndexPutWithIdRequest) Timeout(timeout string) ApiIndexPutWithIdRequest {
	r.timeout = &timeout
	return r
}

// Explicit version number for concurrency control.
func (r ApiIndexPutWithIdRequest) Version(version int32) ApiIndexPutWithIdRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiIndexPutWithIdRequest) VersionType(versionType VersionType) ApiIndexPutWithIdRequest {
	r.versionType = &versionType
	return r
}

// only perform the operation if the last operation that has changed the document has the specified sequence number.
func (r ApiIndexPutWithIdRequest) IfSeqNo(ifSeqNo int32) ApiIndexPutWithIdRequest {
	r.ifSeqNo = &ifSeqNo
	return r
}

// only perform the operation if the last operation that has changed the document has the specified primary term.
func (r ApiIndexPutWithIdRequest) IfPrimaryTerm(ifPrimaryTerm int32) ApiIndexPutWithIdRequest {
	r.ifPrimaryTerm = &ifPrimaryTerm
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r ApiIndexPutWithIdRequest) Pipeline(pipeline string) ApiIndexPutWithIdRequest {
	r.pipeline = &pipeline
	return r
}

// When true, requires destination to be an alias.
func (r ApiIndexPutWithIdRequest) RequireAlias(requireAlias bool) ApiIndexPutWithIdRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r ApiIndexPutWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndexPutWithIdExecute(r)
}

/*
IndexPutWithId Method for IndexPutWithId

Creates or updates a document in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return ApiIndexPutWithIdRequest
*/
func (a *DefaultAPIService) IndexPutWithId(ctx context.Context, id string, index string) ApiIndexPutWithIdRequest {
	return ApiIndexPutWithIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndexPutWithIdExecute(r ApiIndexPutWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndexPutWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_doc/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.opType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "op_type", r.opType, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	if r.ifSeqNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_seq_no", r.ifSeqNo, "")
	}
	if r.ifPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_primary_term", r.ifPrimaryTerm, "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesAddBlockRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	block string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Operation timeout.
func (r ApiIndicesAddBlockRequest) Timeout(timeout string) ApiIndicesAddBlockRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesAddBlockRequest) MasterTimeout(masterTimeout string) ApiIndicesAddBlockRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesAddBlockRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesAddBlockRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesAddBlockRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesAddBlockRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesAddBlockRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesAddBlockRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesAddBlockRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesAddBlockRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesAddBlockRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesAddBlockExecute(r)
}

/*
IndicesAddBlock Method for IndicesAddBlock

Adds a block to an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to add a block to.
 @param block The block to add (one of read, write, read_only or metadata).
 @return ApiIndicesAddBlockRequest
*/
func (a *DefaultAPIService) IndicesAddBlock(ctx context.Context, index string, block string) ApiIndicesAddBlockRequest {
	return ApiIndicesAddBlockRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		block: block,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesAddBlockExecute(r ApiIndicesAddBlockRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesAddBlock")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_block/{block}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesAnalyzeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index *string
}

// The name of the index to scope the operation.
func (r ApiIndicesAnalyzeGetRequest) Index(index string) ApiIndicesAnalyzeGetRequest {
	r.index = &index
	return r
}

func (r ApiIndicesAnalyzeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesAnalyzeGetExecute(r)
}

/*
IndicesAnalyzeGet Method for IndicesAnalyzeGet

Performs the analysis process on a text and return the tokens breakdown of the text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesAnalyzeGetRequest
*/
func (a *DefaultAPIService) IndicesAnalyzeGet(ctx context.Context) ApiIndicesAnalyzeGetRequest {
	return ApiIndicesAnalyzeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesAnalyzeGetExecute(r ApiIndicesAnalyzeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesAnalyzeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_analyze"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesAnalyzeGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	index2 *string
}

// The name of the index to scope the operation.
func (r ApiIndicesAnalyzeGetWithIndexRequest) Index2(index2 string) ApiIndicesAnalyzeGetWithIndexRequest {
	r.index2 = &index2
	return r
}

func (r ApiIndicesAnalyzeGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesAnalyzeGetWithIndexExecute(r)
}

/*
IndicesAnalyzeGetWithIndex Method for IndicesAnalyzeGetWithIndex

Performs the analysis process on a text and return the tokens breakdown of the text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the index to scope the operation.
 @return ApiIndicesAnalyzeGetWithIndexRequest
*/
func (a *DefaultAPIService) IndicesAnalyzeGetWithIndex(ctx context.Context, index string) ApiIndicesAnalyzeGetWithIndexRequest {
	return ApiIndicesAnalyzeGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesAnalyzeGetWithIndexExecute(r ApiIndicesAnalyzeGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesAnalyzeGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_analyze"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index2, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesAnalyzePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index *string
	body *map[string]interface{}
}

// The name of the index to scope the operation.
func (r ApiIndicesAnalyzePostRequest) Index(index string) ApiIndicesAnalyzePostRequest {
	r.index = &index
	return r
}

func (r ApiIndicesAnalyzePostRequest) Body(body map[string]interface{}) ApiIndicesAnalyzePostRequest {
	r.body = &body
	return r
}

func (r ApiIndicesAnalyzePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesAnalyzePostExecute(r)
}

/*
IndicesAnalyzePost Method for IndicesAnalyzePost

Performs the analysis process on a text and return the tokens breakdown of the text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesAnalyzePostRequest
*/
func (a *DefaultAPIService) IndicesAnalyzePost(ctx context.Context) ApiIndicesAnalyzePostRequest {
	return ApiIndicesAnalyzePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesAnalyzePostExecute(r ApiIndicesAnalyzePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesAnalyzePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_analyze"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesAnalyzePostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	index2 *string
	body *map[string]interface{}
}

// The name of the index to scope the operation.
func (r ApiIndicesAnalyzePostWithIndexRequest) Index2(index2 string) ApiIndicesAnalyzePostWithIndexRequest {
	r.index2 = &index2
	return r
}

func (r ApiIndicesAnalyzePostWithIndexRequest) Body(body map[string]interface{}) ApiIndicesAnalyzePostWithIndexRequest {
	r.body = &body
	return r
}

func (r ApiIndicesAnalyzePostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesAnalyzePostWithIndexExecute(r)
}

/*
IndicesAnalyzePostWithIndex Method for IndicesAnalyzePostWithIndex

Performs the analysis process on a text and return the tokens breakdown of the text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the index to scope the operation.
 @return ApiIndicesAnalyzePostWithIndexRequest
*/
func (a *DefaultAPIService) IndicesAnalyzePostWithIndex(ctx context.Context, index string) ApiIndicesAnalyzePostWithIndexRequest {
	return ApiIndicesAnalyzePostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesAnalyzePostWithIndexExecute(r ApiIndicesAnalyzePostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesAnalyzePostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_analyze"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index2, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesClearCacheRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	fielddata *bool
	fields *[]string
	query *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	index *[]string
	request *bool
}

// Clear field data.
func (r ApiIndicesClearCacheRequest) Fielddata(fielddata bool) ApiIndicesClearCacheRequest {
	r.fielddata = &fielddata
	return r
}

// Comma-separated list of fields to clear when using the &#x60;fielddata&#x60; parameter (default: all).
func (r ApiIndicesClearCacheRequest) Fields(fields []string) ApiIndicesClearCacheRequest {
	r.fields = &fields
	return r
}

// Clear query caches.
func (r ApiIndicesClearCacheRequest) Query(query bool) ApiIndicesClearCacheRequest {
	r.query = &query
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesClearCacheRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesClearCacheRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesClearCacheRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesClearCacheRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesClearCacheRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesClearCacheRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Comma-separated list of indices; use &#x60;_all&#x60; or empty string to perform the operation on all indices.
func (r ApiIndicesClearCacheRequest) Index(index []string) ApiIndicesClearCacheRequest {
	r.index = &index
	return r
}

// Clear request cache.
func (r ApiIndicesClearCacheRequest) Request(request bool) ApiIndicesClearCacheRequest {
	r.request = &request
	return r
}

func (r ApiIndicesClearCacheRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesClearCacheExecute(r)
}

/*
IndicesClearCache Method for IndicesClearCache

Clears all or specific caches for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesClearCacheRequest
*/
func (a *DefaultAPIService) IndicesClearCache(ctx context.Context) ApiIndicesClearCacheRequest {
	return ApiIndicesClearCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesClearCacheExecute(r ApiIndicesClearCacheRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesClearCache")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cache/clear"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fielddata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata", r.fielddata, "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.index != nil {
		t := *r.index
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "index", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "index", t, "multi")
		}
	}
	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesClearCacheWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	fielddata *bool
	fields *[]string
	query *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	index2 *[]string
	request *bool
}

// Clear field data.
func (r ApiIndicesClearCacheWithIndexRequest) Fielddata(fielddata bool) ApiIndicesClearCacheWithIndexRequest {
	r.fielddata = &fielddata
	return r
}

// Comma-separated list of fields to clear when using the &#x60;fielddata&#x60; parameter (default: all).
func (r ApiIndicesClearCacheWithIndexRequest) Fields(fields []string) ApiIndicesClearCacheWithIndexRequest {
	r.fields = &fields
	return r
}

// Clear query caches.
func (r ApiIndicesClearCacheWithIndexRequest) Query(query bool) ApiIndicesClearCacheWithIndexRequest {
	r.query = &query
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesClearCacheWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesClearCacheWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesClearCacheWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesClearCacheWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesClearCacheWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesClearCacheWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Comma-separated list of indices; use &#x60;_all&#x60; or empty string to perform the operation on all indices.
func (r ApiIndicesClearCacheWithIndexRequest) Index2(index2 []string) ApiIndicesClearCacheWithIndexRequest {
	r.index2 = &index2
	return r
}

// Clear request cache.
func (r ApiIndicesClearCacheWithIndexRequest) Request(request bool) ApiIndicesClearCacheWithIndexRequest {
	r.request = &request
	return r
}

func (r ApiIndicesClearCacheWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesClearCacheWithIndexExecute(r)
}

/*
IndicesClearCacheWithIndex Method for IndicesClearCacheWithIndex

Clears all or specific caches for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesClearCacheWithIndexRequest
*/
func (a *DefaultAPIService) IndicesClearCacheWithIndex(ctx context.Context, index string) ApiIndicesClearCacheWithIndexRequest {
	return ApiIndicesClearCacheWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesClearCacheWithIndexExecute(r ApiIndicesClearCacheWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesClearCacheWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_cache/clear"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fielddata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata", r.fielddata, "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.index2 != nil {
		t := *r.index2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "index", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "index", t, "multi")
		}
	}
	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesClonePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	target string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// Operation timeout.
func (r ApiIndicesClonePostRequest) Timeout(timeout string) ApiIndicesClonePostRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesClonePostRequest) MasterTimeout(masterTimeout string) ApiIndicesClonePostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesClonePostRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesClonePostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the cloned index before the operation returns.
func (r ApiIndicesClonePostRequest) WaitForActiveShards(waitForActiveShards string) ApiIndicesClonePostRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r ApiIndicesClonePostRequest) Body(body map[string]interface{}) ApiIndicesClonePostRequest {
	r.body = &body
	return r
}

func (r ApiIndicesClonePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesClonePostExecute(r)
}

/*
IndicesClonePost Method for IndicesClonePost

Clones an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the source index to clone.
 @param target The name of the target index.
 @return ApiIndicesClonePostRequest
*/
func (a *DefaultAPIService) IndicesClonePost(ctx context.Context, index string, target string) ApiIndicesClonePostRequest {
	return ApiIndicesClonePostRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		target: target,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesClonePostExecute(r ApiIndicesClonePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesClonePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_clone/{target}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", url.PathEscape(parameterValueToString(r.target, "target")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesClonePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	target string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// Operation timeout.
func (r ApiIndicesClonePutRequest) Timeout(timeout string) ApiIndicesClonePutRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesClonePutRequest) MasterTimeout(masterTimeout string) ApiIndicesClonePutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesClonePutRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesClonePutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the cloned index before the operation returns.
func (r ApiIndicesClonePutRequest) WaitForActiveShards(waitForActiveShards string) ApiIndicesClonePutRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r ApiIndicesClonePutRequest) Body(body map[string]interface{}) ApiIndicesClonePutRequest {
	r.body = &body
	return r
}

func (r ApiIndicesClonePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesClonePutExecute(r)
}

/*
IndicesClonePut Method for IndicesClonePut

Clones an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the source index to clone.
 @param target The name of the target index.
 @return ApiIndicesClonePutRequest
*/
func (a *DefaultAPIService) IndicesClonePut(ctx context.Context, index string, target string) ApiIndicesClonePutRequest {
	return ApiIndicesClonePutRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		target: target,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesClonePutExecute(r ApiIndicesClonePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesClonePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_clone/{target}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", url.PathEscape(parameterValueToString(r.target, "target")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesCloseRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	waitForActiveShards *string
}

// Operation timeout.
func (r ApiIndicesCloseRequest) Timeout(timeout string) ApiIndicesCloseRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesCloseRequest) MasterTimeout(masterTimeout string) ApiIndicesCloseRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesCloseRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesCloseRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesCloseRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesCloseRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesCloseRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesCloseRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesCloseRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesCloseRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Sets the number of active shards to wait for before the operation returns.
func (r ApiIndicesCloseRequest) WaitForActiveShards(waitForActiveShards string) ApiIndicesCloseRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r ApiIndicesCloseRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesCloseExecute(r)
}

/*
IndicesClose Method for IndicesClose

Closes an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to close.
 @return ApiIndicesCloseRequest
*/
func (a *DefaultAPIService) IndicesClose(ctx context.Context, index string) ApiIndicesCloseRequest {
	return ApiIndicesCloseRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesCloseExecute(r ApiIndicesCloseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesClose")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_close"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesCreateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	waitForActiveShards *string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	indicesCreateBodyParams *IndicesCreateBodyParams
}

// Set the number of active shards to wait for before the operation returns.
func (r ApiIndicesCreateRequest) WaitForActiveShards(waitForActiveShards string) ApiIndicesCreateRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Operation timeout.
func (r ApiIndicesCreateRequest) Timeout(timeout string) ApiIndicesCreateRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesCreateRequest) MasterTimeout(masterTimeout string) ApiIndicesCreateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesCreateRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesCreateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesCreateRequest) IndicesCreateBodyParams(indicesCreateBodyParams IndicesCreateBodyParams) ApiIndicesCreateRequest {
	r.indicesCreateBodyParams = &indicesCreateBodyParams
	return r
}

func (r ApiIndicesCreateRequest) Execute() (*IndicesCreateResponseContent, *http.Response, error) {
	return r.ApiService.IndicesCreateExecute(r)
}

/*
IndicesCreate Method for IndicesCreate

Creates an index with optional settings and mappings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Index name.
 @return ApiIndicesCreateRequest
*/
func (a *DefaultAPIService) IndicesCreate(ctx context.Context, index string) ApiIndicesCreateRequest {
	return ApiIndicesCreateRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
//  @return IndicesCreateResponseContent
func (a *DefaultAPIService) IndicesCreateExecute(r ApiIndicesCreateRequest) (*IndicesCreateResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesCreateResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.indicesCreateBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndicesCreateDataStreamRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	body *map[string]interface{}
}

func (r ApiIndicesCreateDataStreamRequest) Body(body map[string]interface{}) ApiIndicesCreateDataStreamRequest {
	r.body = &body
	return r
}

func (r ApiIndicesCreateDataStreamRequest) Execute() (*IndicesCreateDataStreamResponseContent, *http.Response, error) {
	return r.ApiService.IndicesCreateDataStreamExecute(r)
}

/*
IndicesCreateDataStream Method for IndicesCreateDataStream

Creates or updates a data stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the data stream.
 @return ApiIndicesCreateDataStreamRequest
*/
func (a *DefaultAPIService) IndicesCreateDataStream(ctx context.Context, name string) ApiIndicesCreateDataStreamRequest {
	return ApiIndicesCreateDataStreamRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return IndicesCreateDataStreamResponseContent
func (a *DefaultAPIService) IndicesCreateDataStreamExecute(r ApiIndicesCreateDataStreamRequest) (*IndicesCreateDataStreamResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesCreateDataStreamResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesCreateDataStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_data_stream/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndicesDataStreamsStatsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiIndicesDataStreamsStatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesDataStreamsStatsExecute(r)
}

/*
IndicesDataStreamsStats Method for IndicesDataStreamsStats

Provides statistics on operations happening in a data stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesDataStreamsStatsRequest
*/
func (a *DefaultAPIService) IndicesDataStreamsStats(ctx context.Context) ApiIndicesDataStreamsStatsRequest {
	return ApiIndicesDataStreamsStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesDataStreamsStatsExecute(r ApiIndicesDataStreamsStatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDataStreamsStats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_data_stream/_stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesDataStreamsStatsWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
}

func (r ApiIndicesDataStreamsStatsWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesDataStreamsStatsWithNameExecute(r)
}

/*
IndicesDataStreamsStatsWithName Method for IndicesDataStreamsStatsWithName

Provides statistics on operations happening in a data stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of data streams; use `_all` or empty string to perform the operation on all data streams.
 @return ApiIndicesDataStreamsStatsWithNameRequest
*/
func (a *DefaultAPIService) IndicesDataStreamsStatsWithName(ctx context.Context, name string) ApiIndicesDataStreamsStatsWithNameRequest {
	return ApiIndicesDataStreamsStatsWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesDataStreamsStatsWithNameExecute(r ApiIndicesDataStreamsStatsWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDataStreamsStatsWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_data_stream/{name}/_stats"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	timeout *string
	masterTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Operation timeout.
func (r ApiIndicesDeleteRequest) Timeout(timeout string) ApiIndicesDeleteRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesDeleteRequest) MasterTimeout(masterTimeout string) ApiIndicesDeleteRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesDeleteRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesDeleteRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesDeleteRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesDeleteRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesDeleteRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesDeleteRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesDeleteRequest) Execute() (*IndicesDeleteResponseContent, *http.Response, error) {
	return r.ApiService.IndicesDeleteExecute(r)
}

/*
IndicesDelete Method for IndicesDelete

Deletes an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to delete; use `_all` or `*` string to delete all indices.
 @return ApiIndicesDeleteRequest
*/
func (a *DefaultAPIService) IndicesDelete(ctx context.Context, index string) ApiIndicesDeleteRequest {
	return ApiIndicesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
//  @return IndicesDeleteResponseContent
func (a *DefaultAPIService) IndicesDeleteExecute(r ApiIndicesDeleteRequest) (*IndicesDeleteResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesDeleteResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	} else {
		var defaultValue bool = false
		r.allowNoIndices = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndicesDeleteAliasRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout.
func (r ApiIndicesDeleteAliasRequest) Timeout(timeout string) ApiIndicesDeleteAliasRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesDeleteAliasRequest) MasterTimeout(masterTimeout string) ApiIndicesDeleteAliasRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesDeleteAliasRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesDeleteAliasRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesDeleteAliasRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesDeleteAliasExecute(r)
}

/*
IndicesDeleteAlias Method for IndicesDeleteAlias

Deletes an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param name Comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
 @return ApiIndicesDeleteAliasRequest
*/
func (a *DefaultAPIService) IndicesDeleteAlias(ctx context.Context, index string, name string) ApiIndicesDeleteAliasRequest {
	return ApiIndicesDeleteAliasRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesDeleteAliasExecute(r ApiIndicesDeleteAliasRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDeleteAlias")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_alias/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesDeleteAliasPluralRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout.
func (r ApiIndicesDeleteAliasPluralRequest) Timeout(timeout string) ApiIndicesDeleteAliasPluralRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesDeleteAliasPluralRequest) MasterTimeout(masterTimeout string) ApiIndicesDeleteAliasPluralRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesDeleteAliasPluralRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesDeleteAliasPluralRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesDeleteAliasPluralRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesDeleteAliasPluralExecute(r)
}

/*
IndicesDeleteAliasPlural Method for IndicesDeleteAliasPlural

Deletes an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param name Comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
 @return ApiIndicesDeleteAliasPluralRequest
*/
func (a *DefaultAPIService) IndicesDeleteAliasPlural(ctx context.Context, index string, name string) ApiIndicesDeleteAliasPluralRequest {
	return ApiIndicesDeleteAliasPluralRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesDeleteAliasPluralExecute(r ApiIndicesDeleteAliasPluralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDeleteAliasPlural")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_aliases/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesDeleteDataStreamRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
}

func (r ApiIndicesDeleteDataStreamRequest) Execute() (*IndicesDeleteDataStreamResponseContent, *http.Response, error) {
	return r.ApiService.IndicesDeleteDataStreamExecute(r)
}

/*
IndicesDeleteDataStream Method for IndicesDeleteDataStream

Deletes a data stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of data streams; use `_all` or empty string to perform the operation on all data streams.
 @return ApiIndicesDeleteDataStreamRequest
*/
func (a *DefaultAPIService) IndicesDeleteDataStream(ctx context.Context, name string) ApiIndicesDeleteDataStreamRequest {
	return ApiIndicesDeleteDataStreamRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return IndicesDeleteDataStreamResponseContent
func (a *DefaultAPIService) IndicesDeleteDataStreamExecute(r ApiIndicesDeleteDataStreamRequest) (*IndicesDeleteDataStreamResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesDeleteDataStreamResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDeleteDataStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_data_stream/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndicesDeleteIndexTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout.
func (r ApiIndicesDeleteIndexTemplateRequest) Timeout(timeout string) ApiIndicesDeleteIndexTemplateRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesDeleteIndexTemplateRequest) MasterTimeout(masterTimeout string) ApiIndicesDeleteIndexTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesDeleteIndexTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesDeleteIndexTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesDeleteIndexTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesDeleteIndexTemplateExecute(r)
}

/*
IndicesDeleteIndexTemplate Method for IndicesDeleteIndexTemplate

Deletes an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return ApiIndicesDeleteIndexTemplateRequest
*/
func (a *DefaultAPIService) IndicesDeleteIndexTemplate(ctx context.Context, name string) ApiIndicesDeleteIndexTemplateRequest {
	return ApiIndicesDeleteIndexTemplateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesDeleteIndexTemplateExecute(r ApiIndicesDeleteIndexTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDeleteIndexTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesDeleteTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout.
func (r ApiIndicesDeleteTemplateRequest) Timeout(timeout string) ApiIndicesDeleteTemplateRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesDeleteTemplateRequest) MasterTimeout(masterTimeout string) ApiIndicesDeleteTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesDeleteTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesDeleteTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesDeleteTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesDeleteTemplateExecute(r)
}

/*
IndicesDeleteTemplate Method for IndicesDeleteTemplate

Deletes an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return ApiIndicesDeleteTemplateRequest
*/
func (a *DefaultAPIService) IndicesDeleteTemplate(ctx context.Context, name string) ApiIndicesDeleteTemplateRequest {
	return ApiIndicesDeleteTemplateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesDeleteTemplateExecute(r ApiIndicesDeleteTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDeleteTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesExistsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	local *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
	includeDefaults *bool
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesExistsRequest) Local(local bool) ApiIndicesExistsRequest {
	r.local = &local
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesExistsRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesExistsRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesExistsRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesExistsRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesExistsRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesExistsRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r ApiIndicesExistsRequest) FlatSettings(flatSettings bool) ApiIndicesExistsRequest {
	r.flatSettings = &flatSettings
	return r
}

// Whether to return all default setting for each of the indices.
func (r ApiIndicesExistsRequest) IncludeDefaults(includeDefaults bool) ApiIndicesExistsRequest {
	r.includeDefaults = &includeDefaults
	return r
}

func (r ApiIndicesExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesExistsExecute(r)
}

/*
IndicesExists Method for IndicesExists

Returns information about whether a particular index exists.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices.
 @return ApiIndicesExistsRequest
*/
func (a *DefaultAPIService) IndicesExists(ctx context.Context, index string) ApiIndicesExistsRequest {
	return ApiIndicesExistsRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesExistsExecute(r ApiIndicesExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	} else {
		var defaultValue bool = false
		r.allowNoIndices = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	} else {
		var defaultValue bool = false
		r.includeDefaults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesExistsAliasRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesExistsAliasRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesExistsAliasRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesExistsAliasRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesExistsAliasRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesExistsAliasRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesExistsAliasRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesExistsAliasRequest) Local(local bool) ApiIndicesExistsAliasRequest {
	r.local = &local
	return r
}

func (r ApiIndicesExistsAliasRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesExistsAliasExecute(r)
}

/*
IndicesExistsAlias Method for IndicesExistsAlias

Returns information about whether a particular alias exists.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of alias names.
 @return ApiIndicesExistsAliasRequest
*/
func (a *DefaultAPIService) IndicesExistsAlias(ctx context.Context, name string) ApiIndicesExistsAliasRequest {
	return ApiIndicesExistsAliasRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesExistsAliasExecute(r ApiIndicesExistsAliasRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesExistsAlias")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_alias/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesExistsAliasWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesExistsAliasWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesExistsAliasWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesExistsAliasWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesExistsAliasWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesExistsAliasWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesExistsAliasWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesExistsAliasWithIndexRequest) Local(local bool) ApiIndicesExistsAliasWithIndexRequest {
	r.local = &local
	return r
}

func (r ApiIndicesExistsAliasWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesExistsAliasWithIndexExecute(r)
}

/*
IndicesExistsAliasWithIndex Method for IndicesExistsAliasWithIndex

Returns information about whether a particular alias exists.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to filter aliases.
 @param name Comma-separated list of alias names.
 @return ApiIndicesExistsAliasWithIndexRequest
*/
func (a *DefaultAPIService) IndicesExistsAliasWithIndex(ctx context.Context, index string, name string) ApiIndicesExistsAliasWithIndexRequest {
	return ApiIndicesExistsAliasWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesExistsAliasWithIndexExecute(r ApiIndicesExistsAliasWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesExistsAliasWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_alias/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesExistsIndexTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	flatSettings *bool
	masterTimeout *string
	local *bool
}

// Return settings in flat format.
func (r ApiIndicesExistsIndexTemplateRequest) FlatSettings(flatSettings bool) ApiIndicesExistsIndexTemplateRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesExistsIndexTemplateRequest) MasterTimeout(masterTimeout string) ApiIndicesExistsIndexTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesExistsIndexTemplateRequest) Local(local bool) ApiIndicesExistsIndexTemplateRequest {
	r.local = &local
	return r
}

func (r ApiIndicesExistsIndexTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesExistsIndexTemplateExecute(r)
}

/*
IndicesExistsIndexTemplate Method for IndicesExistsIndexTemplate

Returns information about whether a particular index template exists.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return ApiIndicesExistsIndexTemplateRequest
*/
func (a *DefaultAPIService) IndicesExistsIndexTemplate(ctx context.Context, name string) ApiIndicesExistsIndexTemplateRequest {
	return ApiIndicesExistsIndexTemplateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesExistsIndexTemplateExecute(r ApiIndicesExistsIndexTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesExistsIndexTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesExistsTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	flatSettings *bool
	masterTimeout *string
	local *bool
}

// Return settings in flat format.
func (r ApiIndicesExistsTemplateRequest) FlatSettings(flatSettings bool) ApiIndicesExistsTemplateRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesExistsTemplateRequest) MasterTimeout(masterTimeout string) ApiIndicesExistsTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesExistsTemplateRequest) Local(local bool) ApiIndicesExistsTemplateRequest {
	r.local = &local
	return r
}

func (r ApiIndicesExistsTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesExistsTemplateExecute(r)
}

/*
IndicesExistsTemplate Method for IndicesExistsTemplate

Returns information about whether a particular index template exists.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated names of the index templates.
 @return ApiIndicesExistsTemplateRequest
*/
func (a *DefaultAPIService) IndicesExistsTemplate(ctx context.Context, name string) ApiIndicesExistsTemplateRequest {
	return ApiIndicesExistsTemplateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesExistsTemplateExecute(r ApiIndicesExistsTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesExistsTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesFlushGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	force *bool
	waitIfOngoing *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
func (r ApiIndicesFlushGetRequest) Force(force bool) ApiIndicesFlushGetRequest {
	r.force = &force
	return r
}

// If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
func (r ApiIndicesFlushGetRequest) WaitIfOngoing(waitIfOngoing bool) ApiIndicesFlushGetRequest {
	r.waitIfOngoing = &waitIfOngoing
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesFlushGetRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesFlushGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesFlushGetRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesFlushGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesFlushGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesFlushGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesFlushGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesFlushGetExecute(r)
}

/*
IndicesFlushGet Method for IndicesFlushGet

Performs the flush operation on one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesFlushGetRequest
*/
func (a *DefaultAPIService) IndicesFlushGet(ctx context.Context) ApiIndicesFlushGetRequest {
	return ApiIndicesFlushGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesFlushGetExecute(r ApiIndicesFlushGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesFlushGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_flush"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.waitIfOngoing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_if_ongoing", r.waitIfOngoing, "")
	} else {
		var defaultValue bool = true
		r.waitIfOngoing = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesFlushGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	force *bool
	waitIfOngoing *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
func (r ApiIndicesFlushGetWithIndexRequest) Force(force bool) ApiIndicesFlushGetWithIndexRequest {
	r.force = &force
	return r
}

// If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
func (r ApiIndicesFlushGetWithIndexRequest) WaitIfOngoing(waitIfOngoing bool) ApiIndicesFlushGetWithIndexRequest {
	r.waitIfOngoing = &waitIfOngoing
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesFlushGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesFlushGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesFlushGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesFlushGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesFlushGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesFlushGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesFlushGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesFlushGetWithIndexExecute(r)
}

/*
IndicesFlushGetWithIndex Method for IndicesFlushGetWithIndex

Performs the flush operation on one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesFlushGetWithIndexRequest
*/
func (a *DefaultAPIService) IndicesFlushGetWithIndex(ctx context.Context, index string) ApiIndicesFlushGetWithIndexRequest {
	return ApiIndicesFlushGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesFlushGetWithIndexExecute(r ApiIndicesFlushGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesFlushGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_flush"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.waitIfOngoing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_if_ongoing", r.waitIfOngoing, "")
	} else {
		var defaultValue bool = true
		r.waitIfOngoing = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesFlushPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	force *bool
	waitIfOngoing *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
func (r ApiIndicesFlushPostRequest) Force(force bool) ApiIndicesFlushPostRequest {
	r.force = &force
	return r
}

// If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
func (r ApiIndicesFlushPostRequest) WaitIfOngoing(waitIfOngoing bool) ApiIndicesFlushPostRequest {
	r.waitIfOngoing = &waitIfOngoing
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesFlushPostRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesFlushPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesFlushPostRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesFlushPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesFlushPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesFlushPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesFlushPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesFlushPostExecute(r)
}

/*
IndicesFlushPost Method for IndicesFlushPost

Performs the flush operation on one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesFlushPostRequest
*/
func (a *DefaultAPIService) IndicesFlushPost(ctx context.Context) ApiIndicesFlushPostRequest {
	return ApiIndicesFlushPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesFlushPostExecute(r ApiIndicesFlushPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesFlushPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_flush"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.waitIfOngoing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_if_ongoing", r.waitIfOngoing, "")
	} else {
		var defaultValue bool = true
		r.waitIfOngoing = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesFlushPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	force *bool
	waitIfOngoing *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
func (r ApiIndicesFlushPostWithIndexRequest) Force(force bool) ApiIndicesFlushPostWithIndexRequest {
	r.force = &force
	return r
}

// If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
func (r ApiIndicesFlushPostWithIndexRequest) WaitIfOngoing(waitIfOngoing bool) ApiIndicesFlushPostWithIndexRequest {
	r.waitIfOngoing = &waitIfOngoing
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesFlushPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesFlushPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesFlushPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesFlushPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesFlushPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesFlushPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesFlushPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesFlushPostWithIndexExecute(r)
}

/*
IndicesFlushPostWithIndex Method for IndicesFlushPostWithIndex

Performs the flush operation on one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesFlushPostWithIndexRequest
*/
func (a *DefaultAPIService) IndicesFlushPostWithIndex(ctx context.Context, index string) ApiIndicesFlushPostWithIndexRequest {
	return ApiIndicesFlushPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesFlushPostWithIndexExecute(r ApiIndicesFlushPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesFlushPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_flush"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.waitIfOngoing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_if_ongoing", r.waitIfOngoing, "")
	} else {
		var defaultValue bool = true
		r.waitIfOngoing = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesForcemergeRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	flush *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	maxNumSegments *int32
	onlyExpungeDeletes *bool
}

// Specify whether the index should be flushed after performing the operation.
func (r ApiIndicesForcemergeRequest) Flush(flush bool) ApiIndicesForcemergeRequest {
	r.flush = &flush
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesForcemergeRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesForcemergeRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesForcemergeRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesForcemergeRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesForcemergeRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesForcemergeRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// The number of segments the index should be merged into (default: dynamic).
func (r ApiIndicesForcemergeRequest) MaxNumSegments(maxNumSegments int32) ApiIndicesForcemergeRequest {
	r.maxNumSegments = &maxNumSegments
	return r
}

// Specify whether the operation should only expunge deleted documents.
func (r ApiIndicesForcemergeRequest) OnlyExpungeDeletes(onlyExpungeDeletes bool) ApiIndicesForcemergeRequest {
	r.onlyExpungeDeletes = &onlyExpungeDeletes
	return r
}

func (r ApiIndicesForcemergeRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesForcemergeExecute(r)
}

/*
IndicesForcemerge Method for IndicesForcemerge

Performs the force merge operation on one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesForcemergeRequest
*/
func (a *DefaultAPIService) IndicesForcemerge(ctx context.Context) ApiIndicesForcemergeRequest {
	return ApiIndicesForcemergeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesForcemergeExecute(r ApiIndicesForcemergeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesForcemerge")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_forcemerge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flush != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flush", r.flush, "")
	} else {
		var defaultValue bool = true
		r.flush = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.maxNumSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_num_segments", r.maxNumSegments, "")
	}
	if r.onlyExpungeDeletes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_expunge_deletes", r.onlyExpungeDeletes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesForcemergeWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	flush *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	maxNumSegments *int32
	onlyExpungeDeletes *bool
}

// Specify whether the index should be flushed after performing the operation.
func (r ApiIndicesForcemergeWithIndexRequest) Flush(flush bool) ApiIndicesForcemergeWithIndexRequest {
	r.flush = &flush
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesForcemergeWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesForcemergeWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesForcemergeWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesForcemergeWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesForcemergeWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesForcemergeWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// The number of segments the index should be merged into (default: dynamic).
func (r ApiIndicesForcemergeWithIndexRequest) MaxNumSegments(maxNumSegments int32) ApiIndicesForcemergeWithIndexRequest {
	r.maxNumSegments = &maxNumSegments
	return r
}

// Specify whether the operation should only expunge deleted documents.
func (r ApiIndicesForcemergeWithIndexRequest) OnlyExpungeDeletes(onlyExpungeDeletes bool) ApiIndicesForcemergeWithIndexRequest {
	r.onlyExpungeDeletes = &onlyExpungeDeletes
	return r
}

func (r ApiIndicesForcemergeWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesForcemergeWithIndexExecute(r)
}

/*
IndicesForcemergeWithIndex Method for IndicesForcemergeWithIndex

Performs the force merge operation on one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesForcemergeWithIndexRequest
*/
func (a *DefaultAPIService) IndicesForcemergeWithIndex(ctx context.Context, index string) ApiIndicesForcemergeWithIndexRequest {
	return ApiIndicesForcemergeWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesForcemergeWithIndexExecute(r ApiIndicesForcemergeWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesForcemergeWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_forcemerge"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flush != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flush", r.flush, "")
	} else {
		var defaultValue bool = true
		r.flush = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.maxNumSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_num_segments", r.maxNumSegments, "")
	}
	if r.onlyExpungeDeletes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_expunge_deletes", r.onlyExpungeDeletes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	local *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
	includeDefaults *bool
	masterTimeout *string
	clusterManagerTimeout *string
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetRequest) Local(local bool) ApiIndicesGetRequest {
	r.local = &local
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r ApiIndicesGetRequest) FlatSettings(flatSettings bool) ApiIndicesGetRequest {
	r.flatSettings = &flatSettings
	return r
}

// Whether to return all default setting for each of the indices.
func (r ApiIndicesGetRequest) IncludeDefaults(includeDefaults bool) ApiIndicesGetRequest {
	r.includeDefaults = &includeDefaults
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesGetRequest) MasterTimeout(masterTimeout string) ApiIndicesGetRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesGetRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesGetRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetExecute(r)
}

/*
IndicesGet Method for IndicesGet

Returns information about one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices.
 @return ApiIndicesGetRequest
*/
func (a *DefaultAPIService) IndicesGet(ctx context.Context, index string) ApiIndicesGetRequest {
	return ApiIndicesGetRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetExecute(r ApiIndicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	} else {
		var defaultValue bool = false
		r.allowNoIndices = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	} else {
		var defaultValue bool = false
		r.includeDefaults = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetAliasRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetAliasRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetAliasRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetAliasRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetAliasRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetAliasRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetAliasRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetAliasRequest) Local(local bool) ApiIndicesGetAliasRequest {
	r.local = &local
	return r
}

func (r ApiIndicesGetAliasRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetAliasExecute(r)
}

/*
IndicesGetAlias Method for IndicesGetAlias

Returns an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesGetAliasRequest
*/
func (a *DefaultAPIService) IndicesGetAlias(ctx context.Context) ApiIndicesGetAliasRequest {
	return ApiIndicesGetAliasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetAliasExecute(r ApiIndicesGetAliasRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetAlias")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_alias"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetAliasWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetAliasWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetAliasWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetAliasWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetAliasWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetAliasWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetAliasWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetAliasWithIndexRequest) Local(local bool) ApiIndicesGetAliasWithIndexRequest {
	r.local = &local
	return r
}

func (r ApiIndicesGetAliasWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetAliasWithIndexExecute(r)
}

/*
IndicesGetAliasWithIndex Method for IndicesGetAliasWithIndex

Returns an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to filter aliases.
 @return ApiIndicesGetAliasWithIndexRequest
*/
func (a *DefaultAPIService) IndicesGetAliasWithIndex(ctx context.Context, index string) ApiIndicesGetAliasWithIndexRequest {
	return ApiIndicesGetAliasWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetAliasWithIndexExecute(r ApiIndicesGetAliasWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetAliasWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_alias"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetAliasWithIndexNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetAliasWithIndexNameRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetAliasWithIndexNameRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetAliasWithIndexNameRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetAliasWithIndexNameRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetAliasWithIndexNameRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetAliasWithIndexNameRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetAliasWithIndexNameRequest) Local(local bool) ApiIndicesGetAliasWithIndexNameRequest {
	r.local = &local
	return r
}

func (r ApiIndicesGetAliasWithIndexNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetAliasWithIndexNameExecute(r)
}

/*
IndicesGetAliasWithIndexName Method for IndicesGetAliasWithIndexName

Returns an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to filter aliases.
 @param name Comma-separated list of alias names.
 @return ApiIndicesGetAliasWithIndexNameRequest
*/
func (a *DefaultAPIService) IndicesGetAliasWithIndexName(ctx context.Context, index string, name string) ApiIndicesGetAliasWithIndexNameRequest {
	return ApiIndicesGetAliasWithIndexNameRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetAliasWithIndexNameExecute(r ApiIndicesGetAliasWithIndexNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetAliasWithIndexName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_alias/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetAliasWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetAliasWithNameRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetAliasWithNameRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetAliasWithNameRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetAliasWithNameRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetAliasWithNameRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetAliasWithNameRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetAliasWithNameRequest) Local(local bool) ApiIndicesGetAliasWithNameRequest {
	r.local = &local
	return r
}

func (r ApiIndicesGetAliasWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetAliasWithNameExecute(r)
}

/*
IndicesGetAliasWithName Method for IndicesGetAliasWithName

Returns an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of alias names.
 @return ApiIndicesGetAliasWithNameRequest
*/
func (a *DefaultAPIService) IndicesGetAliasWithName(ctx context.Context, name string) ApiIndicesGetAliasWithNameRequest {
	return ApiIndicesGetAliasWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetAliasWithNameExecute(r ApiIndicesGetAliasWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetAliasWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_alias/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetDataStreamRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiIndicesGetDataStreamRequest) Execute() (*IndicesGetDataStreamResponseContent, *http.Response, error) {
	return r.ApiService.IndicesGetDataStreamExecute(r)
}

/*
IndicesGetDataStream Method for IndicesGetDataStream

Returns data streams.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesGetDataStreamRequest
*/
func (a *DefaultAPIService) IndicesGetDataStream(ctx context.Context) ApiIndicesGetDataStreamRequest {
	return ApiIndicesGetDataStreamRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IndicesGetDataStreamResponseContent
func (a *DefaultAPIService) IndicesGetDataStreamExecute(r ApiIndicesGetDataStreamRequest) (*IndicesGetDataStreamResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesGetDataStreamResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetDataStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_data_stream"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndicesGetDataStreamWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
}

func (r ApiIndicesGetDataStreamWithNameRequest) Execute() (*IndicesGetDataStreamWithNameResponseContent, *http.Response, error) {
	return r.ApiService.IndicesGetDataStreamWithNameExecute(r)
}

/*
IndicesGetDataStreamWithName Method for IndicesGetDataStreamWithName

Returns data streams.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of data streams; use `_all` or empty string to perform the operation on all data streams.
 @return ApiIndicesGetDataStreamWithNameRequest
*/
func (a *DefaultAPIService) IndicesGetDataStreamWithName(ctx context.Context, name string) ApiIndicesGetDataStreamWithNameRequest {
	return ApiIndicesGetDataStreamWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return IndicesGetDataStreamWithNameResponseContent
func (a *DefaultAPIService) IndicesGetDataStreamWithNameExecute(r ApiIndicesGetDataStreamWithNameRequest) (*IndicesGetDataStreamWithNameResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesGetDataStreamWithNameResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetDataStreamWithName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_data_stream/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndicesGetFieldMappingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	fields string
	includeDefaults *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether the default mapping values should be returned as well.
func (r ApiIndicesGetFieldMappingRequest) IncludeDefaults(includeDefaults bool) ApiIndicesGetFieldMappingRequest {
	r.includeDefaults = &includeDefaults
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetFieldMappingRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetFieldMappingRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetFieldMappingRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetFieldMappingRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetFieldMappingRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetFieldMappingRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetFieldMappingRequest) Local(local bool) ApiIndicesGetFieldMappingRequest {
	r.local = &local
	return r
}

func (r ApiIndicesGetFieldMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetFieldMappingExecute(r)
}

/*
IndicesGetFieldMapping Method for IndicesGetFieldMapping

Returns mapping for one or more fields.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fields Comma-separated list of fields.
 @return ApiIndicesGetFieldMappingRequest
*/
func (a *DefaultAPIService) IndicesGetFieldMapping(ctx context.Context, fields string) ApiIndicesGetFieldMappingRequest {
	return ApiIndicesGetFieldMappingRequest{
		ApiService: a,
		ctx: ctx,
		fields: fields,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetFieldMappingExecute(r ApiIndicesGetFieldMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetFieldMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_mapping/field/{fields}"
	localVarPath = strings.Replace(localVarPath, "{"+"fields"+"}", url.PathEscape(parameterValueToString(r.fields, "fields")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetFieldMappingWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	fields string
	includeDefaults *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether the default mapping values should be returned as well.
func (r ApiIndicesGetFieldMappingWithIndexRequest) IncludeDefaults(includeDefaults bool) ApiIndicesGetFieldMappingWithIndexRequest {
	r.includeDefaults = &includeDefaults
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetFieldMappingWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetFieldMappingWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetFieldMappingWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetFieldMappingWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetFieldMappingWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetFieldMappingWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetFieldMappingWithIndexRequest) Local(local bool) ApiIndicesGetFieldMappingWithIndexRequest {
	r.local = &local
	return r
}

func (r ApiIndicesGetFieldMappingWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetFieldMappingWithIndexExecute(r)
}

/*
IndicesGetFieldMappingWithIndex Method for IndicesGetFieldMappingWithIndex

Returns mapping for one or more fields.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices.
 @param fields Comma-separated list of fields.
 @return ApiIndicesGetFieldMappingWithIndexRequest
*/
func (a *DefaultAPIService) IndicesGetFieldMappingWithIndex(ctx context.Context, index string, fields string) ApiIndicesGetFieldMappingWithIndexRequest {
	return ApiIndicesGetFieldMappingWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		fields: fields,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetFieldMappingWithIndexExecute(r ApiIndicesGetFieldMappingWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetFieldMappingWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mapping/field/{fields}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fields"+"}", url.PathEscape(parameterValueToString(r.fields, "fields")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetIndexTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	flatSettings *bool
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Return settings in flat format.
func (r ApiIndicesGetIndexTemplateRequest) FlatSettings(flatSettings bool) ApiIndicesGetIndexTemplateRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesGetIndexTemplateRequest) MasterTimeout(masterTimeout string) ApiIndicesGetIndexTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesGetIndexTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesGetIndexTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetIndexTemplateRequest) Local(local bool) ApiIndicesGetIndexTemplateRequest {
	r.local = &local
	return r
}

func (r ApiIndicesGetIndexTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetIndexTemplateExecute(r)
}

/*
IndicesGetIndexTemplate Method for IndicesGetIndexTemplate

Returns an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesGetIndexTemplateRequest
*/
func (a *DefaultAPIService) IndicesGetIndexTemplate(ctx context.Context) ApiIndicesGetIndexTemplateRequest {
	return ApiIndicesGetIndexTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetIndexTemplateExecute(r ApiIndicesGetIndexTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetIndexTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetIndexTemplateWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	flatSettings *bool
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Return settings in flat format.
func (r ApiIndicesGetIndexTemplateWithNameRequest) FlatSettings(flatSettings bool) ApiIndicesGetIndexTemplateWithNameRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesGetIndexTemplateWithNameRequest) MasterTimeout(masterTimeout string) ApiIndicesGetIndexTemplateWithNameRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesGetIndexTemplateWithNameRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesGetIndexTemplateWithNameRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetIndexTemplateWithNameRequest) Local(local bool) ApiIndicesGetIndexTemplateWithNameRequest {
	r.local = &local
	return r
}

func (r ApiIndicesGetIndexTemplateWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetIndexTemplateWithNameExecute(r)
}

/*
IndicesGetIndexTemplateWithName Method for IndicesGetIndexTemplateWithName

Returns an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated names of the index templates.
 @return ApiIndicesGetIndexTemplateWithNameRequest
*/
func (a *DefaultAPIService) IndicesGetIndexTemplateWithName(ctx context.Context, name string) ApiIndicesGetIndexTemplateWithNameRequest {
	return ApiIndicesGetIndexTemplateWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetIndexTemplateWithNameExecute(r ApiIndicesGetIndexTemplateWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetIndexTemplateWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetMappingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetMappingRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetMappingRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetMappingRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetMappingRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetMappingRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetMappingRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesGetMappingRequest) MasterTimeout(masterTimeout string) ApiIndicesGetMappingRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesGetMappingRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesGetMappingRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetMappingRequest) Local(local bool) ApiIndicesGetMappingRequest {
	r.local = &local
	return r
}

func (r ApiIndicesGetMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetMappingExecute(r)
}

/*
IndicesGetMapping Method for IndicesGetMapping

Returns mappings for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesGetMappingRequest
*/
func (a *DefaultAPIService) IndicesGetMapping(ctx context.Context) ApiIndicesGetMappingRequest {
	return ApiIndicesGetMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetMappingExecute(r ApiIndicesGetMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetMappingWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetMappingWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetMappingWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetMappingWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetMappingWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetMappingWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetMappingWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesGetMappingWithIndexRequest) MasterTimeout(masterTimeout string) ApiIndicesGetMappingWithIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesGetMappingWithIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesGetMappingWithIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetMappingWithIndexRequest) Local(local bool) ApiIndicesGetMappingWithIndexRequest {
	r.local = &local
	return r
}

func (r ApiIndicesGetMappingWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetMappingWithIndexExecute(r)
}

/*
IndicesGetMappingWithIndex Method for IndicesGetMappingWithIndex

Returns mappings for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices.
 @return ApiIndicesGetMappingWithIndexRequest
*/
func (a *DefaultAPIService) IndicesGetMappingWithIndex(ctx context.Context, index string) ApiIndicesGetMappingWithIndexRequest {
	return ApiIndicesGetMappingWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetMappingWithIndexExecute(r ApiIndicesGetMappingWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetMappingWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mapping"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetSettingsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
	local *bool
	includeDefaults *bool
}

// Operation timeout for connection to master node.
func (r ApiIndicesGetSettingsRequest) MasterTimeout(masterTimeout string) ApiIndicesGetSettingsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesGetSettingsRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesGetSettingsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetSettingsRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetSettingsRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetSettingsRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetSettingsRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetSettingsRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetSettingsRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r ApiIndicesGetSettingsRequest) FlatSettings(flatSettings bool) ApiIndicesGetSettingsRequest {
	r.flatSettings = &flatSettings
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetSettingsRequest) Local(local bool) ApiIndicesGetSettingsRequest {
	r.local = &local
	return r
}

// Whether to return all default setting for each of the indices.
func (r ApiIndicesGetSettingsRequest) IncludeDefaults(includeDefaults bool) ApiIndicesGetSettingsRequest {
	r.includeDefaults = &includeDefaults
	return r
}

func (r ApiIndicesGetSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetSettingsExecute(r)
}

/*
IndicesGetSettings Method for IndicesGetSettings

Returns settings for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesGetSettingsRequest
*/
func (a *DefaultAPIService) IndicesGetSettings(ctx context.Context) ApiIndicesGetSettingsRequest {
	return ApiIndicesGetSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetSettingsExecute(r ApiIndicesGetSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	} else {
		var defaultValue bool = false
		r.includeDefaults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetSettingsWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
	local *bool
	includeDefaults *bool
}

// Operation timeout for connection to master node.
func (r ApiIndicesGetSettingsWithIndexRequest) MasterTimeout(masterTimeout string) ApiIndicesGetSettingsWithIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesGetSettingsWithIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesGetSettingsWithIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetSettingsWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetSettingsWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetSettingsWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetSettingsWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetSettingsWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetSettingsWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r ApiIndicesGetSettingsWithIndexRequest) FlatSettings(flatSettings bool) ApiIndicesGetSettingsWithIndexRequest {
	r.flatSettings = &flatSettings
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetSettingsWithIndexRequest) Local(local bool) ApiIndicesGetSettingsWithIndexRequest {
	r.local = &local
	return r
}

// Whether to return all default setting for each of the indices.
func (r ApiIndicesGetSettingsWithIndexRequest) IncludeDefaults(includeDefaults bool) ApiIndicesGetSettingsWithIndexRequest {
	r.includeDefaults = &includeDefaults
	return r
}

func (r ApiIndicesGetSettingsWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetSettingsWithIndexExecute(r)
}

/*
IndicesGetSettingsWithIndex Method for IndicesGetSettingsWithIndex

Returns settings for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesGetSettingsWithIndexRequest
*/
func (a *DefaultAPIService) IndicesGetSettingsWithIndex(ctx context.Context, index string) ApiIndicesGetSettingsWithIndexRequest {
	return ApiIndicesGetSettingsWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetSettingsWithIndexExecute(r ApiIndicesGetSettingsWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetSettingsWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_settings"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	} else {
		var defaultValue bool = false
		r.includeDefaults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetSettingsWithIndexNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
	local *bool
	includeDefaults *bool
}

// Operation timeout for connection to master node.
func (r ApiIndicesGetSettingsWithIndexNameRequest) MasterTimeout(masterTimeout string) ApiIndicesGetSettingsWithIndexNameRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesGetSettingsWithIndexNameRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesGetSettingsWithIndexNameRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetSettingsWithIndexNameRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetSettingsWithIndexNameRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetSettingsWithIndexNameRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetSettingsWithIndexNameRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetSettingsWithIndexNameRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetSettingsWithIndexNameRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r ApiIndicesGetSettingsWithIndexNameRequest) FlatSettings(flatSettings bool) ApiIndicesGetSettingsWithIndexNameRequest {
	r.flatSettings = &flatSettings
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetSettingsWithIndexNameRequest) Local(local bool) ApiIndicesGetSettingsWithIndexNameRequest {
	r.local = &local
	return r
}

// Whether to return all default setting for each of the indices.
func (r ApiIndicesGetSettingsWithIndexNameRequest) IncludeDefaults(includeDefaults bool) ApiIndicesGetSettingsWithIndexNameRequest {
	r.includeDefaults = &includeDefaults
	return r
}

func (r ApiIndicesGetSettingsWithIndexNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetSettingsWithIndexNameExecute(r)
}

/*
IndicesGetSettingsWithIndexName Method for IndicesGetSettingsWithIndexName

Returns settings for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param name Comma-separated list of settings.
 @return ApiIndicesGetSettingsWithIndexNameRequest
*/
func (a *DefaultAPIService) IndicesGetSettingsWithIndexName(ctx context.Context, index string, name string) ApiIndicesGetSettingsWithIndexNameRequest {
	return ApiIndicesGetSettingsWithIndexNameRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetSettingsWithIndexNameExecute(r ApiIndicesGetSettingsWithIndexNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetSettingsWithIndexName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_settings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	} else {
		var defaultValue bool = false
		r.includeDefaults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetSettingsWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
	local *bool
	includeDefaults *bool
}

// Operation timeout for connection to master node.
func (r ApiIndicesGetSettingsWithNameRequest) MasterTimeout(masterTimeout string) ApiIndicesGetSettingsWithNameRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesGetSettingsWithNameRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesGetSettingsWithNameRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetSettingsWithNameRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetSettingsWithNameRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetSettingsWithNameRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetSettingsWithNameRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetSettingsWithNameRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetSettingsWithNameRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r ApiIndicesGetSettingsWithNameRequest) FlatSettings(flatSettings bool) ApiIndicesGetSettingsWithNameRequest {
	r.flatSettings = &flatSettings
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetSettingsWithNameRequest) Local(local bool) ApiIndicesGetSettingsWithNameRequest {
	r.local = &local
	return r
}

// Whether to return all default setting for each of the indices.
func (r ApiIndicesGetSettingsWithNameRequest) IncludeDefaults(includeDefaults bool) ApiIndicesGetSettingsWithNameRequest {
	r.includeDefaults = &includeDefaults
	return r
}

func (r ApiIndicesGetSettingsWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetSettingsWithNameExecute(r)
}

/*
IndicesGetSettingsWithName Method for IndicesGetSettingsWithName

Returns settings for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of settings.
 @return ApiIndicesGetSettingsWithNameRequest
*/
func (a *DefaultAPIService) IndicesGetSettingsWithName(ctx context.Context, name string) ApiIndicesGetSettingsWithNameRequest {
	return ApiIndicesGetSettingsWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetSettingsWithNameExecute(r ApiIndicesGetSettingsWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetSettingsWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_settings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	} else {
		var defaultValue bool = false
		r.includeDefaults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	flatSettings *bool
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Return settings in flat format.
func (r ApiIndicesGetTemplateRequest) FlatSettings(flatSettings bool) ApiIndicesGetTemplateRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesGetTemplateRequest) MasterTimeout(masterTimeout string) ApiIndicesGetTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesGetTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesGetTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetTemplateRequest) Local(local bool) ApiIndicesGetTemplateRequest {
	r.local = &local
	return r
}

func (r ApiIndicesGetTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetTemplateExecute(r)
}

/*
IndicesGetTemplate Method for IndicesGetTemplate

Returns an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesGetTemplateRequest
*/
func (a *DefaultAPIService) IndicesGetTemplate(ctx context.Context) ApiIndicesGetTemplateRequest {
	return ApiIndicesGetTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetTemplateExecute(r ApiIndicesGetTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetTemplateWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	flatSettings *bool
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Return settings in flat format.
func (r ApiIndicesGetTemplateWithNameRequest) FlatSettings(flatSettings bool) ApiIndicesGetTemplateWithNameRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesGetTemplateWithNameRequest) MasterTimeout(masterTimeout string) ApiIndicesGetTemplateWithNameRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesGetTemplateWithNameRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesGetTemplateWithNameRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiIndicesGetTemplateWithNameRequest) Local(local bool) ApiIndicesGetTemplateWithNameRequest {
	r.local = &local
	return r
}

func (r ApiIndicesGetTemplateWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetTemplateWithNameExecute(r)
}

/*
IndicesGetTemplateWithName Method for IndicesGetTemplateWithName

Returns an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated names of the index templates.
 @return ApiIndicesGetTemplateWithNameRequest
*/
func (a *DefaultAPIService) IndicesGetTemplateWithName(ctx context.Context, name string) ApiIndicesGetTemplateWithNameRequest {
	return ApiIndicesGetTemplateWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetTemplateWithNameExecute(r ApiIndicesGetTemplateWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetTemplateWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetUpgradeRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetUpgradeRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetUpgradeRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetUpgradeRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetUpgradeRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetUpgradeRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetUpgradeRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesGetUpgradeRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetUpgradeExecute(r)
}

/*
IndicesGetUpgrade Method for IndicesGetUpgrade

The _upgrade API is no longer useful and will be removed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesGetUpgradeRequest
*/
func (a *DefaultAPIService) IndicesGetUpgrade(ctx context.Context) ApiIndicesGetUpgradeRequest {
	return ApiIndicesGetUpgradeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetUpgradeExecute(r ApiIndicesGetUpgradeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetUpgrade")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_upgrade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesGetUpgradeWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesGetUpgradeWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesGetUpgradeWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesGetUpgradeWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesGetUpgradeWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesGetUpgradeWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesGetUpgradeWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesGetUpgradeWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetUpgradeWithIndexExecute(r)
}

/*
IndicesGetUpgradeWithIndex Method for IndicesGetUpgradeWithIndex

The _upgrade API is no longer useful and will be removed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesGetUpgradeWithIndexRequest
*/
func (a *DefaultAPIService) IndicesGetUpgradeWithIndex(ctx context.Context, index string) ApiIndicesGetUpgradeWithIndexRequest {
	return ApiIndicesGetUpgradeWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetUpgradeWithIndexExecute(r ApiIndicesGetUpgradeWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetUpgradeWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_upgrade"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesOpenRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	timeout *string
	masterTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	waitForActiveShards *string
}

// Operation timeout.
func (r ApiIndicesOpenRequest) Timeout(timeout string) ApiIndicesOpenRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesOpenRequest) MasterTimeout(masterTimeout string) ApiIndicesOpenRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesOpenRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesOpenRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesOpenRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesOpenRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesOpenRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesOpenRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Sets the number of active shards to wait for before the operation returns.
func (r ApiIndicesOpenRequest) WaitForActiveShards(waitForActiveShards string) ApiIndicesOpenRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r ApiIndicesOpenRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesOpenExecute(r)
}

/*
IndicesOpen Method for IndicesOpen

Opens an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to open.
 @return ApiIndicesOpenRequest
*/
func (a *DefaultAPIService) IndicesOpen(ctx context.Context, index string) ApiIndicesOpenRequest {
	return ApiIndicesOpenRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesOpenExecute(r ApiIndicesOpenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesOpen")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_open"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesPutAliasPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	body *map[string]interface{}
}

// Operation timeout.
func (r ApiIndicesPutAliasPostRequest) Timeout(timeout string) ApiIndicesPutAliasPostRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesPutAliasPostRequest) MasterTimeout(masterTimeout string) ApiIndicesPutAliasPostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesPutAliasPostRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesPutAliasPostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesPutAliasPostRequest) Body(body map[string]interface{}) ApiIndicesPutAliasPostRequest {
	r.body = &body
	return r
}

func (r ApiIndicesPutAliasPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutAliasPostExecute(r)
}

/*
IndicesPutAliasPost Method for IndicesPutAliasPost

Creates or updates an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param name The name of the alias to be created or updated.
 @return ApiIndicesPutAliasPostRequest
*/
func (a *DefaultAPIService) IndicesPutAliasPost(ctx context.Context, index string, name string) ApiIndicesPutAliasPostRequest {
	return ApiIndicesPutAliasPostRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutAliasPostExecute(r ApiIndicesPutAliasPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutAliasPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_alias/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesPutAliasPostPluralRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	body *map[string]interface{}
}

// Operation timeout.
func (r ApiIndicesPutAliasPostPluralRequest) Timeout(timeout string) ApiIndicesPutAliasPostPluralRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesPutAliasPostPluralRequest) MasterTimeout(masterTimeout string) ApiIndicesPutAliasPostPluralRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesPutAliasPostPluralRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesPutAliasPostPluralRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesPutAliasPostPluralRequest) Body(body map[string]interface{}) ApiIndicesPutAliasPostPluralRequest {
	r.body = &body
	return r
}

func (r ApiIndicesPutAliasPostPluralRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutAliasPostPluralExecute(r)
}

/*
IndicesPutAliasPostPlural Method for IndicesPutAliasPostPlural

Creates or updates an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param name The name of the alias to be created or updated.
 @return ApiIndicesPutAliasPostPluralRequest
*/
func (a *DefaultAPIService) IndicesPutAliasPostPlural(ctx context.Context, index string, name string) ApiIndicesPutAliasPostPluralRequest {
	return ApiIndicesPutAliasPostPluralRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutAliasPostPluralExecute(r ApiIndicesPutAliasPostPluralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutAliasPostPlural")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_aliases/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesPutAliasPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	body *map[string]interface{}
}

// Operation timeout.
func (r ApiIndicesPutAliasPutRequest) Timeout(timeout string) ApiIndicesPutAliasPutRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesPutAliasPutRequest) MasterTimeout(masterTimeout string) ApiIndicesPutAliasPutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesPutAliasPutRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesPutAliasPutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesPutAliasPutRequest) Body(body map[string]interface{}) ApiIndicesPutAliasPutRequest {
	r.body = &body
	return r
}

func (r ApiIndicesPutAliasPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutAliasPutExecute(r)
}

/*
IndicesPutAliasPut Method for IndicesPutAliasPut

Creates or updates an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param name The name of the alias to be created or updated.
 @return ApiIndicesPutAliasPutRequest
*/
func (a *DefaultAPIService) IndicesPutAliasPut(ctx context.Context, index string, name string) ApiIndicesPutAliasPutRequest {
	return ApiIndicesPutAliasPutRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutAliasPutExecute(r ApiIndicesPutAliasPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutAliasPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_alias/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesPutAliasPutPluralRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	body *map[string]interface{}
}

// Operation timeout.
func (r ApiIndicesPutAliasPutPluralRequest) Timeout(timeout string) ApiIndicesPutAliasPutPluralRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesPutAliasPutPluralRequest) MasterTimeout(masterTimeout string) ApiIndicesPutAliasPutPluralRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesPutAliasPutPluralRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesPutAliasPutPluralRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesPutAliasPutPluralRequest) Body(body map[string]interface{}) ApiIndicesPutAliasPutPluralRequest {
	r.body = &body
	return r
}

func (r ApiIndicesPutAliasPutPluralRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutAliasPutPluralExecute(r)
}

/*
IndicesPutAliasPutPlural Method for IndicesPutAliasPutPlural

Creates or updates an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param name The name of the alias to be created or updated.
 @return ApiIndicesPutAliasPutPluralRequest
*/
func (a *DefaultAPIService) IndicesPutAliasPutPlural(ctx context.Context, index string, name string) ApiIndicesPutAliasPutPluralRequest {
	return ApiIndicesPutAliasPutPluralRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutAliasPutPluralExecute(r ApiIndicesPutAliasPutPluralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutAliasPutPlural")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_aliases/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesPutIndexTemplatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	body *map[string]interface{}
	create *bool
	cause *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r ApiIndicesPutIndexTemplatePostRequest) Body(body map[string]interface{}) ApiIndicesPutIndexTemplatePostRequest {
	r.body = &body
	return r
}

// Whether the index template should only be added if new or can also replace an existing one.
func (r ApiIndicesPutIndexTemplatePostRequest) Create(create bool) ApiIndicesPutIndexTemplatePostRequest {
	r.create = &create
	return r
}

// User defined reason for creating/updating the index template.
func (r ApiIndicesPutIndexTemplatePostRequest) Cause(cause string) ApiIndicesPutIndexTemplatePostRequest {
	r.cause = &cause
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesPutIndexTemplatePostRequest) MasterTimeout(masterTimeout string) ApiIndicesPutIndexTemplatePostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesPutIndexTemplatePostRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesPutIndexTemplatePostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesPutIndexTemplatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutIndexTemplatePostExecute(r)
}

/*
IndicesPutIndexTemplatePost Method for IndicesPutIndexTemplatePost

Creates or updates an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return ApiIndicesPutIndexTemplatePostRequest
*/
func (a *DefaultAPIService) IndicesPutIndexTemplatePost(ctx context.Context, name string) ApiIndicesPutIndexTemplatePostRequest {
	return ApiIndicesPutIndexTemplatePostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutIndexTemplatePostExecute(r ApiIndicesPutIndexTemplatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutIndexTemplatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.cause != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cause", r.cause, "")
	} else {
		var defaultValue string = "false"
		r.cause = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesPutIndexTemplatePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	body *map[string]interface{}
	create *bool
	cause *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r ApiIndicesPutIndexTemplatePutRequest) Body(body map[string]interface{}) ApiIndicesPutIndexTemplatePutRequest {
	r.body = &body
	return r
}

// Whether the index template should only be added if new or can also replace an existing one.
func (r ApiIndicesPutIndexTemplatePutRequest) Create(create bool) ApiIndicesPutIndexTemplatePutRequest {
	r.create = &create
	return r
}

// User defined reason for creating/updating the index template.
func (r ApiIndicesPutIndexTemplatePutRequest) Cause(cause string) ApiIndicesPutIndexTemplatePutRequest {
	r.cause = &cause
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesPutIndexTemplatePutRequest) MasterTimeout(masterTimeout string) ApiIndicesPutIndexTemplatePutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesPutIndexTemplatePutRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesPutIndexTemplatePutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesPutIndexTemplatePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutIndexTemplatePutExecute(r)
}

/*
IndicesPutIndexTemplatePut Method for IndicesPutIndexTemplatePut

Creates or updates an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return ApiIndicesPutIndexTemplatePutRequest
*/
func (a *DefaultAPIService) IndicesPutIndexTemplatePut(ctx context.Context, name string) ApiIndicesPutIndexTemplatePutRequest {
	return ApiIndicesPutIndexTemplatePutRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutIndexTemplatePutExecute(r ApiIndicesPutIndexTemplatePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutIndexTemplatePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.cause != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cause", r.cause, "")
	} else {
		var defaultValue string = "false"
		r.cause = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesPutMappingPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	writeIndexOnly *bool
}

func (r ApiIndicesPutMappingPostRequest) Body(body map[string]interface{}) ApiIndicesPutMappingPostRequest {
	r.body = &body
	return r
}

// Operation timeout.
func (r ApiIndicesPutMappingPostRequest) Timeout(timeout string) ApiIndicesPutMappingPostRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesPutMappingPostRequest) MasterTimeout(masterTimeout string) ApiIndicesPutMappingPostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesPutMappingPostRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesPutMappingPostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesPutMappingPostRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesPutMappingPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesPutMappingPostRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesPutMappingPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesPutMappingPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesPutMappingPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// When true, applies mappings only to the write index of an alias or data stream.
func (r ApiIndicesPutMappingPostRequest) WriteIndexOnly(writeIndexOnly bool) ApiIndicesPutMappingPostRequest {
	r.writeIndexOnly = &writeIndexOnly
	return r
}

func (r ApiIndicesPutMappingPostRequest) Execute() (*IndicesPutMappingPostResponseContent, *http.Response, error) {
	return r.ApiService.IndicesPutMappingPostExecute(r)
}

/*
IndicesPutMappingPost Method for IndicesPutMappingPost

Updates the index mappings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesPutMappingPostRequest
*/
func (a *DefaultAPIService) IndicesPutMappingPost(ctx context.Context, index string) ApiIndicesPutMappingPostRequest {
	return ApiIndicesPutMappingPostRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
//  @return IndicesPutMappingPostResponseContent
func (a *DefaultAPIService) IndicesPutMappingPostExecute(r ApiIndicesPutMappingPostRequest) (*IndicesPutMappingPostResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesPutMappingPostResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutMappingPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mapping"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.writeIndexOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "write_index_only", r.writeIndexOnly, "")
	} else {
		var defaultValue bool = false
		r.writeIndexOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndicesPutMappingPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	writeIndexOnly *bool
}

func (r ApiIndicesPutMappingPutRequest) Body(body map[string]interface{}) ApiIndicesPutMappingPutRequest {
	r.body = &body
	return r
}

// Operation timeout.
func (r ApiIndicesPutMappingPutRequest) Timeout(timeout string) ApiIndicesPutMappingPutRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesPutMappingPutRequest) MasterTimeout(masterTimeout string) ApiIndicesPutMappingPutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesPutMappingPutRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesPutMappingPutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesPutMappingPutRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesPutMappingPutRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesPutMappingPutRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesPutMappingPutRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesPutMappingPutRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesPutMappingPutRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// When true, applies mappings only to the write index of an alias or data stream.
func (r ApiIndicesPutMappingPutRequest) WriteIndexOnly(writeIndexOnly bool) ApiIndicesPutMappingPutRequest {
	r.writeIndexOnly = &writeIndexOnly
	return r
}

func (r ApiIndicesPutMappingPutRequest) Execute() (*IndicesPutMappingPutResponseContent, *http.Response, error) {
	return r.ApiService.IndicesPutMappingPutExecute(r)
}

/*
IndicesPutMappingPut Method for IndicesPutMappingPut

Updates the index mappings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesPutMappingPutRequest
*/
func (a *DefaultAPIService) IndicesPutMappingPut(ctx context.Context, index string) ApiIndicesPutMappingPutRequest {
	return ApiIndicesPutMappingPutRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
//  @return IndicesPutMappingPutResponseContent
func (a *DefaultAPIService) IndicesPutMappingPutExecute(r ApiIndicesPutMappingPutRequest) (*IndicesPutMappingPutResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesPutMappingPutResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutMappingPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mapping"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.writeIndexOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "write_index_only", r.writeIndexOnly, "")
	} else {
		var defaultValue bool = false
		r.writeIndexOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndicesPutSettingsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	preserveExisting *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
}

func (r ApiIndicesPutSettingsRequest) Body(body map[string]interface{}) ApiIndicesPutSettingsRequest {
	r.body = &body
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesPutSettingsRequest) MasterTimeout(masterTimeout string) ApiIndicesPutSettingsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesPutSettingsRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesPutSettingsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r ApiIndicesPutSettingsRequest) Timeout(timeout string) ApiIndicesPutSettingsRequest {
	r.timeout = &timeout
	return r
}

// Whether to update existing settings. If set to &#x60;true&#x60; existing settings on an index remain unchanged.
func (r ApiIndicesPutSettingsRequest) PreserveExisting(preserveExisting bool) ApiIndicesPutSettingsRequest {
	r.preserveExisting = &preserveExisting
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesPutSettingsRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesPutSettingsRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesPutSettingsRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesPutSettingsRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesPutSettingsRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesPutSettingsRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r ApiIndicesPutSettingsRequest) FlatSettings(flatSettings bool) ApiIndicesPutSettingsRequest {
	r.flatSettings = &flatSettings
	return r
}

func (r ApiIndicesPutSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutSettingsExecute(r)
}

/*
IndicesPutSettings Method for IndicesPutSettings

Updates the index settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesPutSettingsRequest
*/
func (a *DefaultAPIService) IndicesPutSettings(ctx context.Context) ApiIndicesPutSettingsRequest {
	return ApiIndicesPutSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutSettingsExecute(r ApiIndicesPutSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.preserveExisting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preserve_existing", r.preserveExisting, "")
	} else {
		var defaultValue bool = false
		r.preserveExisting = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesPutSettingsWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	preserveExisting *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
}

func (r ApiIndicesPutSettingsWithIndexRequest) Body(body map[string]interface{}) ApiIndicesPutSettingsWithIndexRequest {
	r.body = &body
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesPutSettingsWithIndexRequest) MasterTimeout(masterTimeout string) ApiIndicesPutSettingsWithIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesPutSettingsWithIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesPutSettingsWithIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r ApiIndicesPutSettingsWithIndexRequest) Timeout(timeout string) ApiIndicesPutSettingsWithIndexRequest {
	r.timeout = &timeout
	return r
}

// Whether to update existing settings. If set to &#x60;true&#x60; existing settings on an index remain unchanged.
func (r ApiIndicesPutSettingsWithIndexRequest) PreserveExisting(preserveExisting bool) ApiIndicesPutSettingsWithIndexRequest {
	r.preserveExisting = &preserveExisting
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesPutSettingsWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesPutSettingsWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesPutSettingsWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesPutSettingsWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesPutSettingsWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesPutSettingsWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r ApiIndicesPutSettingsWithIndexRequest) FlatSettings(flatSettings bool) ApiIndicesPutSettingsWithIndexRequest {
	r.flatSettings = &flatSettings
	return r
}

func (r ApiIndicesPutSettingsWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutSettingsWithIndexExecute(r)
}

/*
IndicesPutSettingsWithIndex Method for IndicesPutSettingsWithIndex

Updates the index settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesPutSettingsWithIndexRequest
*/
func (a *DefaultAPIService) IndicesPutSettingsWithIndex(ctx context.Context, index string) ApiIndicesPutSettingsWithIndexRequest {
	return ApiIndicesPutSettingsWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutSettingsWithIndexExecute(r ApiIndicesPutSettingsWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutSettingsWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_settings"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.preserveExisting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preserve_existing", r.preserveExisting, "")
	} else {
		var defaultValue bool = false
		r.preserveExisting = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesPutTemplatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	body *map[string]interface{}
	order *int32
	create *bool
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r ApiIndicesPutTemplatePostRequest) Body(body map[string]interface{}) ApiIndicesPutTemplatePostRequest {
	r.body = &body
	return r
}

// The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers).
func (r ApiIndicesPutTemplatePostRequest) Order(order int32) ApiIndicesPutTemplatePostRequest {
	r.order = &order
	return r
}

// Whether the index template should only be added if new or can also replace an existing one.
func (r ApiIndicesPutTemplatePostRequest) Create(create bool) ApiIndicesPutTemplatePostRequest {
	r.create = &create
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesPutTemplatePostRequest) MasterTimeout(masterTimeout string) ApiIndicesPutTemplatePostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesPutTemplatePostRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesPutTemplatePostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesPutTemplatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutTemplatePostExecute(r)
}

/*
IndicesPutTemplatePost Method for IndicesPutTemplatePost

Creates or updates an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return ApiIndicesPutTemplatePostRequest
*/
func (a *DefaultAPIService) IndicesPutTemplatePost(ctx context.Context, name string) ApiIndicesPutTemplatePostRequest {
	return ApiIndicesPutTemplatePostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutTemplatePostExecute(r ApiIndicesPutTemplatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutTemplatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesPutTemplatePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	body *map[string]interface{}
	order *int32
	create *bool
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r ApiIndicesPutTemplatePutRequest) Body(body map[string]interface{}) ApiIndicesPutTemplatePutRequest {
	r.body = &body
	return r
}

// The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers).
func (r ApiIndicesPutTemplatePutRequest) Order(order int32) ApiIndicesPutTemplatePutRequest {
	r.order = &order
	return r
}

// Whether the index template should only be added if new or can also replace an existing one.
func (r ApiIndicesPutTemplatePutRequest) Create(create bool) ApiIndicesPutTemplatePutRequest {
	r.create = &create
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesPutTemplatePutRequest) MasterTimeout(masterTimeout string) ApiIndicesPutTemplatePutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesPutTemplatePutRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesPutTemplatePutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesPutTemplatePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutTemplatePutExecute(r)
}

/*
IndicesPutTemplatePut Method for IndicesPutTemplatePut

Creates or updates an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return ApiIndicesPutTemplatePutRequest
*/
func (a *DefaultAPIService) IndicesPutTemplatePut(ctx context.Context, name string) ApiIndicesPutTemplatePutRequest {
	return ApiIndicesPutTemplatePutRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutTemplatePutExecute(r ApiIndicesPutTemplatePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutTemplatePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesRecoveryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	detailed *bool
	activeOnly *bool
}

// Whether to display detailed information about shard recovery.
func (r ApiIndicesRecoveryRequest) Detailed(detailed bool) ApiIndicesRecoveryRequest {
	r.detailed = &detailed
	return r
}

// Display only those recoveries that are currently on-going.
func (r ApiIndicesRecoveryRequest) ActiveOnly(activeOnly bool) ApiIndicesRecoveryRequest {
	r.activeOnly = &activeOnly
	return r
}

func (r ApiIndicesRecoveryRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRecoveryExecute(r)
}

/*
IndicesRecovery Method for IndicesRecovery

Returns information about ongoing index shard recoveries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesRecoveryRequest
*/
func (a *DefaultAPIService) IndicesRecovery(ctx context.Context) ApiIndicesRecoveryRequest {
	return ApiIndicesRecoveryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRecoveryExecute(r ApiIndicesRecoveryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRecovery")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_recovery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_only", r.activeOnly, "")
	} else {
		var defaultValue bool = false
		r.activeOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesRecoveryWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	detailed *bool
	activeOnly *bool
}

// Whether to display detailed information about shard recovery.
func (r ApiIndicesRecoveryWithIndexRequest) Detailed(detailed bool) ApiIndicesRecoveryWithIndexRequest {
	r.detailed = &detailed
	return r
}

// Display only those recoveries that are currently on-going.
func (r ApiIndicesRecoveryWithIndexRequest) ActiveOnly(activeOnly bool) ApiIndicesRecoveryWithIndexRequest {
	r.activeOnly = &activeOnly
	return r
}

func (r ApiIndicesRecoveryWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRecoveryWithIndexExecute(r)
}

/*
IndicesRecoveryWithIndex Method for IndicesRecoveryWithIndex

Returns information about ongoing index shard recoveries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesRecoveryWithIndexRequest
*/
func (a *DefaultAPIService) IndicesRecoveryWithIndex(ctx context.Context, index string) ApiIndicesRecoveryWithIndexRequest {
	return ApiIndicesRecoveryWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRecoveryWithIndexExecute(r ApiIndicesRecoveryWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRecoveryWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_recovery"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_only", r.activeOnly, "")
	} else {
		var defaultValue bool = false
		r.activeOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesRefreshGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesRefreshGetRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesRefreshGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesRefreshGetRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesRefreshGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesRefreshGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesRefreshGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesRefreshGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRefreshGetExecute(r)
}

/*
IndicesRefreshGet Method for IndicesRefreshGet

Performs the refresh operation in one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesRefreshGetRequest
*/
func (a *DefaultAPIService) IndicesRefreshGet(ctx context.Context) ApiIndicesRefreshGetRequest {
	return ApiIndicesRefreshGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRefreshGetExecute(r ApiIndicesRefreshGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRefreshGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesRefreshGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesRefreshGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesRefreshGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesRefreshGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesRefreshGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesRefreshGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesRefreshGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesRefreshGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRefreshGetWithIndexExecute(r)
}

/*
IndicesRefreshGetWithIndex Method for IndicesRefreshGetWithIndex

Performs the refresh operation in one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesRefreshGetWithIndexRequest
*/
func (a *DefaultAPIService) IndicesRefreshGetWithIndex(ctx context.Context, index string) ApiIndicesRefreshGetWithIndexRequest {
	return ApiIndicesRefreshGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRefreshGetWithIndexExecute(r ApiIndicesRefreshGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRefreshGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_refresh"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesRefreshPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesRefreshPostRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesRefreshPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesRefreshPostRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesRefreshPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesRefreshPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesRefreshPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesRefreshPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRefreshPostExecute(r)
}

/*
IndicesRefreshPost Method for IndicesRefreshPost

Performs the refresh operation in one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesRefreshPostRequest
*/
func (a *DefaultAPIService) IndicesRefreshPost(ctx context.Context) ApiIndicesRefreshPostRequest {
	return ApiIndicesRefreshPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRefreshPostExecute(r ApiIndicesRefreshPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRefreshPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesRefreshPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesRefreshPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesRefreshPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesRefreshPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesRefreshPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesRefreshPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesRefreshPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesRefreshPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRefreshPostWithIndexExecute(r)
}

/*
IndicesRefreshPostWithIndex Method for IndicesRefreshPostWithIndex

Performs the refresh operation in one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesRefreshPostWithIndexRequest
*/
func (a *DefaultAPIService) IndicesRefreshPostWithIndex(ctx context.Context, index string) ApiIndicesRefreshPostWithIndexRequest {
	return ApiIndicesRefreshPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRefreshPostWithIndexExecute(r ApiIndicesRefreshPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRefreshPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_refresh"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesResolveIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	expandWildcards *ExpandWildcards
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesResolveIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesResolveIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesResolveIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesResolveIndexExecute(r)
}

/*
IndicesResolveIndex Method for IndicesResolveIndex

Returns information about any matching indices, aliases, and data streams.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of names or wildcard expressions.
 @return ApiIndicesResolveIndexRequest
*/
func (a *DefaultAPIService) IndicesResolveIndex(ctx context.Context, name string) ApiIndicesResolveIndexRequest {
	return ApiIndicesResolveIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesResolveIndexExecute(r ApiIndicesResolveIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesResolveIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_resolve/index/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesRolloverRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	alias string
	timeout *string
	dryRun *bool
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// Operation timeout.
func (r ApiIndicesRolloverRequest) Timeout(timeout string) ApiIndicesRolloverRequest {
	r.timeout = &timeout
	return r
}

// If set to true the rollover action will only be validated but not actually performed even if a condition matches.
func (r ApiIndicesRolloverRequest) DryRun(dryRun bool) ApiIndicesRolloverRequest {
	r.dryRun = &dryRun
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesRolloverRequest) MasterTimeout(masterTimeout string) ApiIndicesRolloverRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesRolloverRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesRolloverRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the newly created rollover index before the operation returns.
func (r ApiIndicesRolloverRequest) WaitForActiveShards(waitForActiveShards string) ApiIndicesRolloverRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r ApiIndicesRolloverRequest) Body(body map[string]interface{}) ApiIndicesRolloverRequest {
	r.body = &body
	return r
}

func (r ApiIndicesRolloverRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRolloverExecute(r)
}

/*
IndicesRollover Method for IndicesRollover

Updates an alias to point to a new index when the existing index
is considered to be too large or too old.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alias The name of the alias to rollover.
 @return ApiIndicesRolloverRequest
*/
func (a *DefaultAPIService) IndicesRollover(ctx context.Context, alias string) ApiIndicesRolloverRequest {
	return ApiIndicesRolloverRequest{
		ApiService: a,
		ctx: ctx,
		alias: alias,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRolloverExecute(r ApiIndicesRolloverRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRollover")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{alias}/_rollover"
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dry_run", r.dryRun, "")
	} else {
		var defaultValue bool = false
		r.dryRun = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesRolloverWithNewIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	alias string
	newIndex string
	timeout *string
	dryRun *bool
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// Operation timeout.
func (r ApiIndicesRolloverWithNewIndexRequest) Timeout(timeout string) ApiIndicesRolloverWithNewIndexRequest {
	r.timeout = &timeout
	return r
}

// If set to true the rollover action will only be validated but not actually performed even if a condition matches.
func (r ApiIndicesRolloverWithNewIndexRequest) DryRun(dryRun bool) ApiIndicesRolloverWithNewIndexRequest {
	r.dryRun = &dryRun
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesRolloverWithNewIndexRequest) MasterTimeout(masterTimeout string) ApiIndicesRolloverWithNewIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesRolloverWithNewIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesRolloverWithNewIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the newly created rollover index before the operation returns.
func (r ApiIndicesRolloverWithNewIndexRequest) WaitForActiveShards(waitForActiveShards string) ApiIndicesRolloverWithNewIndexRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r ApiIndicesRolloverWithNewIndexRequest) Body(body map[string]interface{}) ApiIndicesRolloverWithNewIndexRequest {
	r.body = &body
	return r
}

func (r ApiIndicesRolloverWithNewIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRolloverWithNewIndexExecute(r)
}

/*
IndicesRolloverWithNewIndex Method for IndicesRolloverWithNewIndex

Updates an alias to point to a new index when the existing index
is considered to be too large or too old.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alias The name of the alias to rollover.
 @param newIndex The name of the rollover index.
 @return ApiIndicesRolloverWithNewIndexRequest
*/
func (a *DefaultAPIService) IndicesRolloverWithNewIndex(ctx context.Context, alias string, newIndex string) ApiIndicesRolloverWithNewIndexRequest {
	return ApiIndicesRolloverWithNewIndexRequest{
		ApiService: a,
		ctx: ctx,
		alias: alias,
		newIndex: newIndex,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRolloverWithNewIndexExecute(r ApiIndicesRolloverWithNewIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRolloverWithNewIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{alias}/_rollover/{new_index}"
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"new_index"+"}", url.PathEscape(parameterValueToString(r.newIndex, "newIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dry_run", r.dryRun, "")
	} else {
		var defaultValue bool = false
		r.dryRun = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesSegmentsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	verbose *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesSegmentsRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesSegmentsRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesSegmentsRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesSegmentsRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesSegmentsRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesSegmentsRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Includes detailed memory usage by Lucene.
func (r ApiIndicesSegmentsRequest) Verbose(verbose bool) ApiIndicesSegmentsRequest {
	r.verbose = &verbose
	return r
}

func (r ApiIndicesSegmentsRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesSegmentsExecute(r)
}

/*
IndicesSegments Method for IndicesSegments

Provides low-level information about segments in a Lucene index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesSegmentsRequest
*/
func (a *DefaultAPIService) IndicesSegments(ctx context.Context) ApiIndicesSegmentsRequest {
	return ApiIndicesSegmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesSegmentsExecute(r ApiIndicesSegmentsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesSegments")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesSegmentsWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	verbose *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesSegmentsWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesSegmentsWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesSegmentsWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesSegmentsWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesSegmentsWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesSegmentsWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Includes detailed memory usage by Lucene.
func (r ApiIndicesSegmentsWithIndexRequest) Verbose(verbose bool) ApiIndicesSegmentsWithIndexRequest {
	r.verbose = &verbose
	return r
}

func (r ApiIndicesSegmentsWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesSegmentsWithIndexExecute(r)
}

/*
IndicesSegmentsWithIndex Method for IndicesSegmentsWithIndex

Provides low-level information about segments in a Lucene index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesSegmentsWithIndexRequest
*/
func (a *DefaultAPIService) IndicesSegmentsWithIndex(ctx context.Context, index string) ApiIndicesSegmentsWithIndexRequest {
	return ApiIndicesSegmentsWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesSegmentsWithIndexExecute(r ApiIndicesSegmentsWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesSegmentsWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_segments"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesShardStoresRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	status *[]StatusMember
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Comma-separated list of statuses used to filter on shards to get store information for.
func (r ApiIndicesShardStoresRequest) Status(status []StatusMember) ApiIndicesShardStoresRequest {
	r.status = &status
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesShardStoresRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesShardStoresRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesShardStoresRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesShardStoresRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesShardStoresRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesShardStoresRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesShardStoresRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesShardStoresExecute(r)
}

/*
IndicesShardStores Method for IndicesShardStores

Provides store information for shard copies of indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesShardStoresRequest
*/
func (a *DefaultAPIService) IndicesShardStores(ctx context.Context) ApiIndicesShardStoresRequest {
	return ApiIndicesShardStoresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesShardStoresExecute(r ApiIndicesShardStoresRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesShardStores")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_shard_stores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesShardStoresWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	status *[]StatusMember
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Comma-separated list of statuses used to filter on shards to get store information for.
func (r ApiIndicesShardStoresWithIndexRequest) Status(status []StatusMember) ApiIndicesShardStoresWithIndexRequest {
	r.status = &status
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesShardStoresWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesShardStoresWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesShardStoresWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesShardStoresWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesShardStoresWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesShardStoresWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiIndicesShardStoresWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesShardStoresWithIndexExecute(r)
}

/*
IndicesShardStoresWithIndex Method for IndicesShardStoresWithIndex

Provides store information for shard copies of indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesShardStoresWithIndexRequest
*/
func (a *DefaultAPIService) IndicesShardStoresWithIndex(ctx context.Context, index string) ApiIndicesShardStoresWithIndexRequest {
	return ApiIndicesShardStoresWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesShardStoresWithIndexExecute(r ApiIndicesShardStoresWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesShardStoresWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_shard_stores"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesShrinkPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	target string
	copySettings *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// whether or not to copy settings from the source index.
func (r ApiIndicesShrinkPostRequest) CopySettings(copySettings bool) ApiIndicesShrinkPostRequest {
	r.copySettings = &copySettings
	return r
}

// Operation timeout.
func (r ApiIndicesShrinkPostRequest) Timeout(timeout string) ApiIndicesShrinkPostRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesShrinkPostRequest) MasterTimeout(masterTimeout string) ApiIndicesShrinkPostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesShrinkPostRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesShrinkPostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the shrunken index before the operation returns.
func (r ApiIndicesShrinkPostRequest) WaitForActiveShards(waitForActiveShards string) ApiIndicesShrinkPostRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r ApiIndicesShrinkPostRequest) Body(body map[string]interface{}) ApiIndicesShrinkPostRequest {
	r.body = &body
	return r
}

func (r ApiIndicesShrinkPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesShrinkPostExecute(r)
}

/*
IndicesShrinkPost Method for IndicesShrinkPost

Allow to shrink an existing index into a new index with fewer primary shards.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the source index to shrink.
 @param target The name of the target index.
 @return ApiIndicesShrinkPostRequest
*/
func (a *DefaultAPIService) IndicesShrinkPost(ctx context.Context, index string, target string) ApiIndicesShrinkPostRequest {
	return ApiIndicesShrinkPostRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		target: target,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesShrinkPostExecute(r ApiIndicesShrinkPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesShrinkPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_shrink/{target}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", url.PathEscape(parameterValueToString(r.target, "target")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.copySettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copy_settings", r.copySettings, "")
	} else {
		var defaultValue bool = false
		r.copySettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesShrinkPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	target string
	copySettings *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// whether or not to copy settings from the source index.
func (r ApiIndicesShrinkPutRequest) CopySettings(copySettings bool) ApiIndicesShrinkPutRequest {
	r.copySettings = &copySettings
	return r
}

// Operation timeout.
func (r ApiIndicesShrinkPutRequest) Timeout(timeout string) ApiIndicesShrinkPutRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesShrinkPutRequest) MasterTimeout(masterTimeout string) ApiIndicesShrinkPutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesShrinkPutRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesShrinkPutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the shrunken index before the operation returns.
func (r ApiIndicesShrinkPutRequest) WaitForActiveShards(waitForActiveShards string) ApiIndicesShrinkPutRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r ApiIndicesShrinkPutRequest) Body(body map[string]interface{}) ApiIndicesShrinkPutRequest {
	r.body = &body
	return r
}

func (r ApiIndicesShrinkPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesShrinkPutExecute(r)
}

/*
IndicesShrinkPut Method for IndicesShrinkPut

Allow to shrink an existing index into a new index with fewer primary shards.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the source index to shrink.
 @param target The name of the target index.
 @return ApiIndicesShrinkPutRequest
*/
func (a *DefaultAPIService) IndicesShrinkPut(ctx context.Context, index string, target string) ApiIndicesShrinkPutRequest {
	return ApiIndicesShrinkPutRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		target: target,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesShrinkPutExecute(r ApiIndicesShrinkPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesShrinkPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_shrink/{target}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", url.PathEscape(parameterValueToString(r.target, "target")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.copySettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copy_settings", r.copySettings, "")
	} else {
		var defaultValue bool = false
		r.copySettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesSimulateIndexTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	create *bool
	cause *string
	masterTimeout *string
	clusterManagerTimeout *string
	body *map[string]interface{}
}

// Whether the index template we optionally defined in the body should only be dry-run added if new or can also replace an existing one.
func (r ApiIndicesSimulateIndexTemplateRequest) Create(create bool) ApiIndicesSimulateIndexTemplateRequest {
	r.create = &create
	return r
}

// User defined reason for dry-run creating the new template for simulation purposes.
func (r ApiIndicesSimulateIndexTemplateRequest) Cause(cause string) ApiIndicesSimulateIndexTemplateRequest {
	r.cause = &cause
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesSimulateIndexTemplateRequest) MasterTimeout(masterTimeout string) ApiIndicesSimulateIndexTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesSimulateIndexTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesSimulateIndexTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesSimulateIndexTemplateRequest) Body(body map[string]interface{}) ApiIndicesSimulateIndexTemplateRequest {
	r.body = &body
	return r
}

func (r ApiIndicesSimulateIndexTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesSimulateIndexTemplateExecute(r)
}

/*
IndicesSimulateIndexTemplate Method for IndicesSimulateIndexTemplate

Simulate matching the given index name against the index templates in the system.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the index (it must be a concrete index name).
 @return ApiIndicesSimulateIndexTemplateRequest
*/
func (a *DefaultAPIService) IndicesSimulateIndexTemplate(ctx context.Context, name string) ApiIndicesSimulateIndexTemplateRequest {
	return ApiIndicesSimulateIndexTemplateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesSimulateIndexTemplateExecute(r ApiIndicesSimulateIndexTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesSimulateIndexTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/_simulate_index/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.cause != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cause", r.cause, "")
	} else {
		var defaultValue string = "false"
		r.cause = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesSimulateTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	create *bool
	cause *string
	masterTimeout *string
	clusterManagerTimeout *string
	body *map[string]interface{}
}

// Whether the index template we optionally defined in the body should only be dry-run added if new or can also replace an existing one.
func (r ApiIndicesSimulateTemplateRequest) Create(create bool) ApiIndicesSimulateTemplateRequest {
	r.create = &create
	return r
}

// User defined reason for dry-run creating the new template for simulation purposes.
func (r ApiIndicesSimulateTemplateRequest) Cause(cause string) ApiIndicesSimulateTemplateRequest {
	r.cause = &cause
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesSimulateTemplateRequest) MasterTimeout(masterTimeout string) ApiIndicesSimulateTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesSimulateTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesSimulateTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesSimulateTemplateRequest) Body(body map[string]interface{}) ApiIndicesSimulateTemplateRequest {
	r.body = &body
	return r
}

func (r ApiIndicesSimulateTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesSimulateTemplateExecute(r)
}

/*
IndicesSimulateTemplate Method for IndicesSimulateTemplate

Simulate resolving the given template name or body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesSimulateTemplateRequest
*/
func (a *DefaultAPIService) IndicesSimulateTemplate(ctx context.Context) ApiIndicesSimulateTemplateRequest {
	return ApiIndicesSimulateTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesSimulateTemplateExecute(r ApiIndicesSimulateTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesSimulateTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/_simulate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.cause != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cause", r.cause, "")
	} else {
		var defaultValue string = "false"
		r.cause = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesSimulateTemplateWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	create *bool
	cause *string
	masterTimeout *string
	clusterManagerTimeout *string
	body *map[string]interface{}
}

// Whether the index template we optionally defined in the body should only be dry-run added if new or can also replace an existing one.
func (r ApiIndicesSimulateTemplateWithNameRequest) Create(create bool) ApiIndicesSimulateTemplateWithNameRequest {
	r.create = &create
	return r
}

// User defined reason for dry-run creating the new template for simulation purposes.
func (r ApiIndicesSimulateTemplateWithNameRequest) Cause(cause string) ApiIndicesSimulateTemplateWithNameRequest {
	r.cause = &cause
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesSimulateTemplateWithNameRequest) MasterTimeout(masterTimeout string) ApiIndicesSimulateTemplateWithNameRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesSimulateTemplateWithNameRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesSimulateTemplateWithNameRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesSimulateTemplateWithNameRequest) Body(body map[string]interface{}) ApiIndicesSimulateTemplateWithNameRequest {
	r.body = &body
	return r
}

func (r ApiIndicesSimulateTemplateWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesSimulateTemplateWithNameExecute(r)
}

/*
IndicesSimulateTemplateWithName Method for IndicesSimulateTemplateWithName

Simulate resolving the given template name or body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return ApiIndicesSimulateTemplateWithNameRequest
*/
func (a *DefaultAPIService) IndicesSimulateTemplateWithName(ctx context.Context, name string) ApiIndicesSimulateTemplateWithNameRequest {
	return ApiIndicesSimulateTemplateWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesSimulateTemplateWithNameExecute(r ApiIndicesSimulateTemplateWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesSimulateTemplateWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/_simulate/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.cause != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cause", r.cause, "")
	} else {
		var defaultValue string = "false"
		r.cause = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesSplitPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	target string
	copySettings *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// whether or not to copy settings from the source index.
func (r ApiIndicesSplitPostRequest) CopySettings(copySettings bool) ApiIndicesSplitPostRequest {
	r.copySettings = &copySettings
	return r
}

// Operation timeout.
func (r ApiIndicesSplitPostRequest) Timeout(timeout string) ApiIndicesSplitPostRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesSplitPostRequest) MasterTimeout(masterTimeout string) ApiIndicesSplitPostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesSplitPostRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesSplitPostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the shrunken index before the operation returns.
func (r ApiIndicesSplitPostRequest) WaitForActiveShards(waitForActiveShards string) ApiIndicesSplitPostRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r ApiIndicesSplitPostRequest) Body(body map[string]interface{}) ApiIndicesSplitPostRequest {
	r.body = &body
	return r
}

func (r ApiIndicesSplitPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesSplitPostExecute(r)
}

/*
IndicesSplitPost Method for IndicesSplitPost

Allows you to split an existing index into a new index with more primary shards.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the source index to split.
 @param target The name of the target index.
 @return ApiIndicesSplitPostRequest
*/
func (a *DefaultAPIService) IndicesSplitPost(ctx context.Context, index string, target string) ApiIndicesSplitPostRequest {
	return ApiIndicesSplitPostRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		target: target,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesSplitPostExecute(r ApiIndicesSplitPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesSplitPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_split/{target}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", url.PathEscape(parameterValueToString(r.target, "target")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.copySettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copy_settings", r.copySettings, "")
	} else {
		var defaultValue bool = false
		r.copySettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesSplitPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	target string
	copySettings *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// whether or not to copy settings from the source index.
func (r ApiIndicesSplitPutRequest) CopySettings(copySettings bool) ApiIndicesSplitPutRequest {
	r.copySettings = &copySettings
	return r
}

// Operation timeout.
func (r ApiIndicesSplitPutRequest) Timeout(timeout string) ApiIndicesSplitPutRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesSplitPutRequest) MasterTimeout(masterTimeout string) ApiIndicesSplitPutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesSplitPutRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesSplitPutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the shrunken index before the operation returns.
func (r ApiIndicesSplitPutRequest) WaitForActiveShards(waitForActiveShards string) ApiIndicesSplitPutRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r ApiIndicesSplitPutRequest) Body(body map[string]interface{}) ApiIndicesSplitPutRequest {
	r.body = &body
	return r
}

func (r ApiIndicesSplitPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesSplitPutExecute(r)
}

/*
IndicesSplitPut Method for IndicesSplitPut

Allows you to split an existing index into a new index with more primary shards.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the source index to split.
 @param target The name of the target index.
 @return ApiIndicesSplitPutRequest
*/
func (a *DefaultAPIService) IndicesSplitPut(ctx context.Context, index string, target string) ApiIndicesSplitPutRequest {
	return ApiIndicesSplitPutRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		target: target,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesSplitPutExecute(r ApiIndicesSplitPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesSplitPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_split/{target}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", url.PathEscape(parameterValueToString(r.target, "target")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.copySettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copy_settings", r.copySettings, "")
	} else {
		var defaultValue bool = false
		r.copySettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesStatsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *IndiciesStatLevel
	includeSegmentFileSizes *bool
	includeUnloadedSegments *bool
	expandWildcards *ExpandWildcards
	forbidClosedIndices *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r ApiIndicesStatsRequest) CompletionFields(completionFields []string) ApiIndicesStatsRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r ApiIndicesStatsRequest) FielddataFields(fielddataFields []string) ApiIndicesStatsRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r ApiIndicesStatsRequest) Fields(fields []string) ApiIndicesStatsRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r ApiIndicesStatsRequest) Groups(groups []string) ApiIndicesStatsRequest {
	r.groups = &groups
	return r
}

// Return stats aggregated at cluster, index or shard level.
func (r ApiIndicesStatsRequest) Level(level IndiciesStatLevel) ApiIndicesStatsRequest {
	r.level = &level
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r ApiIndicesStatsRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) ApiIndicesStatsRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

// If set to true segment stats will include stats for segments that are not currently loaded into memory.
func (r ApiIndicesStatsRequest) IncludeUnloadedSegments(includeUnloadedSegments bool) ApiIndicesStatsRequest {
	r.includeUnloadedSegments = &includeUnloadedSegments
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesStatsRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesStatsRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
func (r ApiIndicesStatsRequest) ForbidClosedIndices(forbidClosedIndices bool) ApiIndicesStatsRequest {
	r.forbidClosedIndices = &forbidClosedIndices
	return r
}

func (r ApiIndicesStatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesStatsExecute(r)
}

/*
IndicesStats Method for IndicesStats

Provides statistics on operations happening in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesStatsRequest
*/
func (a *DefaultAPIService) IndicesStats(ctx context.Context) ApiIndicesStatsRequest {
	return ApiIndicesStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesStatsExecute(r ApiIndicesStatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesStats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	if r.includeUnloadedSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unloaded_segments", r.includeUnloadedSegments, "")
	} else {
		var defaultValue bool = false
		r.includeUnloadedSegments = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.forbidClosedIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forbid_closed_indices", r.forbidClosedIndices, "")
	} else {
		var defaultValue bool = true
		r.forbidClosedIndices = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesStatsWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *IndiciesStatLevel
	includeSegmentFileSizes *bool
	includeUnloadedSegments *bool
	expandWildcards *ExpandWildcards
	forbidClosedIndices *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r ApiIndicesStatsWithIndexRequest) CompletionFields(completionFields []string) ApiIndicesStatsWithIndexRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r ApiIndicesStatsWithIndexRequest) FielddataFields(fielddataFields []string) ApiIndicesStatsWithIndexRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r ApiIndicesStatsWithIndexRequest) Fields(fields []string) ApiIndicesStatsWithIndexRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r ApiIndicesStatsWithIndexRequest) Groups(groups []string) ApiIndicesStatsWithIndexRequest {
	r.groups = &groups
	return r
}

// Return stats aggregated at cluster, index or shard level.
func (r ApiIndicesStatsWithIndexRequest) Level(level IndiciesStatLevel) ApiIndicesStatsWithIndexRequest {
	r.level = &level
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r ApiIndicesStatsWithIndexRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) ApiIndicesStatsWithIndexRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

// If set to true segment stats will include stats for segments that are not currently loaded into memory.
func (r ApiIndicesStatsWithIndexRequest) IncludeUnloadedSegments(includeUnloadedSegments bool) ApiIndicesStatsWithIndexRequest {
	r.includeUnloadedSegments = &includeUnloadedSegments
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesStatsWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesStatsWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
func (r ApiIndicesStatsWithIndexRequest) ForbidClosedIndices(forbidClosedIndices bool) ApiIndicesStatsWithIndexRequest {
	r.forbidClosedIndices = &forbidClosedIndices
	return r
}

func (r ApiIndicesStatsWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesStatsWithIndexExecute(r)
}

/*
IndicesStatsWithIndex Method for IndicesStatsWithIndex

Provides statistics on operations happening in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesStatsWithIndexRequest
*/
func (a *DefaultAPIService) IndicesStatsWithIndex(ctx context.Context, index string) ApiIndicesStatsWithIndexRequest {
	return ApiIndicesStatsWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesStatsWithIndexExecute(r ApiIndicesStatsWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesStatsWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_stats"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	if r.includeUnloadedSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unloaded_segments", r.includeUnloadedSegments, "")
	} else {
		var defaultValue bool = false
		r.includeUnloadedSegments = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.forbidClosedIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forbid_closed_indices", r.forbidClosedIndices, "")
	} else {
		var defaultValue bool = true
		r.forbidClosedIndices = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesStatsWithIndexMetricRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	metric string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *IndiciesStatLevel
	includeSegmentFileSizes *bool
	includeUnloadedSegments *bool
	expandWildcards *ExpandWildcards
	forbidClosedIndices *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r ApiIndicesStatsWithIndexMetricRequest) CompletionFields(completionFields []string) ApiIndicesStatsWithIndexMetricRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r ApiIndicesStatsWithIndexMetricRequest) FielddataFields(fielddataFields []string) ApiIndicesStatsWithIndexMetricRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r ApiIndicesStatsWithIndexMetricRequest) Fields(fields []string) ApiIndicesStatsWithIndexMetricRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r ApiIndicesStatsWithIndexMetricRequest) Groups(groups []string) ApiIndicesStatsWithIndexMetricRequest {
	r.groups = &groups
	return r
}

// Return stats aggregated at cluster, index or shard level.
func (r ApiIndicesStatsWithIndexMetricRequest) Level(level IndiciesStatLevel) ApiIndicesStatsWithIndexMetricRequest {
	r.level = &level
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r ApiIndicesStatsWithIndexMetricRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) ApiIndicesStatsWithIndexMetricRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

// If set to true segment stats will include stats for segments that are not currently loaded into memory.
func (r ApiIndicesStatsWithIndexMetricRequest) IncludeUnloadedSegments(includeUnloadedSegments bool) ApiIndicesStatsWithIndexMetricRequest {
	r.includeUnloadedSegments = &includeUnloadedSegments
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesStatsWithIndexMetricRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesStatsWithIndexMetricRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
func (r ApiIndicesStatsWithIndexMetricRequest) ForbidClosedIndices(forbidClosedIndices bool) ApiIndicesStatsWithIndexMetricRequest {
	r.forbidClosedIndices = &forbidClosedIndices
	return r
}

func (r ApiIndicesStatsWithIndexMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesStatsWithIndexMetricExecute(r)
}

/*
IndicesStatsWithIndexMetric Method for IndicesStatsWithIndexMetric

Provides statistics on operations happening in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param metric Limit the information returned the specific metrics.
 @return ApiIndicesStatsWithIndexMetricRequest
*/
func (a *DefaultAPIService) IndicesStatsWithIndexMetric(ctx context.Context, index string, metric string) ApiIndicesStatsWithIndexMetricRequest {
	return ApiIndicesStatsWithIndexMetricRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		metric: metric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesStatsWithIndexMetricExecute(r ApiIndicesStatsWithIndexMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesStatsWithIndexMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_stats/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	if r.includeUnloadedSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unloaded_segments", r.includeUnloadedSegments, "")
	} else {
		var defaultValue bool = false
		r.includeUnloadedSegments = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.forbidClosedIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forbid_closed_indices", r.forbidClosedIndices, "")
	} else {
		var defaultValue bool = true
		r.forbidClosedIndices = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesStatsWithMetricRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *IndiciesStatLevel
	includeSegmentFileSizes *bool
	includeUnloadedSegments *bool
	expandWildcards *ExpandWildcards
	forbidClosedIndices *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r ApiIndicesStatsWithMetricRequest) CompletionFields(completionFields []string) ApiIndicesStatsWithMetricRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r ApiIndicesStatsWithMetricRequest) FielddataFields(fielddataFields []string) ApiIndicesStatsWithMetricRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r ApiIndicesStatsWithMetricRequest) Fields(fields []string) ApiIndicesStatsWithMetricRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r ApiIndicesStatsWithMetricRequest) Groups(groups []string) ApiIndicesStatsWithMetricRequest {
	r.groups = &groups
	return r
}

// Return stats aggregated at cluster, index or shard level.
func (r ApiIndicesStatsWithMetricRequest) Level(level IndiciesStatLevel) ApiIndicesStatsWithMetricRequest {
	r.level = &level
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r ApiIndicesStatsWithMetricRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) ApiIndicesStatsWithMetricRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

// If set to true segment stats will include stats for segments that are not currently loaded into memory.
func (r ApiIndicesStatsWithMetricRequest) IncludeUnloadedSegments(includeUnloadedSegments bool) ApiIndicesStatsWithMetricRequest {
	r.includeUnloadedSegments = &includeUnloadedSegments
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesStatsWithMetricRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesStatsWithMetricRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
func (r ApiIndicesStatsWithMetricRequest) ForbidClosedIndices(forbidClosedIndices bool) ApiIndicesStatsWithMetricRequest {
	r.forbidClosedIndices = &forbidClosedIndices
	return r
}

func (r ApiIndicesStatsWithMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesStatsWithMetricExecute(r)
}

/*
IndicesStatsWithMetric Method for IndicesStatsWithMetric

Provides statistics on operations happening in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned the specific metrics.
 @return ApiIndicesStatsWithMetricRequest
*/
func (a *DefaultAPIService) IndicesStatsWithMetric(ctx context.Context, metric string) ApiIndicesStatsWithMetricRequest {
	return ApiIndicesStatsWithMetricRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesStatsWithMetricExecute(r ApiIndicesStatsWithMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesStatsWithMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_stats/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	if r.includeUnloadedSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unloaded_segments", r.includeUnloadedSegments, "")
	} else {
		var defaultValue bool = false
		r.includeUnloadedSegments = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.forbidClosedIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forbid_closed_indices", r.forbidClosedIndices, "")
	} else {
		var defaultValue bool = true
		r.forbidClosedIndices = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesUpdateAliasesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	indicesUpdateAliasesBodyParams *IndicesUpdateAliasesBodyParams
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r ApiIndicesUpdateAliasesRequest) IndicesUpdateAliasesBodyParams(indicesUpdateAliasesBodyParams IndicesUpdateAliasesBodyParams) ApiIndicesUpdateAliasesRequest {
	r.indicesUpdateAliasesBodyParams = &indicesUpdateAliasesBodyParams
	return r
}

// Operation timeout.
func (r ApiIndicesUpdateAliasesRequest) Timeout(timeout string) ApiIndicesUpdateAliasesRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiIndicesUpdateAliasesRequest) MasterTimeout(masterTimeout string) ApiIndicesUpdateAliasesRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIndicesUpdateAliasesRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIndicesUpdateAliasesRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIndicesUpdateAliasesRequest) Execute() (*IndicesUpdateAliasesResponseContent, *http.Response, error) {
	return r.ApiService.IndicesUpdateAliasesExecute(r)
}

/*
IndicesUpdateAliases Method for IndicesUpdateAliases

Updates index aliases.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesUpdateAliasesRequest
*/
func (a *DefaultAPIService) IndicesUpdateAliases(ctx context.Context) ApiIndicesUpdateAliasesRequest {
	return ApiIndicesUpdateAliasesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IndicesUpdateAliasesResponseContent
func (a *DefaultAPIService) IndicesUpdateAliasesExecute(r ApiIndicesUpdateAliasesRequest) (*IndicesUpdateAliasesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesUpdateAliasesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesUpdateAliases")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_aliases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.indicesUpdateAliasesBodyParams == nil {
		return localVarReturnValue, nil, reportError("indicesUpdateAliasesBodyParams is required and must be specified")
	}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.indicesUpdateAliasesBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndicesUpgradeRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	ignoreUnavailable *bool
	waitForCompletion *bool
	onlyAncientSegments *bool
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesUpgradeRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesUpgradeRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesUpgradeRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesUpgradeRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesUpgradeRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesUpgradeRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Should this request wait until the operation has completed before returning.
func (r ApiIndicesUpgradeRequest) WaitForCompletion(waitForCompletion bool) ApiIndicesUpgradeRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

// If true, only ancient (an older Lucene major release) segments will be upgraded.
func (r ApiIndicesUpgradeRequest) OnlyAncientSegments(onlyAncientSegments bool) ApiIndicesUpgradeRequest {
	r.onlyAncientSegments = &onlyAncientSegments
	return r
}

func (r ApiIndicesUpgradeRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesUpgradeExecute(r)
}

/*
IndicesUpgrade Method for IndicesUpgrade

The _upgrade API is no longer useful and will be removed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesUpgradeRequest
*/
func (a *DefaultAPIService) IndicesUpgrade(ctx context.Context) ApiIndicesUpgradeRequest {
	return ApiIndicesUpgradeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesUpgradeExecute(r ApiIndicesUpgradeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesUpgrade")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_upgrade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	if r.onlyAncientSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_ancient_segments", r.onlyAncientSegments, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesUpgradeWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	ignoreUnavailable *bool
	waitForCompletion *bool
	onlyAncientSegments *bool
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesUpgradeWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesUpgradeWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesUpgradeWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesUpgradeWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesUpgradeWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesUpgradeWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Should this request wait until the operation has completed before returning.
func (r ApiIndicesUpgradeWithIndexRequest) WaitForCompletion(waitForCompletion bool) ApiIndicesUpgradeWithIndexRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

// If true, only ancient (an older Lucene major release) segments will be upgraded.
func (r ApiIndicesUpgradeWithIndexRequest) OnlyAncientSegments(onlyAncientSegments bool) ApiIndicesUpgradeWithIndexRequest {
	r.onlyAncientSegments = &onlyAncientSegments
	return r
}

func (r ApiIndicesUpgradeWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesUpgradeWithIndexExecute(r)
}

/*
IndicesUpgradeWithIndex Method for IndicesUpgradeWithIndex

The _upgrade API is no longer useful and will be removed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesUpgradeWithIndexRequest
*/
func (a *DefaultAPIService) IndicesUpgradeWithIndex(ctx context.Context, index string) ApiIndicesUpgradeWithIndexRequest {
	return ApiIndicesUpgradeWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesUpgradeWithIndexExecute(r ApiIndicesUpgradeWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesUpgradeWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_upgrade"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	if r.onlyAncientSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_ancient_segments", r.onlyAncientSegments, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesValidateQueryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	explain *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	rewrite *bool
	allShards *bool
}

// Return detailed information about the error.
func (r ApiIndicesValidateQueryGetRequest) Explain(explain bool) ApiIndicesValidateQueryGetRequest {
	r.explain = &explain
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesValidateQueryGetRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesValidateQueryGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesValidateQueryGetRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesValidateQueryGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesValidateQueryGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesValidateQueryGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Query in the Lucene query string syntax.
func (r ApiIndicesValidateQueryGetRequest) Q(q string) ApiIndicesValidateQueryGetRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r ApiIndicesValidateQueryGetRequest) Analyzer(analyzer string) ApiIndicesValidateQueryGetRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r ApiIndicesValidateQueryGetRequest) AnalyzeWildcard(analyzeWildcard bool) ApiIndicesValidateQueryGetRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiIndicesValidateQueryGetRequest) DefaultOperator(defaultOperator DefaultOperator) ApiIndicesValidateQueryGetRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r ApiIndicesValidateQueryGetRequest) Df(df string) ApiIndicesValidateQueryGetRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiIndicesValidateQueryGetRequest) Lenient(lenient bool) ApiIndicesValidateQueryGetRequest {
	r.lenient = &lenient
	return r
}

// Provide a more detailed explanation showing the actual Lucene query that will be executed.
func (r ApiIndicesValidateQueryGetRequest) Rewrite(rewrite bool) ApiIndicesValidateQueryGetRequest {
	r.rewrite = &rewrite
	return r
}

// Execute validation on all shards instead of one random shard per index.
func (r ApiIndicesValidateQueryGetRequest) AllShards(allShards bool) ApiIndicesValidateQueryGetRequest {
	r.allShards = &allShards
	return r
}

func (r ApiIndicesValidateQueryGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesValidateQueryGetExecute(r)
}

/*
IndicesValidateQueryGet Method for IndicesValidateQueryGet

Allows a user to validate a potentially expensive query without executing it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesValidateQueryGetRequest
*/
func (a *DefaultAPIService) IndicesValidateQueryGet(ctx context.Context) ApiIndicesValidateQueryGetRequest {
	return ApiIndicesValidateQueryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesValidateQueryGetExecute(r ApiIndicesValidateQueryGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesValidateQueryGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_validate/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.rewrite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rewrite", r.rewrite, "")
	}
	if r.allShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "all_shards", r.allShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesValidateQueryGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	explain *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	rewrite *bool
	allShards *bool
}

// Return detailed information about the error.
func (r ApiIndicesValidateQueryGetWithIndexRequest) Explain(explain bool) ApiIndicesValidateQueryGetWithIndexRequest {
	r.explain = &explain
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesValidateQueryGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesValidateQueryGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesValidateQueryGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesValidateQueryGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesValidateQueryGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesValidateQueryGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Query in the Lucene query string syntax.
func (r ApiIndicesValidateQueryGetWithIndexRequest) Q(q string) ApiIndicesValidateQueryGetWithIndexRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r ApiIndicesValidateQueryGetWithIndexRequest) Analyzer(analyzer string) ApiIndicesValidateQueryGetWithIndexRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r ApiIndicesValidateQueryGetWithIndexRequest) AnalyzeWildcard(analyzeWildcard bool) ApiIndicesValidateQueryGetWithIndexRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiIndicesValidateQueryGetWithIndexRequest) DefaultOperator(defaultOperator DefaultOperator) ApiIndicesValidateQueryGetWithIndexRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r ApiIndicesValidateQueryGetWithIndexRequest) Df(df string) ApiIndicesValidateQueryGetWithIndexRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiIndicesValidateQueryGetWithIndexRequest) Lenient(lenient bool) ApiIndicesValidateQueryGetWithIndexRequest {
	r.lenient = &lenient
	return r
}

// Provide a more detailed explanation showing the actual Lucene query that will be executed.
func (r ApiIndicesValidateQueryGetWithIndexRequest) Rewrite(rewrite bool) ApiIndicesValidateQueryGetWithIndexRequest {
	r.rewrite = &rewrite
	return r
}

// Execute validation on all shards instead of one random shard per index.
func (r ApiIndicesValidateQueryGetWithIndexRequest) AllShards(allShards bool) ApiIndicesValidateQueryGetWithIndexRequest {
	r.allShards = &allShards
	return r
}

func (r ApiIndicesValidateQueryGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesValidateQueryGetWithIndexExecute(r)
}

/*
IndicesValidateQueryGetWithIndex Method for IndicesValidateQueryGetWithIndex

Allows a user to validate a potentially expensive query without executing it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesValidateQueryGetWithIndexRequest
*/
func (a *DefaultAPIService) IndicesValidateQueryGetWithIndex(ctx context.Context, index string) ApiIndicesValidateQueryGetWithIndexRequest {
	return ApiIndicesValidateQueryGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesValidateQueryGetWithIndexExecute(r ApiIndicesValidateQueryGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesValidateQueryGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_validate/query"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.rewrite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rewrite", r.rewrite, "")
	}
	if r.allShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "all_shards", r.allShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesValidateQueryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	explain *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	rewrite *bool
	allShards *bool
	body *map[string]interface{}
}

// Return detailed information about the error.
func (r ApiIndicesValidateQueryPostRequest) Explain(explain bool) ApiIndicesValidateQueryPostRequest {
	r.explain = &explain
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesValidateQueryPostRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesValidateQueryPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesValidateQueryPostRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesValidateQueryPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesValidateQueryPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesValidateQueryPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Query in the Lucene query string syntax.
func (r ApiIndicesValidateQueryPostRequest) Q(q string) ApiIndicesValidateQueryPostRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r ApiIndicesValidateQueryPostRequest) Analyzer(analyzer string) ApiIndicesValidateQueryPostRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r ApiIndicesValidateQueryPostRequest) AnalyzeWildcard(analyzeWildcard bool) ApiIndicesValidateQueryPostRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiIndicesValidateQueryPostRequest) DefaultOperator(defaultOperator DefaultOperator) ApiIndicesValidateQueryPostRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r ApiIndicesValidateQueryPostRequest) Df(df string) ApiIndicesValidateQueryPostRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiIndicesValidateQueryPostRequest) Lenient(lenient bool) ApiIndicesValidateQueryPostRequest {
	r.lenient = &lenient
	return r
}

// Provide a more detailed explanation showing the actual Lucene query that will be executed.
func (r ApiIndicesValidateQueryPostRequest) Rewrite(rewrite bool) ApiIndicesValidateQueryPostRequest {
	r.rewrite = &rewrite
	return r
}

// Execute validation on all shards instead of one random shard per index.
func (r ApiIndicesValidateQueryPostRequest) AllShards(allShards bool) ApiIndicesValidateQueryPostRequest {
	r.allShards = &allShards
	return r
}

func (r ApiIndicesValidateQueryPostRequest) Body(body map[string]interface{}) ApiIndicesValidateQueryPostRequest {
	r.body = &body
	return r
}

func (r ApiIndicesValidateQueryPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesValidateQueryPostExecute(r)
}

/*
IndicesValidateQueryPost Method for IndicesValidateQueryPost

Allows a user to validate a potentially expensive query without executing it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndicesValidateQueryPostRequest
*/
func (a *DefaultAPIService) IndicesValidateQueryPost(ctx context.Context) ApiIndicesValidateQueryPostRequest {
	return ApiIndicesValidateQueryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesValidateQueryPostExecute(r ApiIndicesValidateQueryPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesValidateQueryPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_validate/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.rewrite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rewrite", r.rewrite, "")
	}
	if r.allShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "all_shards", r.allShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIndicesValidateQueryPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	explain *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	rewrite *bool
	allShards *bool
	body *map[string]interface{}
}

// Return detailed information about the error.
func (r ApiIndicesValidateQueryPostWithIndexRequest) Explain(explain bool) ApiIndicesValidateQueryPostWithIndexRequest {
	r.explain = &explain
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiIndicesValidateQueryPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiIndicesValidateQueryPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiIndicesValidateQueryPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiIndicesValidateQueryPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiIndicesValidateQueryPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiIndicesValidateQueryPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Query in the Lucene query string syntax.
func (r ApiIndicesValidateQueryPostWithIndexRequest) Q(q string) ApiIndicesValidateQueryPostWithIndexRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r ApiIndicesValidateQueryPostWithIndexRequest) Analyzer(analyzer string) ApiIndicesValidateQueryPostWithIndexRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r ApiIndicesValidateQueryPostWithIndexRequest) AnalyzeWildcard(analyzeWildcard bool) ApiIndicesValidateQueryPostWithIndexRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiIndicesValidateQueryPostWithIndexRequest) DefaultOperator(defaultOperator DefaultOperator) ApiIndicesValidateQueryPostWithIndexRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r ApiIndicesValidateQueryPostWithIndexRequest) Df(df string) ApiIndicesValidateQueryPostWithIndexRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiIndicesValidateQueryPostWithIndexRequest) Lenient(lenient bool) ApiIndicesValidateQueryPostWithIndexRequest {
	r.lenient = &lenient
	return r
}

// Provide a more detailed explanation showing the actual Lucene query that will be executed.
func (r ApiIndicesValidateQueryPostWithIndexRequest) Rewrite(rewrite bool) ApiIndicesValidateQueryPostWithIndexRequest {
	r.rewrite = &rewrite
	return r
}

// Execute validation on all shards instead of one random shard per index.
func (r ApiIndicesValidateQueryPostWithIndexRequest) AllShards(allShards bool) ApiIndicesValidateQueryPostWithIndexRequest {
	r.allShards = &allShards
	return r
}

func (r ApiIndicesValidateQueryPostWithIndexRequest) Body(body map[string]interface{}) ApiIndicesValidateQueryPostWithIndexRequest {
	r.body = &body
	return r
}

func (r ApiIndicesValidateQueryPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesValidateQueryPostWithIndexExecute(r)
}

/*
IndicesValidateQueryPostWithIndex Method for IndicesValidateQueryPostWithIndex

Allows a user to validate a potentially expensive query without executing it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiIndicesValidateQueryPostWithIndexRequest
*/
func (a *DefaultAPIService) IndicesValidateQueryPostWithIndex(ctx context.Context, index string) ApiIndicesValidateQueryPostWithIndexRequest {
	return ApiIndicesValidateQueryPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesValidateQueryPostWithIndexExecute(r ApiIndicesValidateQueryPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesValidateQueryPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_validate/query"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.rewrite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rewrite", r.rewrite, "")
	}
	if r.allShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "all_shards", r.allShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInfoRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiInfoRequest) Execute() (*InfoResponseContent, *http.Response, error) {
	return r.ApiService.InfoExecute(r)
}

/*
Info Method for Info

Returns basic information about the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInfoRequest
*/
func (a *DefaultAPIService) Info(ctx context.Context) ApiInfoRequest {
	return ApiInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InfoResponseContent
func (a *DefaultAPIService) InfoExecute(r ApiInfoRequest) (*InfoResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InfoResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Info")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIngestDeletePipelineRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
}

// Operation timeout for connection to master node.
func (r ApiIngestDeletePipelineRequest) MasterTimeout(masterTimeout string) ApiIngestDeletePipelineRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIngestDeletePipelineRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIngestDeletePipelineRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r ApiIngestDeletePipelineRequest) Timeout(timeout string) ApiIngestDeletePipelineRequest {
	r.timeout = &timeout
	return r
}

func (r ApiIngestDeletePipelineRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestDeletePipelineExecute(r)
}

/*
IngestDeletePipeline Method for IngestDeletePipeline

Deletes a pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Pipeline ID.
 @return ApiIngestDeletePipelineRequest
*/
func (a *DefaultAPIService) IngestDeletePipeline(ctx context.Context, id string) ApiIngestDeletePipelineRequest {
	return ApiIngestDeletePipelineRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestDeletePipelineExecute(r ApiIngestDeletePipelineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestDeletePipeline")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIngestGetPipelineRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout for connection to master node.
func (r ApiIngestGetPipelineRequest) MasterTimeout(masterTimeout string) ApiIngestGetPipelineRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIngestGetPipelineRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIngestGetPipelineRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIngestGetPipelineRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestGetPipelineExecute(r)
}

/*
IngestGetPipeline Method for IngestGetPipeline

Returns a pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIngestGetPipelineRequest
*/
func (a *DefaultAPIService) IngestGetPipeline(ctx context.Context) ApiIngestGetPipelineRequest {
	return ApiIngestGetPipelineRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestGetPipelineExecute(r ApiIngestGetPipelineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestGetPipeline")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIngestGetPipelineWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout for connection to master node.
func (r ApiIngestGetPipelineWithIdRequest) MasterTimeout(masterTimeout string) ApiIngestGetPipelineWithIdRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIngestGetPipelineWithIdRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIngestGetPipelineWithIdRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiIngestGetPipelineWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestGetPipelineWithIdExecute(r)
}

/*
IngestGetPipelineWithId Method for IngestGetPipelineWithId

Returns a pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Comma-separated list of pipeline ids. Wildcards supported.
 @return ApiIngestGetPipelineWithIdRequest
*/
func (a *DefaultAPIService) IngestGetPipelineWithId(ctx context.Context, id string) ApiIngestGetPipelineWithIdRequest {
	return ApiIngestGetPipelineWithIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestGetPipelineWithIdExecute(r ApiIngestGetPipelineWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestGetPipelineWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIngestProcessorGrokRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiIngestProcessorGrokRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestProcessorGrokExecute(r)
}

/*
IngestProcessorGrok Method for IngestProcessorGrok

Returns a list of the built-in patterns.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIngestProcessorGrokRequest
*/
func (a *DefaultAPIService) IngestProcessorGrok(ctx context.Context) ApiIngestProcessorGrokRequest {
	return ApiIngestProcessorGrokRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestProcessorGrokExecute(r ApiIngestProcessorGrokRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestProcessorGrok")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/processor/grok"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIngestPutPipelineRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	body *map[string]interface{}
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
}

func (r ApiIngestPutPipelineRequest) Body(body map[string]interface{}) ApiIngestPutPipelineRequest {
	r.body = &body
	return r
}

// Operation timeout for connection to master node.
func (r ApiIngestPutPipelineRequest) MasterTimeout(masterTimeout string) ApiIngestPutPipelineRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiIngestPutPipelineRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiIngestPutPipelineRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r ApiIngestPutPipelineRequest) Timeout(timeout string) ApiIngestPutPipelineRequest {
	r.timeout = &timeout
	return r
}

func (r ApiIngestPutPipelineRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestPutPipelineExecute(r)
}

/*
IngestPutPipeline Method for IngestPutPipeline

Creates or updates a pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Pipeline ID.
 @return ApiIngestPutPipelineRequest
*/
func (a *DefaultAPIService) IngestPutPipeline(ctx context.Context, id string) ApiIngestPutPipelineRequest {
	return ApiIngestPutPipelineRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestPutPipelineExecute(r ApiIngestPutPipelineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestPutPipeline")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIngestSimulateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	verbose *bool
}

// Verbose mode. Display data output for each processor in executed pipeline.
func (r ApiIngestSimulateGetRequest) Verbose(verbose bool) ApiIngestSimulateGetRequest {
	r.verbose = &verbose
	return r
}

func (r ApiIngestSimulateGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestSimulateGetExecute(r)
}

/*
IngestSimulateGet Method for IngestSimulateGet

Allows to simulate a pipeline with example documents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIngestSimulateGetRequest
*/
func (a *DefaultAPIService) IngestSimulateGet(ctx context.Context) ApiIngestSimulateGetRequest {
	return ApiIngestSimulateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestSimulateGetExecute(r ApiIngestSimulateGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestSimulateGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline/_simulate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIngestSimulateGetWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	verbose *bool
}

// Verbose mode. Display data output for each processor in executed pipeline.
func (r ApiIngestSimulateGetWithIdRequest) Verbose(verbose bool) ApiIngestSimulateGetWithIdRequest {
	r.verbose = &verbose
	return r
}

func (r ApiIngestSimulateGetWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestSimulateGetWithIdExecute(r)
}

/*
IngestSimulateGetWithId Method for IngestSimulateGetWithId

Allows to simulate a pipeline with example documents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Pipeline ID.
 @return ApiIngestSimulateGetWithIdRequest
*/
func (a *DefaultAPIService) IngestSimulateGetWithId(ctx context.Context, id string) ApiIngestSimulateGetWithIdRequest {
	return ApiIngestSimulateGetWithIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestSimulateGetWithIdExecute(r ApiIngestSimulateGetWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestSimulateGetWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline/{id}/_simulate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIngestSimulatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	verbose *bool
}

func (r ApiIngestSimulatePostRequest) Body(body map[string]interface{}) ApiIngestSimulatePostRequest {
	r.body = &body
	return r
}

// Verbose mode. Display data output for each processor in executed pipeline.
func (r ApiIngestSimulatePostRequest) Verbose(verbose bool) ApiIngestSimulatePostRequest {
	r.verbose = &verbose
	return r
}

func (r ApiIngestSimulatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestSimulatePostExecute(r)
}

/*
IngestSimulatePost Method for IngestSimulatePost

Allows to simulate a pipeline with example documents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIngestSimulatePostRequest
*/
func (a *DefaultAPIService) IngestSimulatePost(ctx context.Context) ApiIngestSimulatePostRequest {
	return ApiIngestSimulatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestSimulatePostExecute(r ApiIngestSimulatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestSimulatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline/_simulate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIngestSimulatePostWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	body *map[string]interface{}
	verbose *bool
}

func (r ApiIngestSimulatePostWithIdRequest) Body(body map[string]interface{}) ApiIngestSimulatePostWithIdRequest {
	r.body = &body
	return r
}

// Verbose mode. Display data output for each processor in executed pipeline.
func (r ApiIngestSimulatePostWithIdRequest) Verbose(verbose bool) ApiIngestSimulatePostWithIdRequest {
	r.verbose = &verbose
	return r
}

func (r ApiIngestSimulatePostWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestSimulatePostWithIdExecute(r)
}

/*
IngestSimulatePostWithId Method for IngestSimulatePostWithId

Allows to simulate a pipeline with example documents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Pipeline ID.
 @return ApiIngestSimulatePostWithIdRequest
*/
func (a *DefaultAPIService) IngestSimulatePostWithId(ctx context.Context, id string) ApiIngestSimulatePostWithIdRequest {
	return ApiIngestSimulatePostWithIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestSimulatePostWithIdExecute(r ApiIngestSimulatePostWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestSimulatePostWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline/{id}/_simulate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMgetGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	storedFields *[]string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
}

// Comma-separated list of stored fields to return.
func (r ApiMgetGetRequest) StoredFields(storedFields []string) ApiMgetGetRequest {
	r.storedFields = &storedFields
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiMgetGetRequest) Preference(preference string) ApiMgetGetRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r ApiMgetGetRequest) Realtime(realtime bool) ApiMgetGetRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r ApiMgetGetRequest) Refresh(refresh bool) ApiMgetGetRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiMgetGetRequest) Routing(routing string) ApiMgetGetRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiMgetGetRequest) Source(source []string) ApiMgetGetRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiMgetGetRequest) SourceExcludes(sourceExcludes []string) ApiMgetGetRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiMgetGetRequest) SourceIncludes(sourceIncludes []string) ApiMgetGetRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

func (r ApiMgetGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MgetGetExecute(r)
}

/*
MgetGet Method for MgetGet

Allows to get multiple documents in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMgetGetRequest
*/
func (a *DefaultAPIService) MgetGet(ctx context.Context) ApiMgetGetRequest {
	return ApiMgetGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MgetGetExecute(r ApiMgetGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MgetGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_mget"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMgetGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	storedFields *[]string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
}

// Comma-separated list of stored fields to return.
func (r ApiMgetGetWithIndexRequest) StoredFields(storedFields []string) ApiMgetGetWithIndexRequest {
	r.storedFields = &storedFields
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiMgetGetWithIndexRequest) Preference(preference string) ApiMgetGetWithIndexRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r ApiMgetGetWithIndexRequest) Realtime(realtime bool) ApiMgetGetWithIndexRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r ApiMgetGetWithIndexRequest) Refresh(refresh bool) ApiMgetGetWithIndexRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiMgetGetWithIndexRequest) Routing(routing string) ApiMgetGetWithIndexRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiMgetGetWithIndexRequest) Source(source []string) ApiMgetGetWithIndexRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiMgetGetWithIndexRequest) SourceExcludes(sourceExcludes []string) ApiMgetGetWithIndexRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiMgetGetWithIndexRequest) SourceIncludes(sourceIncludes []string) ApiMgetGetWithIndexRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

func (r ApiMgetGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MgetGetWithIndexExecute(r)
}

/*
MgetGetWithIndex Method for MgetGetWithIndex

Allows to get multiple documents in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Index name.
 @return ApiMgetGetWithIndexRequest
*/
func (a *DefaultAPIService) MgetGetWithIndex(ctx context.Context, index string) ApiMgetGetWithIndexRequest {
	return ApiMgetGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MgetGetWithIndexExecute(r ApiMgetGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MgetGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mget"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMgetPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	storedFields *[]string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
}

func (r ApiMgetPostRequest) Body(body map[string]interface{}) ApiMgetPostRequest {
	r.body = &body
	return r
}

// Comma-separated list of stored fields to return.
func (r ApiMgetPostRequest) StoredFields(storedFields []string) ApiMgetPostRequest {
	r.storedFields = &storedFields
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiMgetPostRequest) Preference(preference string) ApiMgetPostRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r ApiMgetPostRequest) Realtime(realtime bool) ApiMgetPostRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r ApiMgetPostRequest) Refresh(refresh bool) ApiMgetPostRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiMgetPostRequest) Routing(routing string) ApiMgetPostRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiMgetPostRequest) Source(source []string) ApiMgetPostRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiMgetPostRequest) SourceExcludes(sourceExcludes []string) ApiMgetPostRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiMgetPostRequest) SourceIncludes(sourceIncludes []string) ApiMgetPostRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

func (r ApiMgetPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.MgetPostExecute(r)
}

/*
MgetPost Method for MgetPost

Allows to get multiple documents in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMgetPostRequest
*/
func (a *DefaultAPIService) MgetPost(ctx context.Context) ApiMgetPostRequest {
	return ApiMgetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MgetPostExecute(r ApiMgetPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MgetPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_mget"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMgetPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	storedFields *[]string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
}

func (r ApiMgetPostWithIndexRequest) Body(body map[string]interface{}) ApiMgetPostWithIndexRequest {
	r.body = &body
	return r
}

// Comma-separated list of stored fields to return.
func (r ApiMgetPostWithIndexRequest) StoredFields(storedFields []string) ApiMgetPostWithIndexRequest {
	r.storedFields = &storedFields
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiMgetPostWithIndexRequest) Preference(preference string) ApiMgetPostWithIndexRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r ApiMgetPostWithIndexRequest) Realtime(realtime bool) ApiMgetPostWithIndexRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r ApiMgetPostWithIndexRequest) Refresh(refresh bool) ApiMgetPostWithIndexRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r ApiMgetPostWithIndexRequest) Routing(routing string) ApiMgetPostWithIndexRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiMgetPostWithIndexRequest) Source(source []string) ApiMgetPostWithIndexRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiMgetPostWithIndexRequest) SourceExcludes(sourceExcludes []string) ApiMgetPostWithIndexRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiMgetPostWithIndexRequest) SourceIncludes(sourceIncludes []string) ApiMgetPostWithIndexRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

func (r ApiMgetPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MgetPostWithIndexExecute(r)
}

/*
MgetPostWithIndex Method for MgetPostWithIndex

Allows to get multiple documents in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Index name.
 @return ApiMgetPostWithIndexRequest
*/
func (a *DefaultAPIService) MgetPostWithIndex(ctx context.Context, index string) ApiMgetPostWithIndexRequest {
	return ApiMgetPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MgetPostWithIndexExecute(r ApiMgetPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MgetPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mget"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMsearchGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	searchType *SearchTypeMulti
	maxConcurrentSearches *int32
	typedKeys *bool
	preFilterShardSize *int32
	maxConcurrentShardRequests *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

// Search operation type.
func (r ApiMsearchGetRequest) SearchType(searchType SearchTypeMulti) ApiMsearchGetRequest {
	r.searchType = &searchType
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r ApiMsearchGetRequest) MaxConcurrentSearches(maxConcurrentSearches int32) ApiMsearchGetRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiMsearchGetRequest) TypedKeys(typedKeys bool) ApiMsearchGetRequest {
	r.typedKeys = &typedKeys
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r ApiMsearchGetRequest) PreFilterShardSize(preFilterShardSize int32) ApiMsearchGetRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r ApiMsearchGetRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) ApiMsearchGetRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiMsearchGetRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiMsearchGetRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiMsearchGetRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiMsearchGetRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r ApiMsearchGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchGetExecute(r)
}

/*
MsearchGet Method for MsearchGet

Allows to execute several search operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMsearchGetRequest
*/
func (a *DefaultAPIService) MsearchGet(ctx context.Context) ApiMsearchGetRequest {
	return ApiMsearchGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchGetExecute(r ApiMsearchGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_msearch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMsearchGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	searchType *SearchTypeMulti
	maxConcurrentSearches *int32
	typedKeys *bool
	preFilterShardSize *int32
	maxConcurrentShardRequests *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

// Search operation type.
func (r ApiMsearchGetWithIndexRequest) SearchType(searchType SearchTypeMulti) ApiMsearchGetWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r ApiMsearchGetWithIndexRequest) MaxConcurrentSearches(maxConcurrentSearches int32) ApiMsearchGetWithIndexRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiMsearchGetWithIndexRequest) TypedKeys(typedKeys bool) ApiMsearchGetWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r ApiMsearchGetWithIndexRequest) PreFilterShardSize(preFilterShardSize int32) ApiMsearchGetWithIndexRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r ApiMsearchGetWithIndexRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) ApiMsearchGetWithIndexRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiMsearchGetWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiMsearchGetWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiMsearchGetWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiMsearchGetWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r ApiMsearchGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchGetWithIndexExecute(r)
}

/*
MsearchGetWithIndex Method for MsearchGetWithIndex

Allows to execute several search operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to use as default.
 @return ApiMsearchGetWithIndexRequest
*/
func (a *DefaultAPIService) MsearchGetWithIndex(ctx context.Context, index string) ApiMsearchGetWithIndexRequest {
	return ApiMsearchGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchGetWithIndexExecute(r ApiMsearchGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_msearch"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMsearchPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	searchType *SearchTypeMulti
	maxConcurrentSearches *int32
	typedKeys *bool
	preFilterShardSize *int32
	maxConcurrentShardRequests *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

func (r ApiMsearchPostRequest) Body(body map[string]interface{}) ApiMsearchPostRequest {
	r.body = &body
	return r
}

// Search operation type.
func (r ApiMsearchPostRequest) SearchType(searchType SearchTypeMulti) ApiMsearchPostRequest {
	r.searchType = &searchType
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r ApiMsearchPostRequest) MaxConcurrentSearches(maxConcurrentSearches int32) ApiMsearchPostRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiMsearchPostRequest) TypedKeys(typedKeys bool) ApiMsearchPostRequest {
	r.typedKeys = &typedKeys
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r ApiMsearchPostRequest) PreFilterShardSize(preFilterShardSize int32) ApiMsearchPostRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r ApiMsearchPostRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) ApiMsearchPostRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiMsearchPostRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiMsearchPostRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiMsearchPostRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiMsearchPostRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r ApiMsearchPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchPostExecute(r)
}

/*
MsearchPost Method for MsearchPost

Allows to execute several search operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMsearchPostRequest
*/
func (a *DefaultAPIService) MsearchPost(ctx context.Context) ApiMsearchPostRequest {
	return ApiMsearchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchPostExecute(r ApiMsearchPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_msearch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMsearchPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	searchType *SearchTypeMulti
	maxConcurrentSearches *int32
	typedKeys *bool
	preFilterShardSize *int32
	maxConcurrentShardRequests *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

func (r ApiMsearchPostWithIndexRequest) Body(body map[string]interface{}) ApiMsearchPostWithIndexRequest {
	r.body = &body
	return r
}

// Search operation type.
func (r ApiMsearchPostWithIndexRequest) SearchType(searchType SearchTypeMulti) ApiMsearchPostWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r ApiMsearchPostWithIndexRequest) MaxConcurrentSearches(maxConcurrentSearches int32) ApiMsearchPostWithIndexRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiMsearchPostWithIndexRequest) TypedKeys(typedKeys bool) ApiMsearchPostWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r ApiMsearchPostWithIndexRequest) PreFilterShardSize(preFilterShardSize int32) ApiMsearchPostWithIndexRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r ApiMsearchPostWithIndexRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) ApiMsearchPostWithIndexRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiMsearchPostWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiMsearchPostWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiMsearchPostWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiMsearchPostWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r ApiMsearchPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchPostWithIndexExecute(r)
}

/*
MsearchPostWithIndex Method for MsearchPostWithIndex

Allows to execute several search operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to use as default.
 @return ApiMsearchPostWithIndexRequest
*/
func (a *DefaultAPIService) MsearchPostWithIndex(ctx context.Context, index string) ApiMsearchPostWithIndexRequest {
	return ApiMsearchPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchPostWithIndexExecute(r ApiMsearchPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_msearch"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMsearchTemplateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	searchType *SearchTypeMulti
	typedKeys *bool
	maxConcurrentSearches *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

// Search operation type.
func (r ApiMsearchTemplateGetRequest) SearchType(searchType SearchTypeMulti) ApiMsearchTemplateGetRequest {
	r.searchType = &searchType
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiMsearchTemplateGetRequest) TypedKeys(typedKeys bool) ApiMsearchTemplateGetRequest {
	r.typedKeys = &typedKeys
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r ApiMsearchTemplateGetRequest) MaxConcurrentSearches(maxConcurrentSearches int32) ApiMsearchTemplateGetRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiMsearchTemplateGetRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiMsearchTemplateGetRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiMsearchTemplateGetRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiMsearchTemplateGetRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r ApiMsearchTemplateGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchTemplateGetExecute(r)
}

/*
MsearchTemplateGet Method for MsearchTemplateGet

Allows to execute several search template operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMsearchTemplateGetRequest
*/
func (a *DefaultAPIService) MsearchTemplateGet(ctx context.Context) ApiMsearchTemplateGetRequest {
	return ApiMsearchTemplateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchTemplateGetExecute(r ApiMsearchTemplateGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchTemplateGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_msearch/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMsearchTemplateGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	searchType *SearchTypeMulti
	typedKeys *bool
	maxConcurrentSearches *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

// Search operation type.
func (r ApiMsearchTemplateGetWithIndexRequest) SearchType(searchType SearchTypeMulti) ApiMsearchTemplateGetWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiMsearchTemplateGetWithIndexRequest) TypedKeys(typedKeys bool) ApiMsearchTemplateGetWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r ApiMsearchTemplateGetWithIndexRequest) MaxConcurrentSearches(maxConcurrentSearches int32) ApiMsearchTemplateGetWithIndexRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiMsearchTemplateGetWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiMsearchTemplateGetWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiMsearchTemplateGetWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiMsearchTemplateGetWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r ApiMsearchTemplateGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchTemplateGetWithIndexExecute(r)
}

/*
MsearchTemplateGetWithIndex Method for MsearchTemplateGetWithIndex

Allows to execute several search template operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to use as default.
 @return ApiMsearchTemplateGetWithIndexRequest
*/
func (a *DefaultAPIService) MsearchTemplateGetWithIndex(ctx context.Context, index string) ApiMsearchTemplateGetWithIndexRequest {
	return ApiMsearchTemplateGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchTemplateGetWithIndexExecute(r ApiMsearchTemplateGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchTemplateGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_msearch/template"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMsearchTemplatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	searchType *SearchTypeMulti
	typedKeys *bool
	maxConcurrentSearches *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

func (r ApiMsearchTemplatePostRequest) Body(body map[string]interface{}) ApiMsearchTemplatePostRequest {
	r.body = &body
	return r
}

// Search operation type.
func (r ApiMsearchTemplatePostRequest) SearchType(searchType SearchTypeMulti) ApiMsearchTemplatePostRequest {
	r.searchType = &searchType
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiMsearchTemplatePostRequest) TypedKeys(typedKeys bool) ApiMsearchTemplatePostRequest {
	r.typedKeys = &typedKeys
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r ApiMsearchTemplatePostRequest) MaxConcurrentSearches(maxConcurrentSearches int32) ApiMsearchTemplatePostRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiMsearchTemplatePostRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiMsearchTemplatePostRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiMsearchTemplatePostRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiMsearchTemplatePostRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r ApiMsearchTemplatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchTemplatePostExecute(r)
}

/*
MsearchTemplatePost Method for MsearchTemplatePost

Allows to execute several search template operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMsearchTemplatePostRequest
*/
func (a *DefaultAPIService) MsearchTemplatePost(ctx context.Context) ApiMsearchTemplatePostRequest {
	return ApiMsearchTemplatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchTemplatePostExecute(r ApiMsearchTemplatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchTemplatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_msearch/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMsearchTemplatePostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	searchType *SearchTypeMulti
	typedKeys *bool
	maxConcurrentSearches *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

func (r ApiMsearchTemplatePostWithIndexRequest) Body(body map[string]interface{}) ApiMsearchTemplatePostWithIndexRequest {
	r.body = &body
	return r
}

// Search operation type.
func (r ApiMsearchTemplatePostWithIndexRequest) SearchType(searchType SearchTypeMulti) ApiMsearchTemplatePostWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiMsearchTemplatePostWithIndexRequest) TypedKeys(typedKeys bool) ApiMsearchTemplatePostWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r ApiMsearchTemplatePostWithIndexRequest) MaxConcurrentSearches(maxConcurrentSearches int32) ApiMsearchTemplatePostWithIndexRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiMsearchTemplatePostWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiMsearchTemplatePostWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiMsearchTemplatePostWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiMsearchTemplatePostWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r ApiMsearchTemplatePostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchTemplatePostWithIndexExecute(r)
}

/*
MsearchTemplatePostWithIndex Method for MsearchTemplatePostWithIndex

Allows to execute several search template operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to use as default.
 @return ApiMsearchTemplatePostWithIndexRequest
*/
func (a *DefaultAPIService) MsearchTemplatePostWithIndex(ctx context.Context, index string) ApiMsearchTemplatePostWithIndexRequest {
	return ApiMsearchTemplatePostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchTemplatePostWithIndexExecute(r ApiMsearchTemplatePostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchTemplatePostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_msearch/template"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMtermvectorsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ids *[]string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
}

// Comma-separated list of documents ids. You must define ids as parameter or set &#39;ids&#39; or &#39;docs&#39; in the request body.
func (r ApiMtermvectorsGetRequest) Ids(ids []string) ApiMtermvectorsGetRequest {
	r.ids = &ids
	return r
}

// Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetRequest) TermStatistics(termStatistics bool) ApiMtermvectorsGetRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetRequest) FieldStatistics(fieldStatistics bool) ApiMtermvectorsGetRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetRequest) Fields(fields []string) ApiMtermvectorsGetRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetRequest) Offsets(offsets bool) ApiMtermvectorsGetRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetRequest) Positions(positions bool) ApiMtermvectorsGetRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetRequest) Payloads(payloads bool) ApiMtermvectorsGetRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetRequest) Preference(preference string) ApiMtermvectorsGetRequest {
	r.preference = &preference
	return r
}

// Routing value. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetRequest) Routing(routing string) ApiMtermvectorsGetRequest {
	r.routing = &routing
	return r
}

// Specifies if requests are real-time as opposed to near-real-time.
func (r ApiMtermvectorsGetRequest) Realtime(realtime bool) ApiMtermvectorsGetRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r ApiMtermvectorsGetRequest) Version(version int32) ApiMtermvectorsGetRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiMtermvectorsGetRequest) VersionType(versionType VersionType) ApiMtermvectorsGetRequest {
	r.versionType = &versionType
	return r
}

func (r ApiMtermvectorsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MtermvectorsGetExecute(r)
}

/*
MtermvectorsGet Method for MtermvectorsGet

Returns multiple termvectors in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMtermvectorsGetRequest
*/
func (a *DefaultAPIService) MtermvectorsGet(ctx context.Context) ApiMtermvectorsGetRequest {
	return ApiMtermvectorsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MtermvectorsGetExecute(r ApiMtermvectorsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MtermvectorsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_mtermvectors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMtermvectorsGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ids *[]string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
}

// Comma-separated list of documents ids. You must define ids as parameter or set &#39;ids&#39; or &#39;docs&#39; in the request body.
func (r ApiMtermvectorsGetWithIndexRequest) Ids(ids []string) ApiMtermvectorsGetWithIndexRequest {
	r.ids = &ids
	return r
}

// Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetWithIndexRequest) TermStatistics(termStatistics bool) ApiMtermvectorsGetWithIndexRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetWithIndexRequest) FieldStatistics(fieldStatistics bool) ApiMtermvectorsGetWithIndexRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetWithIndexRequest) Fields(fields []string) ApiMtermvectorsGetWithIndexRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetWithIndexRequest) Offsets(offsets bool) ApiMtermvectorsGetWithIndexRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetWithIndexRequest) Positions(positions bool) ApiMtermvectorsGetWithIndexRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetWithIndexRequest) Payloads(payloads bool) ApiMtermvectorsGetWithIndexRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetWithIndexRequest) Preference(preference string) ApiMtermvectorsGetWithIndexRequest {
	r.preference = &preference
	return r
}

// Routing value. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsGetWithIndexRequest) Routing(routing string) ApiMtermvectorsGetWithIndexRequest {
	r.routing = &routing
	return r
}

// Specifies if requests are real-time as opposed to near-real-time.
func (r ApiMtermvectorsGetWithIndexRequest) Realtime(realtime bool) ApiMtermvectorsGetWithIndexRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r ApiMtermvectorsGetWithIndexRequest) Version(version int32) ApiMtermvectorsGetWithIndexRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiMtermvectorsGetWithIndexRequest) VersionType(versionType VersionType) ApiMtermvectorsGetWithIndexRequest {
	r.versionType = &versionType
	return r
}

func (r ApiMtermvectorsGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MtermvectorsGetWithIndexExecute(r)
}

/*
MtermvectorsGetWithIndex Method for MtermvectorsGetWithIndex

Returns multiple termvectors in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The index in which the document resides.
 @return ApiMtermvectorsGetWithIndexRequest
*/
func (a *DefaultAPIService) MtermvectorsGetWithIndex(ctx context.Context, index string) ApiMtermvectorsGetWithIndexRequest {
	return ApiMtermvectorsGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MtermvectorsGetWithIndexExecute(r ApiMtermvectorsGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MtermvectorsGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mtermvectors"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMtermvectorsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ids *[]string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
	body *map[string]interface{}
}

// Comma-separated list of documents ids. You must define ids as parameter or set &#39;ids&#39; or &#39;docs&#39; in the request body.
func (r ApiMtermvectorsPostRequest) Ids(ids []string) ApiMtermvectorsPostRequest {
	r.ids = &ids
	return r
}

// Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostRequest) TermStatistics(termStatistics bool) ApiMtermvectorsPostRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostRequest) FieldStatistics(fieldStatistics bool) ApiMtermvectorsPostRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostRequest) Fields(fields []string) ApiMtermvectorsPostRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostRequest) Offsets(offsets bool) ApiMtermvectorsPostRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostRequest) Positions(positions bool) ApiMtermvectorsPostRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostRequest) Payloads(payloads bool) ApiMtermvectorsPostRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostRequest) Preference(preference string) ApiMtermvectorsPostRequest {
	r.preference = &preference
	return r
}

// Routing value. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostRequest) Routing(routing string) ApiMtermvectorsPostRequest {
	r.routing = &routing
	return r
}

// Specifies if requests are real-time as opposed to near-real-time.
func (r ApiMtermvectorsPostRequest) Realtime(realtime bool) ApiMtermvectorsPostRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r ApiMtermvectorsPostRequest) Version(version int32) ApiMtermvectorsPostRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiMtermvectorsPostRequest) VersionType(versionType VersionType) ApiMtermvectorsPostRequest {
	r.versionType = &versionType
	return r
}

func (r ApiMtermvectorsPostRequest) Body(body map[string]interface{}) ApiMtermvectorsPostRequest {
	r.body = &body
	return r
}

func (r ApiMtermvectorsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.MtermvectorsPostExecute(r)
}

/*
MtermvectorsPost Method for MtermvectorsPost

Returns multiple termvectors in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMtermvectorsPostRequest
*/
func (a *DefaultAPIService) MtermvectorsPost(ctx context.Context) ApiMtermvectorsPostRequest {
	return ApiMtermvectorsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MtermvectorsPostExecute(r ApiMtermvectorsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MtermvectorsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_mtermvectors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMtermvectorsPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ids *[]string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
	body *map[string]interface{}
}

// Comma-separated list of documents ids. You must define ids as parameter or set &#39;ids&#39; or &#39;docs&#39; in the request body.
func (r ApiMtermvectorsPostWithIndexRequest) Ids(ids []string) ApiMtermvectorsPostWithIndexRequest {
	r.ids = &ids
	return r
}

// Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostWithIndexRequest) TermStatistics(termStatistics bool) ApiMtermvectorsPostWithIndexRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostWithIndexRequest) FieldStatistics(fieldStatistics bool) ApiMtermvectorsPostWithIndexRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostWithIndexRequest) Fields(fields []string) ApiMtermvectorsPostWithIndexRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostWithIndexRequest) Offsets(offsets bool) ApiMtermvectorsPostWithIndexRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostWithIndexRequest) Positions(positions bool) ApiMtermvectorsPostWithIndexRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostWithIndexRequest) Payloads(payloads bool) ApiMtermvectorsPostWithIndexRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostWithIndexRequest) Preference(preference string) ApiMtermvectorsPostWithIndexRequest {
	r.preference = &preference
	return r
}

// Routing value. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r ApiMtermvectorsPostWithIndexRequest) Routing(routing string) ApiMtermvectorsPostWithIndexRequest {
	r.routing = &routing
	return r
}

// Specifies if requests are real-time as opposed to near-real-time.
func (r ApiMtermvectorsPostWithIndexRequest) Realtime(realtime bool) ApiMtermvectorsPostWithIndexRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r ApiMtermvectorsPostWithIndexRequest) Version(version int32) ApiMtermvectorsPostWithIndexRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiMtermvectorsPostWithIndexRequest) VersionType(versionType VersionType) ApiMtermvectorsPostWithIndexRequest {
	r.versionType = &versionType
	return r
}

func (r ApiMtermvectorsPostWithIndexRequest) Body(body map[string]interface{}) ApiMtermvectorsPostWithIndexRequest {
	r.body = &body
	return r
}

func (r ApiMtermvectorsPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MtermvectorsPostWithIndexExecute(r)
}

/*
MtermvectorsPostWithIndex Method for MtermvectorsPostWithIndex

Returns multiple termvectors in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The index in which the document resides.
 @return ApiMtermvectorsPostWithIndexRequest
*/
func (a *DefaultAPIService) MtermvectorsPostWithIndex(ctx context.Context, index string) ApiMtermvectorsPostWithIndexRequest {
	return ApiMtermvectorsPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MtermvectorsPostWithIndexExecute(r ApiMtermvectorsPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MtermvectorsPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mtermvectors"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesHotThreadsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r ApiNodesHotThreadsRequest) Interval(interval string) ApiNodesHotThreadsRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r ApiNodesHotThreadsRequest) Snapshots(snapshots int32) ApiNodesHotThreadsRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r ApiNodesHotThreadsRequest) Threads(threads int32) ApiNodesHotThreadsRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r ApiNodesHotThreadsRequest) IgnoreIdleThreads(ignoreIdleThreads bool) ApiNodesHotThreadsRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r ApiNodesHotThreadsRequest) Type_(type_ SampleType) ApiNodesHotThreadsRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r ApiNodesHotThreadsRequest) Timeout(timeout string) ApiNodesHotThreadsRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesHotThreadsRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsExecute(r)
}

/*
NodesHotThreads Method for NodesHotThreads

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiNodesHotThreadsRequest
*/
func (a *DefaultAPIService) NodesHotThreads(ctx context.Context) ApiNodesHotThreadsRequest {
	return ApiNodesHotThreadsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesHotThreadsExecute(r ApiNodesHotThreadsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreads")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/hot_threads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesHotThreadsDeprecatedRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r ApiNodesHotThreadsDeprecatedRequest) Interval(interval string) ApiNodesHotThreadsDeprecatedRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r ApiNodesHotThreadsDeprecatedRequest) Snapshots(snapshots int32) ApiNodesHotThreadsDeprecatedRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r ApiNodesHotThreadsDeprecatedRequest) Threads(threads int32) ApiNodesHotThreadsDeprecatedRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r ApiNodesHotThreadsDeprecatedRequest) IgnoreIdleThreads(ignoreIdleThreads bool) ApiNodesHotThreadsDeprecatedRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r ApiNodesHotThreadsDeprecatedRequest) Type_(type_ SampleType) ApiNodesHotThreadsDeprecatedRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r ApiNodesHotThreadsDeprecatedRequest) Timeout(timeout string) ApiNodesHotThreadsDeprecatedRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesHotThreadsDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsDeprecatedExecute(r)
}

/*
NodesHotThreadsDeprecated Method for NodesHotThreadsDeprecated

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiNodesHotThreadsDeprecatedRequest

Deprecated
*/
func (a *DefaultAPIService) NodesHotThreadsDeprecated(ctx context.Context) ApiNodesHotThreadsDeprecatedRequest {
	return ApiNodesHotThreadsDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) NodesHotThreadsDeprecatedExecute(r ApiNodesHotThreadsDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreadsDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/hotthreads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesHotThreadsDeprecatedClusterRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r ApiNodesHotThreadsDeprecatedClusterRequest) Interval(interval string) ApiNodesHotThreadsDeprecatedClusterRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r ApiNodesHotThreadsDeprecatedClusterRequest) Snapshots(snapshots int32) ApiNodesHotThreadsDeprecatedClusterRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r ApiNodesHotThreadsDeprecatedClusterRequest) Threads(threads int32) ApiNodesHotThreadsDeprecatedClusterRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r ApiNodesHotThreadsDeprecatedClusterRequest) IgnoreIdleThreads(ignoreIdleThreads bool) ApiNodesHotThreadsDeprecatedClusterRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r ApiNodesHotThreadsDeprecatedClusterRequest) Type_(type_ SampleType) ApiNodesHotThreadsDeprecatedClusterRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r ApiNodesHotThreadsDeprecatedClusterRequest) Timeout(timeout string) ApiNodesHotThreadsDeprecatedClusterRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesHotThreadsDeprecatedClusterRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsDeprecatedClusterExecute(r)
}

/*
NodesHotThreadsDeprecatedCluster Method for NodesHotThreadsDeprecatedCluster

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiNodesHotThreadsDeprecatedClusterRequest

Deprecated
*/
func (a *DefaultAPIService) NodesHotThreadsDeprecatedCluster(ctx context.Context) ApiNodesHotThreadsDeprecatedClusterRequest {
	return ApiNodesHotThreadsDeprecatedClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) NodesHotThreadsDeprecatedClusterExecute(r ApiNodesHotThreadsDeprecatedClusterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreadsDeprecatedCluster")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/nodes/hotthreads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesHotThreadsDeprecatedDashRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r ApiNodesHotThreadsDeprecatedDashRequest) Interval(interval string) ApiNodesHotThreadsDeprecatedDashRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r ApiNodesHotThreadsDeprecatedDashRequest) Snapshots(snapshots int32) ApiNodesHotThreadsDeprecatedDashRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r ApiNodesHotThreadsDeprecatedDashRequest) Threads(threads int32) ApiNodesHotThreadsDeprecatedDashRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r ApiNodesHotThreadsDeprecatedDashRequest) IgnoreIdleThreads(ignoreIdleThreads bool) ApiNodesHotThreadsDeprecatedDashRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r ApiNodesHotThreadsDeprecatedDashRequest) Type_(type_ SampleType) ApiNodesHotThreadsDeprecatedDashRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r ApiNodesHotThreadsDeprecatedDashRequest) Timeout(timeout string) ApiNodesHotThreadsDeprecatedDashRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesHotThreadsDeprecatedDashRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsDeprecatedDashExecute(r)
}

/*
NodesHotThreadsDeprecatedDash Method for NodesHotThreadsDeprecatedDash

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiNodesHotThreadsDeprecatedDashRequest

Deprecated
*/
func (a *DefaultAPIService) NodesHotThreadsDeprecatedDash(ctx context.Context) ApiNodesHotThreadsDeprecatedDashRequest {
	return ApiNodesHotThreadsDeprecatedDashRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) NodesHotThreadsDeprecatedDashExecute(r ApiNodesHotThreadsDeprecatedDashRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreadsDeprecatedDash")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/nodes/hot_threads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesHotThreadsWithNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r ApiNodesHotThreadsWithNodeIdRequest) Interval(interval string) ApiNodesHotThreadsWithNodeIdRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r ApiNodesHotThreadsWithNodeIdRequest) Snapshots(snapshots int32) ApiNodesHotThreadsWithNodeIdRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r ApiNodesHotThreadsWithNodeIdRequest) Threads(threads int32) ApiNodesHotThreadsWithNodeIdRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r ApiNodesHotThreadsWithNodeIdRequest) IgnoreIdleThreads(ignoreIdleThreads bool) ApiNodesHotThreadsWithNodeIdRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r ApiNodesHotThreadsWithNodeIdRequest) Type_(type_ SampleType) ApiNodesHotThreadsWithNodeIdRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r ApiNodesHotThreadsWithNodeIdRequest) Timeout(timeout string) ApiNodesHotThreadsWithNodeIdRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesHotThreadsWithNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsWithNodeIdExecute(r)
}

/*
NodesHotThreadsWithNodeId Method for NodesHotThreadsWithNodeId

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return ApiNodesHotThreadsWithNodeIdRequest
*/
func (a *DefaultAPIService) NodesHotThreadsWithNodeId(ctx context.Context, nodeId string) ApiNodesHotThreadsWithNodeIdRequest {
	return ApiNodesHotThreadsWithNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesHotThreadsWithNodeIdExecute(r ApiNodesHotThreadsWithNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreadsWithNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/hot_threads"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesHotThreadsWithNodeIdDeprecatedRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedRequest) Interval(interval string) ApiNodesHotThreadsWithNodeIdDeprecatedRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedRequest) Snapshots(snapshots int32) ApiNodesHotThreadsWithNodeIdDeprecatedRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedRequest) Threads(threads int32) ApiNodesHotThreadsWithNodeIdDeprecatedRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedRequest) IgnoreIdleThreads(ignoreIdleThreads bool) ApiNodesHotThreadsWithNodeIdDeprecatedRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedRequest) Type_(type_ SampleType) ApiNodesHotThreadsWithNodeIdDeprecatedRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedRequest) Timeout(timeout string) ApiNodesHotThreadsWithNodeIdDeprecatedRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesHotThreadsWithNodeIdDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsWithNodeIdDeprecatedExecute(r)
}

/*
NodesHotThreadsWithNodeIdDeprecated Method for NodesHotThreadsWithNodeIdDeprecated

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return ApiNodesHotThreadsWithNodeIdDeprecatedRequest

Deprecated
*/
func (a *DefaultAPIService) NodesHotThreadsWithNodeIdDeprecated(ctx context.Context, nodeId string) ApiNodesHotThreadsWithNodeIdDeprecatedRequest {
	return ApiNodesHotThreadsWithNodeIdDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) NodesHotThreadsWithNodeIdDeprecatedExecute(r ApiNodesHotThreadsWithNodeIdDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreadsWithNodeIdDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/hotthreads"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest) Interval(interval string) ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest) Snapshots(snapshots int32) ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest) Threads(threads int32) ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest) IgnoreIdleThreads(ignoreIdleThreads bool) ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest) Type_(type_ SampleType) ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest) Timeout(timeout string) ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsWithNodeIdDeprecatedClusterExecute(r)
}

/*
NodesHotThreadsWithNodeIdDeprecatedCluster Method for NodesHotThreadsWithNodeIdDeprecatedCluster

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest

Deprecated
*/
func (a *DefaultAPIService) NodesHotThreadsWithNodeIdDeprecatedCluster(ctx context.Context, nodeId string) ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest {
	return ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) NodesHotThreadsWithNodeIdDeprecatedClusterExecute(r ApiNodesHotThreadsWithNodeIdDeprecatedClusterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreadsWithNodeIdDeprecatedCluster")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/nodes/{node_id}/hotthreads"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest) Interval(interval string) ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest) Snapshots(snapshots int32) ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest) Threads(threads int32) ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest) IgnoreIdleThreads(ignoreIdleThreads bool) ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest) Type_(type_ SampleType) ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest) Timeout(timeout string) ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsWithNodeIdDeprecatedDashExecute(r)
}

/*
NodesHotThreadsWithNodeIdDeprecatedDash Method for NodesHotThreadsWithNodeIdDeprecatedDash

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest

Deprecated
*/
func (a *DefaultAPIService) NodesHotThreadsWithNodeIdDeprecatedDash(ctx context.Context, nodeId string) ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest {
	return ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) NodesHotThreadsWithNodeIdDeprecatedDashExecute(r ApiNodesHotThreadsWithNodeIdDeprecatedDashRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreadsWithNodeIdDeprecatedDash")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/nodes/{node_id}/hot_threads"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesInfoRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	flatSettings *bool
	timeout *string
}

// Return settings in flat format.
func (r ApiNodesInfoRequest) FlatSettings(flatSettings bool) ApiNodesInfoRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout.
func (r ApiNodesInfoRequest) Timeout(timeout string) ApiNodesInfoRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesInfoRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesInfoExecute(r)
}

/*
NodesInfo Method for NodesInfo

Returns information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiNodesInfoRequest
*/
func (a *DefaultAPIService) NodesInfo(ctx context.Context) ApiNodesInfoRequest {
	return ApiNodesInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesInfoExecute(r ApiNodesInfoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesInfo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesInfoWithMetricNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	metric string
	flatSettings *bool
	timeout *string
}

// Return settings in flat format.
func (r ApiNodesInfoWithMetricNodeIdRequest) FlatSettings(flatSettings bool) ApiNodesInfoWithMetricNodeIdRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout.
func (r ApiNodesInfoWithMetricNodeIdRequest) Timeout(timeout string) ApiNodesInfoWithMetricNodeIdRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesInfoWithMetricNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesInfoWithMetricNodeIdExecute(r)
}

/*
NodesInfoWithMetricNodeId Method for NodesInfoWithMetricNodeId

Returns information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @param metric Comma-separated list of metrics you wish returned. Leave empty to return all.
 @return ApiNodesInfoWithMetricNodeIdRequest
*/
func (a *DefaultAPIService) NodesInfoWithMetricNodeId(ctx context.Context, nodeId string, metric string) ApiNodesInfoWithMetricNodeIdRequest {
	return ApiNodesInfoWithMetricNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
		metric: metric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesInfoWithMetricNodeIdExecute(r ApiNodesInfoWithMetricNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesInfoWithMetricNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesInfoWithNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	flatSettings *bool
	timeout *string
}

// Return settings in flat format.
func (r ApiNodesInfoWithNodeIdRequest) FlatSettings(flatSettings bool) ApiNodesInfoWithNodeIdRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout.
func (r ApiNodesInfoWithNodeIdRequest) Timeout(timeout string) ApiNodesInfoWithNodeIdRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesInfoWithNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesInfoWithNodeIdExecute(r)
}

/*
NodesInfoWithNodeId Method for NodesInfoWithNodeId

Returns information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return ApiNodesInfoWithNodeIdRequest
*/
func (a *DefaultAPIService) NodesInfoWithNodeId(ctx context.Context, nodeId string) ApiNodesInfoWithNodeIdRequest {
	return ApiNodesInfoWithNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesInfoWithNodeIdExecute(r ApiNodesInfoWithNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesInfoWithNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesReloadSecureSettingsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	timeout *string
	body *map[string]interface{}
}

// Operation timeout.
func (r ApiNodesReloadSecureSettingsRequest) Timeout(timeout string) ApiNodesReloadSecureSettingsRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesReloadSecureSettingsRequest) Body(body map[string]interface{}) ApiNodesReloadSecureSettingsRequest {
	r.body = &body
	return r
}

func (r ApiNodesReloadSecureSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesReloadSecureSettingsExecute(r)
}

/*
NodesReloadSecureSettings Method for NodesReloadSecureSettings

Reloads secure settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiNodesReloadSecureSettingsRequest
*/
func (a *DefaultAPIService) NodesReloadSecureSettings(ctx context.Context) ApiNodesReloadSecureSettingsRequest {
	return ApiNodesReloadSecureSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesReloadSecureSettingsExecute(r ApiNodesReloadSecureSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesReloadSecureSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/reload_secure_settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesReloadSecureSettingsWithNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	timeout *string
	body *map[string]interface{}
}

// Operation timeout.
func (r ApiNodesReloadSecureSettingsWithNodeIdRequest) Timeout(timeout string) ApiNodesReloadSecureSettingsWithNodeIdRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesReloadSecureSettingsWithNodeIdRequest) Body(body map[string]interface{}) ApiNodesReloadSecureSettingsWithNodeIdRequest {
	r.body = &body
	return r
}

func (r ApiNodesReloadSecureSettingsWithNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesReloadSecureSettingsWithNodeIdExecute(r)
}

/*
NodesReloadSecureSettingsWithNodeId Method for NodesReloadSecureSettingsWithNodeId

Reloads secure settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs to span the reload/reinit call. Should stay empty because reloading usually involves all cluster nodes.
 @return ApiNodesReloadSecureSettingsWithNodeIdRequest
*/
func (a *DefaultAPIService) NodesReloadSecureSettingsWithNodeId(ctx context.Context, nodeId string) ApiNodesReloadSecureSettingsWithNodeIdRequest {
	return ApiNodesReloadSecureSettingsWithNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesReloadSecureSettingsWithNodeIdExecute(r ApiNodesReloadSecureSettingsWithNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesReloadSecureSettingsWithNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/reload_secure_settings"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesStatsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *NodesStatLevel
	types *[]string
	timeout *string
	includeSegmentFileSizes *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r ApiNodesStatsRequest) CompletionFields(completionFields []string) ApiNodesStatsRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r ApiNodesStatsRequest) FielddataFields(fielddataFields []string) ApiNodesStatsRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r ApiNodesStatsRequest) Fields(fields []string) ApiNodesStatsRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r ApiNodesStatsRequest) Groups(groups []string) ApiNodesStatsRequest {
	r.groups = &groups
	return r
}

// Return indices stats aggregated at index, node or shard level.
func (r ApiNodesStatsRequest) Level(level NodesStatLevel) ApiNodesStatsRequest {
	r.level = &level
	return r
}

// Comma-separated list of document types for the &#x60;indexing&#x60; index metric.
func (r ApiNodesStatsRequest) Types(types []string) ApiNodesStatsRequest {
	r.types = &types
	return r
}

// Operation timeout.
func (r ApiNodesStatsRequest) Timeout(timeout string) ApiNodesStatsRequest {
	r.timeout = &timeout
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r ApiNodesStatsRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) ApiNodesStatsRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

func (r ApiNodesStatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesStatsExecute(r)
}

/*
NodesStats Method for NodesStats

Returns statistical information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiNodesStatsRequest
*/
func (a *DefaultAPIService) NodesStats(ctx context.Context) ApiNodesStatsRequest {
	return ApiNodesStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesStatsExecute(r ApiNodesStatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesStats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesStatsWithIndexMetricMetricRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	indexMetric string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *NodesStatLevel
	types *[]string
	timeout *string
	includeSegmentFileSizes *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithIndexMetricMetricRequest) CompletionFields(completionFields []string) ApiNodesStatsWithIndexMetricMetricRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithIndexMetricMetricRequest) FielddataFields(fielddataFields []string) ApiNodesStatsWithIndexMetricMetricRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithIndexMetricMetricRequest) Fields(fields []string) ApiNodesStatsWithIndexMetricMetricRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r ApiNodesStatsWithIndexMetricMetricRequest) Groups(groups []string) ApiNodesStatsWithIndexMetricMetricRequest {
	r.groups = &groups
	return r
}

// Return indices stats aggregated at index, node or shard level.
func (r ApiNodesStatsWithIndexMetricMetricRequest) Level(level NodesStatLevel) ApiNodesStatsWithIndexMetricMetricRequest {
	r.level = &level
	return r
}

// Comma-separated list of document types for the &#x60;indexing&#x60; index metric.
func (r ApiNodesStatsWithIndexMetricMetricRequest) Types(types []string) ApiNodesStatsWithIndexMetricMetricRequest {
	r.types = &types
	return r
}

// Operation timeout.
func (r ApiNodesStatsWithIndexMetricMetricRequest) Timeout(timeout string) ApiNodesStatsWithIndexMetricMetricRequest {
	r.timeout = &timeout
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r ApiNodesStatsWithIndexMetricMetricRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) ApiNodesStatsWithIndexMetricMetricRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

func (r ApiNodesStatsWithIndexMetricMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesStatsWithIndexMetricMetricExecute(r)
}

/*
NodesStatsWithIndexMetricMetric Method for NodesStatsWithIndexMetricMetric

Returns statistical information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned to the specified metrics.
 @param indexMetric Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
 @return ApiNodesStatsWithIndexMetricMetricRequest
*/
func (a *DefaultAPIService) NodesStatsWithIndexMetricMetric(ctx context.Context, metric string, indexMetric string) ApiNodesStatsWithIndexMetricMetricRequest {
	return ApiNodesStatsWithIndexMetricMetricRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
		indexMetric: indexMetric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesStatsWithIndexMetricMetricExecute(r ApiNodesStatsWithIndexMetricMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesStatsWithIndexMetricMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/stats/{metric}/{index_metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index_metric"+"}", url.PathEscape(parameterValueToString(r.indexMetric, "indexMetric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesStatsWithIndexMetricMetricNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	indexMetric string
	nodeId string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *NodesStatLevel
	types *[]string
	timeout *string
	includeSegmentFileSizes *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithIndexMetricMetricNodeIdRequest) CompletionFields(completionFields []string) ApiNodesStatsWithIndexMetricMetricNodeIdRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithIndexMetricMetricNodeIdRequest) FielddataFields(fielddataFields []string) ApiNodesStatsWithIndexMetricMetricNodeIdRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithIndexMetricMetricNodeIdRequest) Fields(fields []string) ApiNodesStatsWithIndexMetricMetricNodeIdRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r ApiNodesStatsWithIndexMetricMetricNodeIdRequest) Groups(groups []string) ApiNodesStatsWithIndexMetricMetricNodeIdRequest {
	r.groups = &groups
	return r
}

// Return indices stats aggregated at index, node or shard level.
func (r ApiNodesStatsWithIndexMetricMetricNodeIdRequest) Level(level NodesStatLevel) ApiNodesStatsWithIndexMetricMetricNodeIdRequest {
	r.level = &level
	return r
}

// Comma-separated list of document types for the &#x60;indexing&#x60; index metric.
func (r ApiNodesStatsWithIndexMetricMetricNodeIdRequest) Types(types []string) ApiNodesStatsWithIndexMetricMetricNodeIdRequest {
	r.types = &types
	return r
}

// Operation timeout.
func (r ApiNodesStatsWithIndexMetricMetricNodeIdRequest) Timeout(timeout string) ApiNodesStatsWithIndexMetricMetricNodeIdRequest {
	r.timeout = &timeout
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r ApiNodesStatsWithIndexMetricMetricNodeIdRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) ApiNodesStatsWithIndexMetricMetricNodeIdRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

func (r ApiNodesStatsWithIndexMetricMetricNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesStatsWithIndexMetricMetricNodeIdExecute(r)
}

/*
NodesStatsWithIndexMetricMetricNodeId Method for NodesStatsWithIndexMetricMetricNodeId

Returns statistical information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned to the specified metrics.
 @param indexMetric Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return ApiNodesStatsWithIndexMetricMetricNodeIdRequest
*/
func (a *DefaultAPIService) NodesStatsWithIndexMetricMetricNodeId(ctx context.Context, metric string, indexMetric string, nodeId string) ApiNodesStatsWithIndexMetricMetricNodeIdRequest {
	return ApiNodesStatsWithIndexMetricMetricNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
		indexMetric: indexMetric,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesStatsWithIndexMetricMetricNodeIdExecute(r ApiNodesStatsWithIndexMetricMetricNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesStatsWithIndexMetricMetricNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/stats/{metric}/{index_metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index_metric"+"}", url.PathEscape(parameterValueToString(r.indexMetric, "indexMetric")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesStatsWithMetricRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *NodesStatLevel
	types *[]string
	timeout *string
	includeSegmentFileSizes *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithMetricRequest) CompletionFields(completionFields []string) ApiNodesStatsWithMetricRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithMetricRequest) FielddataFields(fielddataFields []string) ApiNodesStatsWithMetricRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithMetricRequest) Fields(fields []string) ApiNodesStatsWithMetricRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r ApiNodesStatsWithMetricRequest) Groups(groups []string) ApiNodesStatsWithMetricRequest {
	r.groups = &groups
	return r
}

// Return indices stats aggregated at index, node or shard level.
func (r ApiNodesStatsWithMetricRequest) Level(level NodesStatLevel) ApiNodesStatsWithMetricRequest {
	r.level = &level
	return r
}

// Comma-separated list of document types for the &#x60;indexing&#x60; index metric.
func (r ApiNodesStatsWithMetricRequest) Types(types []string) ApiNodesStatsWithMetricRequest {
	r.types = &types
	return r
}

// Operation timeout.
func (r ApiNodesStatsWithMetricRequest) Timeout(timeout string) ApiNodesStatsWithMetricRequest {
	r.timeout = &timeout
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r ApiNodesStatsWithMetricRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) ApiNodesStatsWithMetricRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

func (r ApiNodesStatsWithMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesStatsWithMetricExecute(r)
}

/*
NodesStatsWithMetric Method for NodesStatsWithMetric

Returns statistical information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned to the specified metrics.
 @return ApiNodesStatsWithMetricRequest
*/
func (a *DefaultAPIService) NodesStatsWithMetric(ctx context.Context, metric string) ApiNodesStatsWithMetricRequest {
	return ApiNodesStatsWithMetricRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesStatsWithMetricExecute(r ApiNodesStatsWithMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesStatsWithMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/stats/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesStatsWithMetricNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	nodeId string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *NodesStatLevel
	types *[]string
	timeout *string
	includeSegmentFileSizes *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithMetricNodeIdRequest) CompletionFields(completionFields []string) ApiNodesStatsWithMetricNodeIdRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithMetricNodeIdRequest) FielddataFields(fielddataFields []string) ApiNodesStatsWithMetricNodeIdRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithMetricNodeIdRequest) Fields(fields []string) ApiNodesStatsWithMetricNodeIdRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r ApiNodesStatsWithMetricNodeIdRequest) Groups(groups []string) ApiNodesStatsWithMetricNodeIdRequest {
	r.groups = &groups
	return r
}

// Return indices stats aggregated at index, node or shard level.
func (r ApiNodesStatsWithMetricNodeIdRequest) Level(level NodesStatLevel) ApiNodesStatsWithMetricNodeIdRequest {
	r.level = &level
	return r
}

// Comma-separated list of document types for the &#x60;indexing&#x60; index metric.
func (r ApiNodesStatsWithMetricNodeIdRequest) Types(types []string) ApiNodesStatsWithMetricNodeIdRequest {
	r.types = &types
	return r
}

// Operation timeout.
func (r ApiNodesStatsWithMetricNodeIdRequest) Timeout(timeout string) ApiNodesStatsWithMetricNodeIdRequest {
	r.timeout = &timeout
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r ApiNodesStatsWithMetricNodeIdRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) ApiNodesStatsWithMetricNodeIdRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

func (r ApiNodesStatsWithMetricNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesStatsWithMetricNodeIdExecute(r)
}

/*
NodesStatsWithMetricNodeId Method for NodesStatsWithMetricNodeId

Returns statistical information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned to the specified metrics.
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return ApiNodesStatsWithMetricNodeIdRequest
*/
func (a *DefaultAPIService) NodesStatsWithMetricNodeId(ctx context.Context, metric string, nodeId string) ApiNodesStatsWithMetricNodeIdRequest {
	return ApiNodesStatsWithMetricNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesStatsWithMetricNodeIdExecute(r ApiNodesStatsWithMetricNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesStatsWithMetricNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/stats/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesStatsWithNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *NodesStatLevel
	types *[]string
	timeout *string
	includeSegmentFileSizes *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithNodeIdRequest) CompletionFields(completionFields []string) ApiNodesStatsWithNodeIdRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithNodeIdRequest) FielddataFields(fielddataFields []string) ApiNodesStatsWithNodeIdRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r ApiNodesStatsWithNodeIdRequest) Fields(fields []string) ApiNodesStatsWithNodeIdRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r ApiNodesStatsWithNodeIdRequest) Groups(groups []string) ApiNodesStatsWithNodeIdRequest {
	r.groups = &groups
	return r
}

// Return indices stats aggregated at index, node or shard level.
func (r ApiNodesStatsWithNodeIdRequest) Level(level NodesStatLevel) ApiNodesStatsWithNodeIdRequest {
	r.level = &level
	return r
}

// Comma-separated list of document types for the &#x60;indexing&#x60; index metric.
func (r ApiNodesStatsWithNodeIdRequest) Types(types []string) ApiNodesStatsWithNodeIdRequest {
	r.types = &types
	return r
}

// Operation timeout.
func (r ApiNodesStatsWithNodeIdRequest) Timeout(timeout string) ApiNodesStatsWithNodeIdRequest {
	r.timeout = &timeout
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r ApiNodesStatsWithNodeIdRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) ApiNodesStatsWithNodeIdRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

func (r ApiNodesStatsWithNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesStatsWithNodeIdExecute(r)
}

/*
NodesStatsWithNodeId Method for NodesStatsWithNodeId

Returns statistical information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return ApiNodesStatsWithNodeIdRequest
*/
func (a *DefaultAPIService) NodesStatsWithNodeId(ctx context.Context, nodeId string) ApiNodesStatsWithNodeIdRequest {
	return ApiNodesStatsWithNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesStatsWithNodeIdExecute(r ApiNodesStatsWithNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesStatsWithNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesUsageRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	timeout *string
}

// Operation timeout.
func (r ApiNodesUsageRequest) Timeout(timeout string) ApiNodesUsageRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesUsageRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesUsageExecute(r)
}

/*
NodesUsage Method for NodesUsage

Returns low-level information about REST actions usage on nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiNodesUsageRequest
*/
func (a *DefaultAPIService) NodesUsage(ctx context.Context) ApiNodesUsageRequest {
	return ApiNodesUsageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesUsageExecute(r ApiNodesUsageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesUsage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesUsageWithMetricRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	timeout *string
}

// Operation timeout.
func (r ApiNodesUsageWithMetricRequest) Timeout(timeout string) ApiNodesUsageWithMetricRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesUsageWithMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesUsageWithMetricExecute(r)
}

/*
NodesUsageWithMetric Method for NodesUsageWithMetric

Returns low-level information about REST actions usage on nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned to the specified metrics.
 @return ApiNodesUsageWithMetricRequest
*/
func (a *DefaultAPIService) NodesUsageWithMetric(ctx context.Context, metric string) ApiNodesUsageWithMetricRequest {
	return ApiNodesUsageWithMetricRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesUsageWithMetricExecute(r ApiNodesUsageWithMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesUsageWithMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/usage/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesUsageWithMetricNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	nodeId string
	timeout *string
}

// Operation timeout.
func (r ApiNodesUsageWithMetricNodeIdRequest) Timeout(timeout string) ApiNodesUsageWithMetricNodeIdRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesUsageWithMetricNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesUsageWithMetricNodeIdExecute(r)
}

/*
NodesUsageWithMetricNodeId Method for NodesUsageWithMetricNodeId

Returns low-level information about REST actions usage on nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned to the specified metrics.
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return ApiNodesUsageWithMetricNodeIdRequest
*/
func (a *DefaultAPIService) NodesUsageWithMetricNodeId(ctx context.Context, metric string, nodeId string) ApiNodesUsageWithMetricNodeIdRequest {
	return ApiNodesUsageWithMetricNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesUsageWithMetricNodeIdExecute(r ApiNodesUsageWithMetricNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesUsageWithMetricNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/usage/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNodesUsageWithNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	timeout *string
}

// Operation timeout.
func (r ApiNodesUsageWithNodeIdRequest) Timeout(timeout string) ApiNodesUsageWithNodeIdRequest {
	r.timeout = &timeout
	return r
}

func (r ApiNodesUsageWithNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesUsageWithNodeIdExecute(r)
}

/*
NodesUsageWithNodeId Method for NodesUsageWithNodeId

Returns low-level information about REST actions usage on nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return ApiNodesUsageWithNodeIdRequest
*/
func (a *DefaultAPIService) NodesUsageWithNodeId(ctx context.Context, nodeId string) ApiNodesUsageWithNodeIdRequest {
	return ApiNodesUsageWithNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesUsageWithNodeIdExecute(r ApiNodesUsageWithNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesUsageWithNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/usage"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPatchActionGroupRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	actionGroup string
	patchOperation *[]PatchOperation
}

func (r ApiPatchActionGroupRequest) PatchOperation(patchOperation []PatchOperation) ApiPatchActionGroupRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r ApiPatchActionGroupRequest) Execute() (*PatchActionGroupResponseContent, *http.Response, error) {
	return r.ApiService.PatchActionGroupExecute(r)
}

/*
PatchActionGroup Method for PatchActionGroup

Updates individual attributes of an action group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionGroup
 @return ApiPatchActionGroupRequest
*/
func (a *DefaultAPIService) PatchActionGroup(ctx context.Context, actionGroup string) ApiPatchActionGroupRequest {
	return ApiPatchActionGroupRequest{
		ApiService: a,
		ctx: ctx,
		actionGroup: actionGroup,
	}
}

// Execute executes the request
//  @return PatchActionGroupResponseContent
func (a *DefaultAPIService) PatchActionGroupExecute(r ApiPatchActionGroupRequest) (*PatchActionGroupResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchActionGroupResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchActionGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/actiongroups/{action_group}"
	localVarPath = strings.Replace(localVarPath, "{"+"action_group"+"}", url.PathEscape(parameterValueToString(r.actionGroup, "actionGroup")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchActionGroupsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r ApiPatchActionGroupsRequest) PatchOperation(patchOperation []PatchOperation) ApiPatchActionGroupsRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r ApiPatchActionGroupsRequest) Execute() (*PatchActionGroupsResponseContent, *http.Response, error) {
	return r.ApiService.PatchActionGroupsExecute(r)
}

/*
PatchActionGroups Method for PatchActionGroups

Creates, updates, or deletes multiple action groups in a single call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchActionGroupsRequest
*/
func (a *DefaultAPIService) PatchActionGroups(ctx context.Context) ApiPatchActionGroupsRequest {
	return ApiPatchActionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchActionGroupsResponseContent
func (a *DefaultAPIService) PatchActionGroupsExecute(r ApiPatchActionGroupsRequest) (*PatchActionGroupsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchActionGroupsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchActionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/actiongroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchAuditConfigurationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r ApiPatchAuditConfigurationRequest) PatchOperation(patchOperation []PatchOperation) ApiPatchAuditConfigurationRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r ApiPatchAuditConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.PatchAuditConfigurationExecute(r)
}

/*
PatchAuditConfiguration Method for PatchAuditConfiguration

A PATCH call is used to update specified fields in the audit configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchAuditConfigurationRequest
*/
func (a *DefaultAPIService) PatchAuditConfiguration(ctx context.Context) ApiPatchAuditConfigurationRequest {
	return ApiPatchAuditConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PatchAuditConfigurationExecute(r ApiPatchAuditConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchAuditConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/audit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPatchConfigurationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r ApiPatchConfigurationRequest) PatchOperation(patchOperation []PatchOperation) ApiPatchConfigurationRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r ApiPatchConfigurationRequest) Execute() (*PatchConfigurationResponseContent, *http.Response, error) {
	return r.ApiService.PatchConfigurationExecute(r)
}

/*
PatchConfiguration Method for PatchConfiguration

A PATCH call is used to update the existing configuration using the REST API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchConfigurationRequest
*/
func (a *DefaultAPIService) PatchConfiguration(ctx context.Context) ApiPatchConfigurationRequest {
	return ApiPatchConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchConfigurationResponseContent
func (a *DefaultAPIService) PatchConfigurationExecute(r ApiPatchConfigurationRequest) (*PatchConfigurationResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchConfigurationResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/securityconfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDistinguishedNamesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r ApiPatchDistinguishedNamesRequest) PatchOperation(patchOperation []PatchOperation) ApiPatchDistinguishedNamesRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r ApiPatchDistinguishedNamesRequest) Execute() (*PatchDistinguishedNamesResponseContent, *http.Response, error) {
	return r.ApiService.PatchDistinguishedNamesExecute(r)
}

/*
PatchDistinguishedNames Method for PatchDistinguishedNames

Bulk update of distinguished names.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchDistinguishedNamesRequest
*/
func (a *DefaultAPIService) PatchDistinguishedNames(ctx context.Context) ApiPatchDistinguishedNamesRequest {
	return ApiPatchDistinguishedNamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchDistinguishedNamesResponseContent
func (a *DefaultAPIService) PatchDistinguishedNamesExecute(r ApiPatchDistinguishedNamesRequest) (*PatchDistinguishedNamesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchDistinguishedNamesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchDistinguishedNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/nodesdn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchRoleRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
	patchOperation *[]PatchOperation
}

func (r ApiPatchRoleRequest) PatchOperation(patchOperation []PatchOperation) ApiPatchRoleRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r ApiPatchRoleRequest) Execute() (*PatchRoleResponseContent, *http.Response, error) {
	return r.ApiService.PatchRoleExecute(r)
}

/*
PatchRole Method for PatchRole

Updates individual attributes of a role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return ApiPatchRoleRequest
*/
func (a *DefaultAPIService) PatchRole(ctx context.Context, role string) ApiPatchRoleRequest {
	return ApiPatchRoleRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return PatchRoleResponseContent
func (a *DefaultAPIService) PatchRoleExecute(r ApiPatchRoleRequest) (*PatchRoleResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchRoleResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/roles/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchRoleMappingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
	patchOperation *[]PatchOperation
}

func (r ApiPatchRoleMappingRequest) PatchOperation(patchOperation []PatchOperation) ApiPatchRoleMappingRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r ApiPatchRoleMappingRequest) Execute() (*PatchRoleMappingResponseContent, *http.Response, error) {
	return r.ApiService.PatchRoleMappingExecute(r)
}

/*
PatchRoleMapping Method for PatchRoleMapping

Updates individual attributes of a role mapping.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return ApiPatchRoleMappingRequest
*/
func (a *DefaultAPIService) PatchRoleMapping(ctx context.Context, role string) ApiPatchRoleMappingRequest {
	return ApiPatchRoleMappingRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return PatchRoleMappingResponseContent
func (a *DefaultAPIService) PatchRoleMappingExecute(r ApiPatchRoleMappingRequest) (*PatchRoleMappingResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchRoleMappingResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchRoleMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/rolesmapping/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchRoleMappingsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r ApiPatchRoleMappingsRequest) PatchOperation(patchOperation []PatchOperation) ApiPatchRoleMappingsRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r ApiPatchRoleMappingsRequest) Execute() (*PatchRoleMappingsResponseContent, *http.Response, error) {
	return r.ApiService.PatchRoleMappingsExecute(r)
}

/*
PatchRoleMappings Method for PatchRoleMappings

Creates or updates multiple role mappings in a single call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchRoleMappingsRequest
*/
func (a *DefaultAPIService) PatchRoleMappings(ctx context.Context) ApiPatchRoleMappingsRequest {
	return ApiPatchRoleMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchRoleMappingsResponseContent
func (a *DefaultAPIService) PatchRoleMappingsExecute(r ApiPatchRoleMappingsRequest) (*PatchRoleMappingsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchRoleMappingsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchRoleMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/rolesmapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchRolesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r ApiPatchRolesRequest) PatchOperation(patchOperation []PatchOperation) ApiPatchRolesRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r ApiPatchRolesRequest) Execute() (*PatchRolesResponseContent, *http.Response, error) {
	return r.ApiService.PatchRolesExecute(r)
}

/*
PatchRoles Method for PatchRoles

Creates, updates, or deletes multiple roles in a single call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchRolesRequest
*/
func (a *DefaultAPIService) PatchRoles(ctx context.Context) ApiPatchRolesRequest {
	return ApiPatchRolesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchRolesResponseContent
func (a *DefaultAPIService) PatchRolesExecute(r ApiPatchRolesRequest) (*PatchRolesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchRolesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchTenantRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	tenant string
	patchOperation *[]PatchOperation
}

func (r ApiPatchTenantRequest) PatchOperation(patchOperation []PatchOperation) ApiPatchTenantRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r ApiPatchTenantRequest) Execute() (*PatchTenantResponseContent, *http.Response, error) {
	return r.ApiService.PatchTenantExecute(r)
}

/*
PatchTenant Method for PatchTenant

Add, delete, or modify a single tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @return ApiPatchTenantRequest
*/
func (a *DefaultAPIService) PatchTenant(ctx context.Context, tenant string) ApiPatchTenantRequest {
	return ApiPatchTenantRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
	}
}

// Execute executes the request
//  @return PatchTenantResponseContent
func (a *DefaultAPIService) PatchTenantExecute(r ApiPatchTenantRequest) (*PatchTenantResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchTenantResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchTenant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/tenants/{tenant}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchTenantsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r ApiPatchTenantsRequest) PatchOperation(patchOperation []PatchOperation) ApiPatchTenantsRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r ApiPatchTenantsRequest) Execute() (*PatchTenantsResponseContent, *http.Response, error) {
	return r.ApiService.PatchTenantsExecute(r)
}

/*
PatchTenants Method for PatchTenants

Add, delete, or modify multiple tenants in a single call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchTenantsRequest
*/
func (a *DefaultAPIService) PatchTenants(ctx context.Context) ApiPatchTenantsRequest {
	return ApiPatchTenantsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchTenantsResponseContent
func (a *DefaultAPIService) PatchTenantsExecute(r ApiPatchTenantsRequest) (*PatchTenantsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchTenantsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchTenants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/tenants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchUserRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	username string
	patchOperation *[]PatchOperation
}

func (r ApiPatchUserRequest) PatchOperation(patchOperation []PatchOperation) ApiPatchUserRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r ApiPatchUserRequest) Execute() (*PatchUserResponseContent, *http.Response, error) {
	return r.ApiService.PatchUserExecute(r)
}

/*
PatchUser Method for PatchUser

Updates individual attributes of an internal user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username
 @return ApiPatchUserRequest
*/
func (a *DefaultAPIService) PatchUser(ctx context.Context, username string) ApiPatchUserRequest {
	return ApiPatchUserRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return PatchUserResponseContent
func (a *DefaultAPIService) PatchUserExecute(r ApiPatchUserRequest) (*PatchUserResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchUserResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/internalusers/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterValueToString(r.username, "username")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchUsersRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r ApiPatchUsersRequest) PatchOperation(patchOperation []PatchOperation) ApiPatchUsersRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r ApiPatchUsersRequest) Execute() (*PatchUsersResponseContent, *http.Response, error) {
	return r.ApiService.PatchUsersExecute(r)
}

/*
PatchUsers Method for PatchUsers

Creates, updates, or deletes multiple internal users in a single call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchUsersRequest
*/
func (a *DefaultAPIService) PatchUsers(ctx context.Context) ApiPatchUsersRequest {
	return ApiPatchUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchUsersResponseContent
func (a *DefaultAPIService) PatchUsersExecute(r ApiPatchUsersRequest) (*PatchUsersResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchUsersResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/internalusers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiPingRequest) Execute() (*http.Response, error) {
	return r.ApiService.PingExecute(r)
}

/*
Ping Method for Ping

Returns whether the cluster is running.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPingRequest
*/
func (a *DefaultAPIService) Ping(ctx context.Context) ApiPingRequest {
	return ApiPingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PingExecute(r ApiPingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Ping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutScriptPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	body *map[string]interface{}
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r ApiPutScriptPostRequest) Body(body map[string]interface{}) ApiPutScriptPostRequest {
	r.body = &body
	return r
}

// Operation timeout.
func (r ApiPutScriptPostRequest) Timeout(timeout string) ApiPutScriptPostRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiPutScriptPostRequest) MasterTimeout(masterTimeout string) ApiPutScriptPostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiPutScriptPostRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiPutScriptPostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiPutScriptPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutScriptPostExecute(r)
}

/*
PutScriptPost Method for PutScriptPost

Creates or updates a script.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Script ID.
 @return ApiPutScriptPostRequest
*/
func (a *DefaultAPIService) PutScriptPost(ctx context.Context, id string) ApiPutScriptPostRequest {
	return ApiPutScriptPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PutScriptPostExecute(r ApiPutScriptPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PutScriptPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutScriptPostWithContextRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	context string
	body *map[string]interface{}
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r ApiPutScriptPostWithContextRequest) Body(body map[string]interface{}) ApiPutScriptPostWithContextRequest {
	r.body = &body
	return r
}

// Operation timeout.
func (r ApiPutScriptPostWithContextRequest) Timeout(timeout string) ApiPutScriptPostWithContextRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiPutScriptPostWithContextRequest) MasterTimeout(masterTimeout string) ApiPutScriptPostWithContextRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiPutScriptPostWithContextRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiPutScriptPostWithContextRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiPutScriptPostWithContextRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutScriptPostWithContextExecute(r)
}

/*
PutScriptPostWithContext Method for PutScriptPostWithContext

Creates or updates a script.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Script ID.
 @param context Script context.
 @return ApiPutScriptPostWithContextRequest
*/
func (a *DefaultAPIService) PutScriptPostWithContext(ctx context.Context, id string, context string) ApiPutScriptPostWithContextRequest {
	return ApiPutScriptPostWithContextRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		context: context,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PutScriptPostWithContextExecute(r ApiPutScriptPostWithContextRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PutScriptPostWithContext")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/{id}/{context}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"context"+"}", url.PathEscape(parameterValueToString(r.context, "context")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutScriptPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	body *map[string]interface{}
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r ApiPutScriptPutRequest) Body(body map[string]interface{}) ApiPutScriptPutRequest {
	r.body = &body
	return r
}

// Operation timeout.
func (r ApiPutScriptPutRequest) Timeout(timeout string) ApiPutScriptPutRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiPutScriptPutRequest) MasterTimeout(masterTimeout string) ApiPutScriptPutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiPutScriptPutRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiPutScriptPutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiPutScriptPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutScriptPutExecute(r)
}

/*
PutScriptPut Method for PutScriptPut

Creates or updates a script.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Script ID.
 @return ApiPutScriptPutRequest
*/
func (a *DefaultAPIService) PutScriptPut(ctx context.Context, id string) ApiPutScriptPutRequest {
	return ApiPutScriptPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PutScriptPutExecute(r ApiPutScriptPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PutScriptPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutScriptPutWithContextRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	context string
	body *map[string]interface{}
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r ApiPutScriptPutWithContextRequest) Body(body map[string]interface{}) ApiPutScriptPutWithContextRequest {
	r.body = &body
	return r
}

// Operation timeout.
func (r ApiPutScriptPutWithContextRequest) Timeout(timeout string) ApiPutScriptPutWithContextRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r ApiPutScriptPutWithContextRequest) MasterTimeout(masterTimeout string) ApiPutScriptPutWithContextRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiPutScriptPutWithContextRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiPutScriptPutWithContextRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiPutScriptPutWithContextRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutScriptPutWithContextExecute(r)
}

/*
PutScriptPutWithContext Method for PutScriptPutWithContext

Creates or updates a script.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Script ID.
 @param context Script context.
 @return ApiPutScriptPutWithContextRequest
*/
func (a *DefaultAPIService) PutScriptPutWithContext(ctx context.Context, id string, context string) ApiPutScriptPutWithContextRequest {
	return ApiPutScriptPutWithContextRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		context: context,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PutScriptPutWithContextExecute(r ApiPutScriptPutWithContextRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PutScriptPutWithContext")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/{id}/{context}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"context"+"}", url.PathEscape(parameterValueToString(r.context, "context")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRankEvalGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	searchType *SearchType
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiRankEvalGetRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiRankEvalGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiRankEvalGetRequest) AllowNoIndices(allowNoIndices bool) ApiRankEvalGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiRankEvalGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiRankEvalGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Search operation type.
func (r ApiRankEvalGetRequest) SearchType(searchType SearchType) ApiRankEvalGetRequest {
	r.searchType = &searchType
	return r
}

func (r ApiRankEvalGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.RankEvalGetExecute(r)
}

/*
RankEvalGet Method for RankEvalGet

Allows to evaluate the quality of ranked search results over a set of typical search queries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRankEvalGetRequest
*/
func (a *DefaultAPIService) RankEvalGet(ctx context.Context) ApiRankEvalGetRequest {
	return ApiRankEvalGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RankEvalGetExecute(r ApiRankEvalGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RankEvalGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_rank_eval"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRankEvalGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	searchType *SearchType
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiRankEvalGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiRankEvalGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiRankEvalGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiRankEvalGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiRankEvalGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiRankEvalGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Search operation type.
func (r ApiRankEvalGetWithIndexRequest) SearchType(searchType SearchType) ApiRankEvalGetWithIndexRequest {
	r.searchType = &searchType
	return r
}

func (r ApiRankEvalGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.RankEvalGetWithIndexExecute(r)
}

/*
RankEvalGetWithIndex Method for RankEvalGetWithIndex

Allows to evaluate the quality of ranked search results over a set of typical search queries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiRankEvalGetWithIndexRequest
*/
func (a *DefaultAPIService) RankEvalGetWithIndex(ctx context.Context, index string) ApiRankEvalGetWithIndexRequest {
	return ApiRankEvalGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RankEvalGetWithIndexExecute(r ApiRankEvalGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RankEvalGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_rank_eval"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRankEvalPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	searchType *SearchType
}

func (r ApiRankEvalPostRequest) Body(body map[string]interface{}) ApiRankEvalPostRequest {
	r.body = &body
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiRankEvalPostRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiRankEvalPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiRankEvalPostRequest) AllowNoIndices(allowNoIndices bool) ApiRankEvalPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiRankEvalPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiRankEvalPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Search operation type.
func (r ApiRankEvalPostRequest) SearchType(searchType SearchType) ApiRankEvalPostRequest {
	r.searchType = &searchType
	return r
}

func (r ApiRankEvalPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.RankEvalPostExecute(r)
}

/*
RankEvalPost Method for RankEvalPost

Allows to evaluate the quality of ranked search results over a set of typical search queries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRankEvalPostRequest
*/
func (a *DefaultAPIService) RankEvalPost(ctx context.Context) ApiRankEvalPostRequest {
	return ApiRankEvalPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RankEvalPostExecute(r ApiRankEvalPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RankEvalPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_rank_eval"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRankEvalPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	searchType *SearchType
}

func (r ApiRankEvalPostWithIndexRequest) Body(body map[string]interface{}) ApiRankEvalPostWithIndexRequest {
	r.body = &body
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiRankEvalPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiRankEvalPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiRankEvalPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiRankEvalPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiRankEvalPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiRankEvalPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Search operation type.
func (r ApiRankEvalPostWithIndexRequest) SearchType(searchType SearchType) ApiRankEvalPostWithIndexRequest {
	r.searchType = &searchType
	return r
}

func (r ApiRankEvalPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.RankEvalPostWithIndexExecute(r)
}

/*
RankEvalPostWithIndex Method for RankEvalPostWithIndex

Allows to evaluate the quality of ranked search results over a set of typical search queries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiRankEvalPostWithIndexRequest
*/
func (a *DefaultAPIService) RankEvalPostWithIndex(ctx context.Context, index string) ApiRankEvalPostWithIndexRequest {
	return ApiRankEvalPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RankEvalPostWithIndexExecute(r ApiRankEvalPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RankEvalPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_rank_eval"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReindexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	refresh *bool
	timeout *string
	waitForActiveShards *string
	waitForCompletion *bool
	requestsPerSecond *int32
	scroll *string
	slices *string
	maxDocs *int32
}

func (r ApiReindexRequest) Body(body map[string]interface{}) ApiReindexRequest {
	r.body = &body
	return r
}

// Should the affected indexes be refreshed?.
func (r ApiReindexRequest) Refresh(refresh bool) ApiReindexRequest {
	r.refresh = &refresh
	return r
}

// Time each individual bulk request should wait for shards that are unavailable.
func (r ApiReindexRequest) Timeout(timeout string) ApiReindexRequest {
	r.timeout = &timeout
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r ApiReindexRequest) WaitForActiveShards(waitForActiveShards string) ApiReindexRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Should this request wait until the operation has completed before returning.
func (r ApiReindexRequest) WaitForCompletion(waitForCompletion bool) ApiReindexRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

// The throttle for this request in sub-requests per second. -1 means no throttle.
func (r ApiReindexRequest) RequestsPerSecond(requestsPerSecond int32) ApiReindexRequest {
	r.requestsPerSecond = &requestsPerSecond
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiReindexRequest) Scroll(scroll string) ApiReindexRequest {
	r.scroll = &scroll
	return r
}

// The number of slices this task should be divided into. Defaults to 1, meaning the task isn&#39;t sliced into subtasks. Can be set to &#x60;auto&#x60;.
func (r ApiReindexRequest) Slices(slices string) ApiReindexRequest {
	r.slices = &slices
	return r
}

// Maximum number of documents to process (default: all documents).
func (r ApiReindexRequest) MaxDocs(maxDocs int32) ApiReindexRequest {
	r.maxDocs = &maxDocs
	return r
}

func (r ApiReindexRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReindexExecute(r)
}

/*
Reindex Method for Reindex

Allows to copy documents from one index to another, optionally filtering the source
documents by a query, changing the destination index settings, or fetching the
documents from a remote cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReindexRequest
*/
func (a *DefaultAPIService) Reindex(ctx context.Context) ApiReindexRequest {
	return ApiReindexRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ReindexExecute(r ApiReindexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Reindex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_reindex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	} else {
		var defaultValue string = "1m"
		r.timeout = &defaultValue
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = true
		r.waitForCompletion = &defaultValue
	}
	if r.requestsPerSecond != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requests_per_second", r.requestsPerSecond, "")
	} else {
		var defaultValue int32 = 0
		r.requestsPerSecond = &defaultValue
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.slices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slices", r.slices, "")
	} else {
		var defaultValue string = "1"
		r.slices = &defaultValue
	}
	if r.maxDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_docs", r.maxDocs, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReindexRethrottleRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	requestsPerSecond *int32
}

// The throttle for this request in sub-requests per second. -1 means no throttle.
func (r ApiReindexRethrottleRequest) RequestsPerSecond(requestsPerSecond int32) ApiReindexRethrottleRequest {
	r.requestsPerSecond = &requestsPerSecond
	return r
}

func (r ApiReindexRethrottleRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReindexRethrottleExecute(r)
}

/*
ReindexRethrottle Method for ReindexRethrottle

Changes the number of requests per second for a particular Reindex operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id to rethrottle.
 @return ApiReindexRethrottleRequest
*/
func (a *DefaultAPIService) ReindexRethrottle(ctx context.Context, taskId string) ApiReindexRethrottleRequest {
	return ApiReindexRethrottleRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ReindexRethrottleExecute(r ApiReindexRethrottleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ReindexRethrottle")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_reindex/{task_id}/_rethrottle"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestsPerSecond == nil {
		return nil, reportError("requestsPerSecond is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "requests_per_second", r.requestsPerSecond, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReloadHttpCertificatesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiReloadHttpCertificatesRequest) Execute() (*ReloadHttpCertificatesResponseContent, *http.Response, error) {
	return r.ApiService.ReloadHttpCertificatesExecute(r)
}

/*
ReloadHttpCertificates Method for ReloadHttpCertificates

Reload HTTP layer communication certificates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReloadHttpCertificatesRequest
*/
func (a *DefaultAPIService) ReloadHttpCertificates(ctx context.Context) ApiReloadHttpCertificatesRequest {
	return ApiReloadHttpCertificatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReloadHttpCertificatesResponseContent
func (a *DefaultAPIService) ReloadHttpCertificatesExecute(r ApiReloadHttpCertificatesRequest) (*ReloadHttpCertificatesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReloadHttpCertificatesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ReloadHttpCertificates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/ssl/http/reloadcerts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReloadTransportCertificatesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiReloadTransportCertificatesRequest) Execute() (*ReloadTransportCertificatesResponseContent, *http.Response, error) {
	return r.ApiService.ReloadTransportCertificatesExecute(r)
}

/*
ReloadTransportCertificates Method for ReloadTransportCertificates

Reload transport layer communication certificates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReloadTransportCertificatesRequest
*/
func (a *DefaultAPIService) ReloadTransportCertificates(ctx context.Context) ApiReloadTransportCertificatesRequest {
	return ApiReloadTransportCertificatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReloadTransportCertificatesResponseContent
func (a *DefaultAPIService) ReloadTransportCertificatesExecute(r ApiReloadTransportCertificatesRequest) (*ReloadTransportCertificatesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReloadTransportCertificatesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ReloadTransportCertificates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/ssl/transport/reloadcerts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoteStoreRestoreRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	remoteStoreRestoreBodyParams *RemoteStoreRestoreBodyParams
	clusterManagerTimeout *string
	waitForCompletion *bool
}

func (r ApiRemoteStoreRestoreRequest) RemoteStoreRestoreBodyParams(remoteStoreRestoreBodyParams RemoteStoreRestoreBodyParams) ApiRemoteStoreRestoreRequest {
	r.remoteStoreRestoreBodyParams = &remoteStoreRestoreBodyParams
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiRemoteStoreRestoreRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiRemoteStoreRestoreRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Should this request wait until the operation has completed before returning.
func (r ApiRemoteStoreRestoreRequest) WaitForCompletion(waitForCompletion bool) ApiRemoteStoreRestoreRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

func (r ApiRemoteStoreRestoreRequest) Execute() (*RemoteStoreRestoreResponseContent, *http.Response, error) {
	return r.ApiService.RemoteStoreRestoreExecute(r)
}

/*
RemoteStoreRestore Method for RemoteStoreRestore

Restores from remote store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoteStoreRestoreRequest
*/
func (a *DefaultAPIService) RemoteStoreRestore(ctx context.Context) ApiRemoteStoreRestoreRequest {
	return ApiRemoteStoreRestoreRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RemoteStoreRestoreResponseContent
func (a *DefaultAPIService) RemoteStoreRestoreExecute(r ApiRemoteStoreRestoreRequest) (*RemoteStoreRestoreResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemoteStoreRestoreResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RemoteStoreRestore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_remotestore/_restore"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.remoteStoreRestoreBodyParams == nil {
		return localVarReturnValue, nil, reportError("remoteStoreRestoreBodyParams is required and must be specified")
	}

	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.remoteStoreRestoreBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRenderSearchTemplateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiRenderSearchTemplateGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.RenderSearchTemplateGetExecute(r)
}

/*
RenderSearchTemplateGet Method for RenderSearchTemplateGet

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRenderSearchTemplateGetRequest
*/
func (a *DefaultAPIService) RenderSearchTemplateGet(ctx context.Context) ApiRenderSearchTemplateGetRequest {
	return ApiRenderSearchTemplateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RenderSearchTemplateGetExecute(r ApiRenderSearchTemplateGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RenderSearchTemplateGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_render/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRenderSearchTemplateGetWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
}

func (r ApiRenderSearchTemplateGetWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.RenderSearchTemplateGetWithIdExecute(r)
}

/*
RenderSearchTemplateGetWithId Method for RenderSearchTemplateGetWithId

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the stored search template.
 @return ApiRenderSearchTemplateGetWithIdRequest
*/
func (a *DefaultAPIService) RenderSearchTemplateGetWithId(ctx context.Context, id string) ApiRenderSearchTemplateGetWithIdRequest {
	return ApiRenderSearchTemplateGetWithIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RenderSearchTemplateGetWithIdExecute(r ApiRenderSearchTemplateGetWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RenderSearchTemplateGetWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_render/template/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRenderSearchTemplatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
}

func (r ApiRenderSearchTemplatePostRequest) Body(body map[string]interface{}) ApiRenderSearchTemplatePostRequest {
	r.body = &body
	return r
}

func (r ApiRenderSearchTemplatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.RenderSearchTemplatePostExecute(r)
}

/*
RenderSearchTemplatePost Method for RenderSearchTemplatePost

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRenderSearchTemplatePostRequest
*/
func (a *DefaultAPIService) RenderSearchTemplatePost(ctx context.Context) ApiRenderSearchTemplatePostRequest {
	return ApiRenderSearchTemplatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RenderSearchTemplatePostExecute(r ApiRenderSearchTemplatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RenderSearchTemplatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_render/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRenderSearchTemplatePostWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	body *map[string]interface{}
}

func (r ApiRenderSearchTemplatePostWithIdRequest) Body(body map[string]interface{}) ApiRenderSearchTemplatePostWithIdRequest {
	r.body = &body
	return r
}

func (r ApiRenderSearchTemplatePostWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.RenderSearchTemplatePostWithIdExecute(r)
}

/*
RenderSearchTemplatePostWithId Method for RenderSearchTemplatePostWithId

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the stored search template.
 @return ApiRenderSearchTemplatePostWithIdRequest
*/
func (a *DefaultAPIService) RenderSearchTemplatePostWithId(ctx context.Context, id string) ApiRenderSearchTemplatePostWithIdRequest {
	return ApiRenderSearchTemplatePostWithIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RenderSearchTemplatePostWithIdExecute(r ApiRenderSearchTemplatePostWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RenderSearchTemplatePostWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_render/template/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScriptsPainlessExecuteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiScriptsPainlessExecuteGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScriptsPainlessExecuteGetExecute(r)
}

/*
ScriptsPainlessExecuteGet Method for ScriptsPainlessExecuteGet

Allows an arbitrary script to be executed and a result to be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScriptsPainlessExecuteGetRequest
*/
func (a *DefaultAPIService) ScriptsPainlessExecuteGet(ctx context.Context) ApiScriptsPainlessExecuteGetRequest {
	return ApiScriptsPainlessExecuteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScriptsPainlessExecuteGetExecute(r ApiScriptsPainlessExecuteGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScriptsPainlessExecuteGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/painless/_execute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScriptsPainlessExecutePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
}

func (r ApiScriptsPainlessExecutePostRequest) Body(body map[string]interface{}) ApiScriptsPainlessExecutePostRequest {
	r.body = &body
	return r
}

func (r ApiScriptsPainlessExecutePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScriptsPainlessExecutePostExecute(r)
}

/*
ScriptsPainlessExecutePost Method for ScriptsPainlessExecutePost

Allows an arbitrary script to be executed and a result to be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScriptsPainlessExecutePostRequest
*/
func (a *DefaultAPIService) ScriptsPainlessExecutePost(ctx context.Context) ApiScriptsPainlessExecutePostRequest {
	return ApiScriptsPainlessExecutePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScriptsPainlessExecutePostExecute(r ApiScriptsPainlessExecutePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScriptsPainlessExecutePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/painless/_execute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScrollGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	scroll *string
	scrollId *string
	restTotalHitsAsInt *bool
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiScrollGetRequest) Scroll(scroll string) ApiScrollGetRequest {
	r.scroll = &scroll
	return r
}

// Scroll ID.
func (r ApiScrollGetRequest) ScrollId(scrollId string) ApiScrollGetRequest {
	r.scrollId = &scrollId
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiScrollGetRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiScrollGetRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r ApiScrollGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScrollGetExecute(r)
}

/*
ScrollGet Method for ScrollGet

Allows to retrieve a large numbers of results from a single search request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScrollGetRequest
*/
func (a *DefaultAPIService) ScrollGet(ctx context.Context) ApiScrollGetRequest {
	return ApiScrollGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScrollGetExecute(r ApiScrollGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScrollGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/scroll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.scrollId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll_id", r.scrollId, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScrollGetWithScrollIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	scrollId string
	scroll *string
	scrollId2 *string
	restTotalHitsAsInt *bool
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiScrollGetWithScrollIdRequest) Scroll(scroll string) ApiScrollGetWithScrollIdRequest {
	r.scroll = &scroll
	return r
}

// Scroll ID.
func (r ApiScrollGetWithScrollIdRequest) ScrollId2(scrollId2 string) ApiScrollGetWithScrollIdRequest {
	r.scrollId2 = &scrollId2
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiScrollGetWithScrollIdRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiScrollGetWithScrollIdRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r ApiScrollGetWithScrollIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScrollGetWithScrollIdExecute(r)
}

/*
ScrollGetWithScrollId Method for ScrollGetWithScrollId

Allows to retrieve a large numbers of results from a single search request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param scrollId Scroll ID.
 @return ApiScrollGetWithScrollIdRequest

Deprecated
*/
func (a *DefaultAPIService) ScrollGetWithScrollId(ctx context.Context, scrollId string) ApiScrollGetWithScrollIdRequest {
	return ApiScrollGetWithScrollIdRequest{
		ApiService: a,
		ctx: ctx,
		scrollId: scrollId,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) ScrollGetWithScrollIdExecute(r ApiScrollGetWithScrollIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScrollGetWithScrollId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/scroll/{scroll_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"scroll_id"+"}", url.PathEscape(parameterValueToString(r.scrollId, "scrollId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.scrollId2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll_id", r.scrollId2, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScrollPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	scroll *string
	scrollId *string
	restTotalHitsAsInt *bool
	body *map[string]interface{}
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiScrollPostRequest) Scroll(scroll string) ApiScrollPostRequest {
	r.scroll = &scroll
	return r
}

// Scroll ID.
func (r ApiScrollPostRequest) ScrollId(scrollId string) ApiScrollPostRequest {
	r.scrollId = &scrollId
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiScrollPostRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiScrollPostRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r ApiScrollPostRequest) Body(body map[string]interface{}) ApiScrollPostRequest {
	r.body = &body
	return r
}

func (r ApiScrollPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScrollPostExecute(r)
}

/*
ScrollPost Method for ScrollPost

Allows to retrieve a large numbers of results from a single search request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScrollPostRequest
*/
func (a *DefaultAPIService) ScrollPost(ctx context.Context) ApiScrollPostRequest {
	return ApiScrollPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScrollPostExecute(r ApiScrollPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScrollPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/scroll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.scrollId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll_id", r.scrollId, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScrollPostWithScrollIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	scrollId string
	scroll *string
	scrollId2 *string
	restTotalHitsAsInt *bool
	body *map[string]interface{}
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiScrollPostWithScrollIdRequest) Scroll(scroll string) ApiScrollPostWithScrollIdRequest {
	r.scroll = &scroll
	return r
}

// Scroll ID.
func (r ApiScrollPostWithScrollIdRequest) ScrollId2(scrollId2 string) ApiScrollPostWithScrollIdRequest {
	r.scrollId2 = &scrollId2
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiScrollPostWithScrollIdRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiScrollPostWithScrollIdRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r ApiScrollPostWithScrollIdRequest) Body(body map[string]interface{}) ApiScrollPostWithScrollIdRequest {
	r.body = &body
	return r
}

func (r ApiScrollPostWithScrollIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScrollPostWithScrollIdExecute(r)
}

/*
ScrollPostWithScrollId Method for ScrollPostWithScrollId

Allows to retrieve a large numbers of results from a single search request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param scrollId Scroll ID.
 @return ApiScrollPostWithScrollIdRequest

Deprecated
*/
func (a *DefaultAPIService) ScrollPostWithScrollId(ctx context.Context, scrollId string) ApiScrollPostWithScrollIdRequest {
	return ApiScrollPostWithScrollIdRequest{
		ApiService: a,
		ctx: ctx,
		scrollId: scrollId,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) ScrollPostWithScrollIdExecute(r ApiScrollPostWithScrollIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScrollPostWithScrollId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/scroll/{scroll_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"scroll_id"+"}", url.PathEscape(parameterValueToString(r.scrollId, "scrollId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.scrollId2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll_id", r.scrollId2, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	analyzer *string
	analyzeWildcard *bool
	ccsMinimizeRoundtrips *bool
	defaultOperator *DefaultOperator
	df *string
	explain *bool
	storedFields *[]string
	docvalueFields *[]string
	from *int32
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	lenient *bool
	preference *string
	q *string
	routing *[]string
	scroll *string
	searchType *SearchType
	size *int32
	sort *[]string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	terminateAfter *int32
	stats *[]string
	suggestField *string
	suggestMode *SuggestMode
	suggestSize *int32
	suggestText *string
	timeout *string
	trackScores *bool
	trackTotalHits *bool
	allowPartialSearchResults *bool
	typedKeys *bool
	version *bool
	seqNoPrimaryTerm *bool
	requestCache *bool
	batchedReduceSize *int32
	maxConcurrentShardRequests *int32
	preFilterShardSize *int32
	restTotalHitsAsInt *bool
}

// The analyzer to use for the query string.
func (r ApiSearchGetRequest) Analyzer(analyzer string) ApiSearchGetRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r ApiSearchGetRequest) AnalyzeWildcard(analyzeWildcard bool) ApiSearchGetRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiSearchGetRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiSearchGetRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiSearchGetRequest) DefaultOperator(defaultOperator DefaultOperator) ApiSearchGetRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r ApiSearchGetRequest) Df(df string) ApiSearchGetRequest {
	r.df = &df
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r ApiSearchGetRequest) Explain(explain bool) ApiSearchGetRequest {
	r.explain = &explain
	return r
}

// Comma-separated list of stored fields to return.
func (r ApiSearchGetRequest) StoredFields(storedFields []string) ApiSearchGetRequest {
	r.storedFields = &storedFields
	return r
}

// Comma-separated list of fields to return as the docvalue representation of a field for each hit.
func (r ApiSearchGetRequest) DocvalueFields(docvalueFields []string) ApiSearchGetRequest {
	r.docvalueFields = &docvalueFields
	return r
}

// Starting offset.
func (r ApiSearchGetRequest) From(from int32) ApiSearchGetRequest {
	r.from = &from
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiSearchGetRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSearchGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r ApiSearchGetRequest) IgnoreThrottled(ignoreThrottled bool) ApiSearchGetRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiSearchGetRequest) AllowNoIndices(allowNoIndices bool) ApiSearchGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiSearchGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiSearchGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiSearchGetRequest) Lenient(lenient bool) ApiSearchGetRequest {
	r.lenient = &lenient
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiSearchGetRequest) Preference(preference string) ApiSearchGetRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r ApiSearchGetRequest) Q(q string) ApiSearchGetRequest {
	r.q = &q
	return r
}

// Comma-separated list of specific routing values.
func (r ApiSearchGetRequest) Routing(routing []string) ApiSearchGetRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiSearchGetRequest) Scroll(scroll string) ApiSearchGetRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r ApiSearchGetRequest) SearchType(searchType SearchType) ApiSearchGetRequest {
	r.searchType = &searchType
	return r
}

// Number of hits to return.
func (r ApiSearchGetRequest) Size(size int32) ApiSearchGetRequest {
	r.size = &size
	return r
}

// Comma-separated list of &lt;field&gt;:&lt;direction&gt; pairs.
func (r ApiSearchGetRequest) Sort(sort []string) ApiSearchGetRequest {
	r.sort = &sort
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiSearchGetRequest) Source(source []string) ApiSearchGetRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiSearchGetRequest) SourceExcludes(sourceExcludes []string) ApiSearchGetRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiSearchGetRequest) SourceIncludes(sourceIncludes []string) ApiSearchGetRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r ApiSearchGetRequest) TerminateAfter(terminateAfter int32) ApiSearchGetRequest {
	r.terminateAfter = &terminateAfter
	return r
}

// Specific &#39;tag&#39; of the request for logging and statistical purposes.
func (r ApiSearchGetRequest) Stats(stats []string) ApiSearchGetRequest {
	r.stats = &stats
	return r
}

// Specify which field to use for suggestions.
func (r ApiSearchGetRequest) SuggestField(suggestField string) ApiSearchGetRequest {
	r.suggestField = &suggestField
	return r
}

// Specify suggest mode.
func (r ApiSearchGetRequest) SuggestMode(suggestMode SuggestMode) ApiSearchGetRequest {
	r.suggestMode = &suggestMode
	return r
}

// How many suggestions to return in response.
func (r ApiSearchGetRequest) SuggestSize(suggestSize int32) ApiSearchGetRequest {
	r.suggestSize = &suggestSize
	return r
}

// The source text for which the suggestions should be returned.
func (r ApiSearchGetRequest) SuggestText(suggestText string) ApiSearchGetRequest {
	r.suggestText = &suggestText
	return r
}

// Operation timeout.
func (r ApiSearchGetRequest) Timeout(timeout string) ApiSearchGetRequest {
	r.timeout = &timeout
	return r
}

// Whether to calculate and return scores even if they are not used for sorting.
func (r ApiSearchGetRequest) TrackScores(trackScores bool) ApiSearchGetRequest {
	r.trackScores = &trackScores
	return r
}

// Indicate if the number of documents that match the query should be tracked.
func (r ApiSearchGetRequest) TrackTotalHits(trackTotalHits bool) ApiSearchGetRequest {
	r.trackTotalHits = &trackTotalHits
	return r
}

// Indicate if an error should be returned if there is a partial search failure or timeout.
func (r ApiSearchGetRequest) AllowPartialSearchResults(allowPartialSearchResults bool) ApiSearchGetRequest {
	r.allowPartialSearchResults = &allowPartialSearchResults
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiSearchGetRequest) TypedKeys(typedKeys bool) ApiSearchGetRequest {
	r.typedKeys = &typedKeys
	return r
}

// Whether to return document version as part of a hit.
func (r ApiSearchGetRequest) Version(version bool) ApiSearchGetRequest {
	r.version = &version
	return r
}

// Specify whether to return sequence number and primary term of the last modification of each hit.
func (r ApiSearchGetRequest) SeqNoPrimaryTerm(seqNoPrimaryTerm bool) ApiSearchGetRequest {
	r.seqNoPrimaryTerm = &seqNoPrimaryTerm
	return r
}

// Specify if request cache should be used for this request or not, defaults to index level setting.
func (r ApiSearchGetRequest) RequestCache(requestCache bool) ApiSearchGetRequest {
	r.requestCache = &requestCache
	return r
}

// The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
func (r ApiSearchGetRequest) BatchedReduceSize(batchedReduceSize int32) ApiSearchGetRequest {
	r.batchedReduceSize = &batchedReduceSize
	return r
}

// The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r ApiSearchGetRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) ApiSearchGetRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r ApiSearchGetRequest) PreFilterShardSize(preFilterShardSize int32) ApiSearchGetRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiSearchGetRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiSearchGetRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r ApiSearchGetRequest) Execute() (*SearchGetResponseContent, *http.Response, error) {
	return r.ApiService.SearchGetExecute(r)
}

/*
SearchGet Method for SearchGet

Returns results matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchGetRequest
*/
func (a *DefaultAPIService) SearchGet(ctx context.Context) ApiSearchGetRequest {
	return ApiSearchGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchGetResponseContent
func (a *DefaultAPIService) SearchGetExecute(r ApiSearchGetRequest) (*SearchGetResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchGetResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.docvalueFields != nil {
		t := *r.docvalueFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", t, "multi")
		}
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	} else {
		var defaultValue int32 = 0
		r.from = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	if r.stats != nil {
		t := *r.stats
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stats", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stats", t, "multi")
		}
	}
	if r.suggestField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_field", r.suggestField, "")
	}
	if r.suggestMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_mode", r.suggestMode, "")
	}
	if r.suggestSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_size", r.suggestSize, "")
	}
	if r.suggestText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_text", r.suggestText, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.trackScores != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_scores", r.trackScores, "")
	}
	if r.trackTotalHits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_total_hits", r.trackTotalHits, "")
	}
	if r.allowPartialSearchResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_partial_search_results", r.allowPartialSearchResults, "")
	} else {
		var defaultValue bool = true
		r.allowPartialSearchResults = &defaultValue
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.seqNoPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seq_no_primary_term", r.seqNoPrimaryTerm, "")
	}
	if r.requestCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_cache", r.requestCache, "")
	}
	if r.batchedReduceSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batched_reduce_size", r.batchedReduceSize, "")
	} else {
		var defaultValue int32 = 512
		r.batchedReduceSize = &defaultValue
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	analyzer *string
	analyzeWildcard *bool
	ccsMinimizeRoundtrips *bool
	defaultOperator *DefaultOperator
	df *string
	explain *bool
	storedFields *[]string
	docvalueFields *[]string
	from *int32
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	lenient *bool
	preference *string
	q *string
	routing *[]string
	scroll *string
	searchType *SearchType
	size *int32
	sort *[]string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	terminateAfter *int32
	stats *[]string
	suggestField *string
	suggestMode *SuggestMode
	suggestSize *int32
	suggestText *string
	timeout *string
	trackScores *bool
	trackTotalHits *bool
	allowPartialSearchResults *bool
	typedKeys *bool
	version *bool
	seqNoPrimaryTerm *bool
	requestCache *bool
	batchedReduceSize *int32
	maxConcurrentShardRequests *int32
	preFilterShardSize *int32
	restTotalHitsAsInt *bool
}

// The analyzer to use for the query string.
func (r ApiSearchGetWithIndexRequest) Analyzer(analyzer string) ApiSearchGetWithIndexRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r ApiSearchGetWithIndexRequest) AnalyzeWildcard(analyzeWildcard bool) ApiSearchGetWithIndexRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiSearchGetWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiSearchGetWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiSearchGetWithIndexRequest) DefaultOperator(defaultOperator DefaultOperator) ApiSearchGetWithIndexRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r ApiSearchGetWithIndexRequest) Df(df string) ApiSearchGetWithIndexRequest {
	r.df = &df
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r ApiSearchGetWithIndexRequest) Explain(explain bool) ApiSearchGetWithIndexRequest {
	r.explain = &explain
	return r
}

// Comma-separated list of stored fields to return.
func (r ApiSearchGetWithIndexRequest) StoredFields(storedFields []string) ApiSearchGetWithIndexRequest {
	r.storedFields = &storedFields
	return r
}

// Comma-separated list of fields to return as the docvalue representation of a field for each hit.
func (r ApiSearchGetWithIndexRequest) DocvalueFields(docvalueFields []string) ApiSearchGetWithIndexRequest {
	r.docvalueFields = &docvalueFields
	return r
}

// Starting offset.
func (r ApiSearchGetWithIndexRequest) From(from int32) ApiSearchGetWithIndexRequest {
	r.from = &from
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiSearchGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSearchGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r ApiSearchGetWithIndexRequest) IgnoreThrottled(ignoreThrottled bool) ApiSearchGetWithIndexRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiSearchGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiSearchGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiSearchGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiSearchGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiSearchGetWithIndexRequest) Lenient(lenient bool) ApiSearchGetWithIndexRequest {
	r.lenient = &lenient
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiSearchGetWithIndexRequest) Preference(preference string) ApiSearchGetWithIndexRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r ApiSearchGetWithIndexRequest) Q(q string) ApiSearchGetWithIndexRequest {
	r.q = &q
	return r
}

// Comma-separated list of specific routing values.
func (r ApiSearchGetWithIndexRequest) Routing(routing []string) ApiSearchGetWithIndexRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiSearchGetWithIndexRequest) Scroll(scroll string) ApiSearchGetWithIndexRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r ApiSearchGetWithIndexRequest) SearchType(searchType SearchType) ApiSearchGetWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Number of hits to return.
func (r ApiSearchGetWithIndexRequest) Size(size int32) ApiSearchGetWithIndexRequest {
	r.size = &size
	return r
}

// Comma-separated list of &lt;field&gt;:&lt;direction&gt; pairs.
func (r ApiSearchGetWithIndexRequest) Sort(sort []string) ApiSearchGetWithIndexRequest {
	r.sort = &sort
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiSearchGetWithIndexRequest) Source(source []string) ApiSearchGetWithIndexRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiSearchGetWithIndexRequest) SourceExcludes(sourceExcludes []string) ApiSearchGetWithIndexRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiSearchGetWithIndexRequest) SourceIncludes(sourceIncludes []string) ApiSearchGetWithIndexRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r ApiSearchGetWithIndexRequest) TerminateAfter(terminateAfter int32) ApiSearchGetWithIndexRequest {
	r.terminateAfter = &terminateAfter
	return r
}

// Specific &#39;tag&#39; of the request for logging and statistical purposes.
func (r ApiSearchGetWithIndexRequest) Stats(stats []string) ApiSearchGetWithIndexRequest {
	r.stats = &stats
	return r
}

// Specify which field to use for suggestions.
func (r ApiSearchGetWithIndexRequest) SuggestField(suggestField string) ApiSearchGetWithIndexRequest {
	r.suggestField = &suggestField
	return r
}

// Specify suggest mode.
func (r ApiSearchGetWithIndexRequest) SuggestMode(suggestMode SuggestMode) ApiSearchGetWithIndexRequest {
	r.suggestMode = &suggestMode
	return r
}

// How many suggestions to return in response.
func (r ApiSearchGetWithIndexRequest) SuggestSize(suggestSize int32) ApiSearchGetWithIndexRequest {
	r.suggestSize = &suggestSize
	return r
}

// The source text for which the suggestions should be returned.
func (r ApiSearchGetWithIndexRequest) SuggestText(suggestText string) ApiSearchGetWithIndexRequest {
	r.suggestText = &suggestText
	return r
}

// Operation timeout.
func (r ApiSearchGetWithIndexRequest) Timeout(timeout string) ApiSearchGetWithIndexRequest {
	r.timeout = &timeout
	return r
}

// Whether to calculate and return scores even if they are not used for sorting.
func (r ApiSearchGetWithIndexRequest) TrackScores(trackScores bool) ApiSearchGetWithIndexRequest {
	r.trackScores = &trackScores
	return r
}

// Indicate if the number of documents that match the query should be tracked.
func (r ApiSearchGetWithIndexRequest) TrackTotalHits(trackTotalHits bool) ApiSearchGetWithIndexRequest {
	r.trackTotalHits = &trackTotalHits
	return r
}

// Indicate if an error should be returned if there is a partial search failure or timeout.
func (r ApiSearchGetWithIndexRequest) AllowPartialSearchResults(allowPartialSearchResults bool) ApiSearchGetWithIndexRequest {
	r.allowPartialSearchResults = &allowPartialSearchResults
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiSearchGetWithIndexRequest) TypedKeys(typedKeys bool) ApiSearchGetWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Whether to return document version as part of a hit.
func (r ApiSearchGetWithIndexRequest) Version(version bool) ApiSearchGetWithIndexRequest {
	r.version = &version
	return r
}

// Specify whether to return sequence number and primary term of the last modification of each hit.
func (r ApiSearchGetWithIndexRequest) SeqNoPrimaryTerm(seqNoPrimaryTerm bool) ApiSearchGetWithIndexRequest {
	r.seqNoPrimaryTerm = &seqNoPrimaryTerm
	return r
}

// Specify if request cache should be used for this request or not, defaults to index level setting.
func (r ApiSearchGetWithIndexRequest) RequestCache(requestCache bool) ApiSearchGetWithIndexRequest {
	r.requestCache = &requestCache
	return r
}

// The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
func (r ApiSearchGetWithIndexRequest) BatchedReduceSize(batchedReduceSize int32) ApiSearchGetWithIndexRequest {
	r.batchedReduceSize = &batchedReduceSize
	return r
}

// The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r ApiSearchGetWithIndexRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) ApiSearchGetWithIndexRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r ApiSearchGetWithIndexRequest) PreFilterShardSize(preFilterShardSize int32) ApiSearchGetWithIndexRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiSearchGetWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiSearchGetWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r ApiSearchGetWithIndexRequest) Execute() (*SearchGetWithIndexResponseContent, *http.Response, error) {
	return r.ApiService.SearchGetWithIndexExecute(r)
}

/*
SearchGetWithIndex Method for SearchGetWithIndex

Returns results matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiSearchGetWithIndexRequest
*/
func (a *DefaultAPIService) SearchGetWithIndex(ctx context.Context, index string) ApiSearchGetWithIndexRequest {
	return ApiSearchGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
//  @return SearchGetWithIndexResponseContent
func (a *DefaultAPIService) SearchGetWithIndexExecute(r ApiSearchGetWithIndexRequest) (*SearchGetWithIndexResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchGetWithIndexResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchGetWithIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_search"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.docvalueFields != nil {
		t := *r.docvalueFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", t, "multi")
		}
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	} else {
		var defaultValue int32 = 0
		r.from = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	if r.stats != nil {
		t := *r.stats
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stats", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stats", t, "multi")
		}
	}
	if r.suggestField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_field", r.suggestField, "")
	}
	if r.suggestMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_mode", r.suggestMode, "")
	}
	if r.suggestSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_size", r.suggestSize, "")
	}
	if r.suggestText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_text", r.suggestText, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.trackScores != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_scores", r.trackScores, "")
	}
	if r.trackTotalHits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_total_hits", r.trackTotalHits, "")
	}
	if r.allowPartialSearchResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_partial_search_results", r.allowPartialSearchResults, "")
	} else {
		var defaultValue bool = true
		r.allowPartialSearchResults = &defaultValue
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.seqNoPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seq_no_primary_term", r.seqNoPrimaryTerm, "")
	}
	if r.requestCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_cache", r.requestCache, "")
	}
	if r.batchedReduceSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batched_reduce_size", r.batchedReduceSize, "")
	} else {
		var defaultValue int32 = 512
		r.batchedReduceSize = &defaultValue
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	analyzer *string
	analyzeWildcard *bool
	ccsMinimizeRoundtrips *bool
	defaultOperator *DefaultOperator
	df *string
	explain *bool
	storedFields *[]string
	docvalueFields *[]string
	from *int32
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	lenient *bool
	preference *string
	q *string
	routing *[]string
	scroll *string
	searchType *SearchType
	size *int32
	sort *[]string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	terminateAfter *int32
	stats *[]string
	suggestField *string
	suggestMode *SuggestMode
	suggestSize *int32
	suggestText *string
	timeout *string
	trackScores *bool
	trackTotalHits *bool
	allowPartialSearchResults *bool
	typedKeys *bool
	version *bool
	seqNoPrimaryTerm *bool
	requestCache *bool
	batchedReduceSize *int32
	maxConcurrentShardRequests *int32
	preFilterShardSize *int32
	restTotalHitsAsInt *bool
	searchBodyParams *SearchBodyParams
}

// The analyzer to use for the query string.
func (r ApiSearchPostRequest) Analyzer(analyzer string) ApiSearchPostRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r ApiSearchPostRequest) AnalyzeWildcard(analyzeWildcard bool) ApiSearchPostRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiSearchPostRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiSearchPostRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiSearchPostRequest) DefaultOperator(defaultOperator DefaultOperator) ApiSearchPostRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r ApiSearchPostRequest) Df(df string) ApiSearchPostRequest {
	r.df = &df
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r ApiSearchPostRequest) Explain(explain bool) ApiSearchPostRequest {
	r.explain = &explain
	return r
}

// Comma-separated list of stored fields to return.
func (r ApiSearchPostRequest) StoredFields(storedFields []string) ApiSearchPostRequest {
	r.storedFields = &storedFields
	return r
}

// Comma-separated list of fields to return as the docvalue representation of a field for each hit.
func (r ApiSearchPostRequest) DocvalueFields(docvalueFields []string) ApiSearchPostRequest {
	r.docvalueFields = &docvalueFields
	return r
}

// Starting offset.
func (r ApiSearchPostRequest) From(from int32) ApiSearchPostRequest {
	r.from = &from
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiSearchPostRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSearchPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r ApiSearchPostRequest) IgnoreThrottled(ignoreThrottled bool) ApiSearchPostRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiSearchPostRequest) AllowNoIndices(allowNoIndices bool) ApiSearchPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiSearchPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiSearchPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiSearchPostRequest) Lenient(lenient bool) ApiSearchPostRequest {
	r.lenient = &lenient
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiSearchPostRequest) Preference(preference string) ApiSearchPostRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r ApiSearchPostRequest) Q(q string) ApiSearchPostRequest {
	r.q = &q
	return r
}

// Comma-separated list of specific routing values.
func (r ApiSearchPostRequest) Routing(routing []string) ApiSearchPostRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiSearchPostRequest) Scroll(scroll string) ApiSearchPostRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r ApiSearchPostRequest) SearchType(searchType SearchType) ApiSearchPostRequest {
	r.searchType = &searchType
	return r
}

// Number of hits to return.
func (r ApiSearchPostRequest) Size(size int32) ApiSearchPostRequest {
	r.size = &size
	return r
}

// Comma-separated list of &lt;field&gt;:&lt;direction&gt; pairs.
func (r ApiSearchPostRequest) Sort(sort []string) ApiSearchPostRequest {
	r.sort = &sort
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiSearchPostRequest) Source(source []string) ApiSearchPostRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiSearchPostRequest) SourceExcludes(sourceExcludes []string) ApiSearchPostRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiSearchPostRequest) SourceIncludes(sourceIncludes []string) ApiSearchPostRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r ApiSearchPostRequest) TerminateAfter(terminateAfter int32) ApiSearchPostRequest {
	r.terminateAfter = &terminateAfter
	return r
}

// Specific &#39;tag&#39; of the request for logging and statistical purposes.
func (r ApiSearchPostRequest) Stats(stats []string) ApiSearchPostRequest {
	r.stats = &stats
	return r
}

// Specify which field to use for suggestions.
func (r ApiSearchPostRequest) SuggestField(suggestField string) ApiSearchPostRequest {
	r.suggestField = &suggestField
	return r
}

// Specify suggest mode.
func (r ApiSearchPostRequest) SuggestMode(suggestMode SuggestMode) ApiSearchPostRequest {
	r.suggestMode = &suggestMode
	return r
}

// How many suggestions to return in response.
func (r ApiSearchPostRequest) SuggestSize(suggestSize int32) ApiSearchPostRequest {
	r.suggestSize = &suggestSize
	return r
}

// The source text for which the suggestions should be returned.
func (r ApiSearchPostRequest) SuggestText(suggestText string) ApiSearchPostRequest {
	r.suggestText = &suggestText
	return r
}

// Operation timeout.
func (r ApiSearchPostRequest) Timeout(timeout string) ApiSearchPostRequest {
	r.timeout = &timeout
	return r
}

// Whether to calculate and return scores even if they are not used for sorting.
func (r ApiSearchPostRequest) TrackScores(trackScores bool) ApiSearchPostRequest {
	r.trackScores = &trackScores
	return r
}

// Indicate if the number of documents that match the query should be tracked.
func (r ApiSearchPostRequest) TrackTotalHits(trackTotalHits bool) ApiSearchPostRequest {
	r.trackTotalHits = &trackTotalHits
	return r
}

// Indicate if an error should be returned if there is a partial search failure or timeout.
func (r ApiSearchPostRequest) AllowPartialSearchResults(allowPartialSearchResults bool) ApiSearchPostRequest {
	r.allowPartialSearchResults = &allowPartialSearchResults
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiSearchPostRequest) TypedKeys(typedKeys bool) ApiSearchPostRequest {
	r.typedKeys = &typedKeys
	return r
}

// Whether to return document version as part of a hit.
func (r ApiSearchPostRequest) Version(version bool) ApiSearchPostRequest {
	r.version = &version
	return r
}

// Specify whether to return sequence number and primary term of the last modification of each hit.
func (r ApiSearchPostRequest) SeqNoPrimaryTerm(seqNoPrimaryTerm bool) ApiSearchPostRequest {
	r.seqNoPrimaryTerm = &seqNoPrimaryTerm
	return r
}

// Specify if request cache should be used for this request or not, defaults to index level setting.
func (r ApiSearchPostRequest) RequestCache(requestCache bool) ApiSearchPostRequest {
	r.requestCache = &requestCache
	return r
}

// The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
func (r ApiSearchPostRequest) BatchedReduceSize(batchedReduceSize int32) ApiSearchPostRequest {
	r.batchedReduceSize = &batchedReduceSize
	return r
}

// The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r ApiSearchPostRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) ApiSearchPostRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r ApiSearchPostRequest) PreFilterShardSize(preFilterShardSize int32) ApiSearchPostRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiSearchPostRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiSearchPostRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r ApiSearchPostRequest) SearchBodyParams(searchBodyParams SearchBodyParams) ApiSearchPostRequest {
	r.searchBodyParams = &searchBodyParams
	return r
}

func (r ApiSearchPostRequest) Execute() (*SearchPostResponseContent, *http.Response, error) {
	return r.ApiService.SearchPostExecute(r)
}

/*
SearchPost Method for SearchPost

Returns results matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchPostRequest
*/
func (a *DefaultAPIService) SearchPost(ctx context.Context) ApiSearchPostRequest {
	return ApiSearchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchPostResponseContent
func (a *DefaultAPIService) SearchPostExecute(r ApiSearchPostRequest) (*SearchPostResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchPostResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.docvalueFields != nil {
		t := *r.docvalueFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", t, "multi")
		}
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	} else {
		var defaultValue int32 = 0
		r.from = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	if r.stats != nil {
		t := *r.stats
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stats", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stats", t, "multi")
		}
	}
	if r.suggestField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_field", r.suggestField, "")
	}
	if r.suggestMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_mode", r.suggestMode, "")
	}
	if r.suggestSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_size", r.suggestSize, "")
	}
	if r.suggestText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_text", r.suggestText, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.trackScores != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_scores", r.trackScores, "")
	}
	if r.trackTotalHits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_total_hits", r.trackTotalHits, "")
	}
	if r.allowPartialSearchResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_partial_search_results", r.allowPartialSearchResults, "")
	} else {
		var defaultValue bool = true
		r.allowPartialSearchResults = &defaultValue
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.seqNoPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seq_no_primary_term", r.seqNoPrimaryTerm, "")
	}
	if r.requestCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_cache", r.requestCache, "")
	}
	if r.batchedReduceSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batched_reduce_size", r.batchedReduceSize, "")
	} else {
		var defaultValue int32 = 512
		r.batchedReduceSize = &defaultValue
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.searchBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	analyzer *string
	analyzeWildcard *bool
	ccsMinimizeRoundtrips *bool
	defaultOperator *DefaultOperator
	df *string
	explain *bool
	storedFields *[]string
	docvalueFields *[]string
	from *int32
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	lenient *bool
	preference *string
	q *string
	routing *[]string
	scroll *string
	searchType *SearchType
	size *int32
	sort *[]string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	terminateAfter *int32
	stats *[]string
	suggestField *string
	suggestMode *SuggestMode
	suggestSize *int32
	suggestText *string
	timeout *string
	trackScores *bool
	trackTotalHits *bool
	allowPartialSearchResults *bool
	typedKeys *bool
	version *bool
	seqNoPrimaryTerm *bool
	requestCache *bool
	batchedReduceSize *int32
	maxConcurrentShardRequests *int32
	preFilterShardSize *int32
	restTotalHitsAsInt *bool
	searchBodyParams *SearchBodyParams
}

// The analyzer to use for the query string.
func (r ApiSearchPostWithIndexRequest) Analyzer(analyzer string) ApiSearchPostWithIndexRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r ApiSearchPostWithIndexRequest) AnalyzeWildcard(analyzeWildcard bool) ApiSearchPostWithIndexRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiSearchPostWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiSearchPostWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiSearchPostWithIndexRequest) DefaultOperator(defaultOperator DefaultOperator) ApiSearchPostWithIndexRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r ApiSearchPostWithIndexRequest) Df(df string) ApiSearchPostWithIndexRequest {
	r.df = &df
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r ApiSearchPostWithIndexRequest) Explain(explain bool) ApiSearchPostWithIndexRequest {
	r.explain = &explain
	return r
}

// Comma-separated list of stored fields to return.
func (r ApiSearchPostWithIndexRequest) StoredFields(storedFields []string) ApiSearchPostWithIndexRequest {
	r.storedFields = &storedFields
	return r
}

// Comma-separated list of fields to return as the docvalue representation of a field for each hit.
func (r ApiSearchPostWithIndexRequest) DocvalueFields(docvalueFields []string) ApiSearchPostWithIndexRequest {
	r.docvalueFields = &docvalueFields
	return r
}

// Starting offset.
func (r ApiSearchPostWithIndexRequest) From(from int32) ApiSearchPostWithIndexRequest {
	r.from = &from
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiSearchPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSearchPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r ApiSearchPostWithIndexRequest) IgnoreThrottled(ignoreThrottled bool) ApiSearchPostWithIndexRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiSearchPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiSearchPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiSearchPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiSearchPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiSearchPostWithIndexRequest) Lenient(lenient bool) ApiSearchPostWithIndexRequest {
	r.lenient = &lenient
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiSearchPostWithIndexRequest) Preference(preference string) ApiSearchPostWithIndexRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r ApiSearchPostWithIndexRequest) Q(q string) ApiSearchPostWithIndexRequest {
	r.q = &q
	return r
}

// Comma-separated list of specific routing values.
func (r ApiSearchPostWithIndexRequest) Routing(routing []string) ApiSearchPostWithIndexRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiSearchPostWithIndexRequest) Scroll(scroll string) ApiSearchPostWithIndexRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r ApiSearchPostWithIndexRequest) SearchType(searchType SearchType) ApiSearchPostWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Number of hits to return.
func (r ApiSearchPostWithIndexRequest) Size(size int32) ApiSearchPostWithIndexRequest {
	r.size = &size
	return r
}

// Comma-separated list of &lt;field&gt;:&lt;direction&gt; pairs.
func (r ApiSearchPostWithIndexRequest) Sort(sort []string) ApiSearchPostWithIndexRequest {
	r.sort = &sort
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiSearchPostWithIndexRequest) Source(source []string) ApiSearchPostWithIndexRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiSearchPostWithIndexRequest) SourceExcludes(sourceExcludes []string) ApiSearchPostWithIndexRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiSearchPostWithIndexRequest) SourceIncludes(sourceIncludes []string) ApiSearchPostWithIndexRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r ApiSearchPostWithIndexRequest) TerminateAfter(terminateAfter int32) ApiSearchPostWithIndexRequest {
	r.terminateAfter = &terminateAfter
	return r
}

// Specific &#39;tag&#39; of the request for logging and statistical purposes.
func (r ApiSearchPostWithIndexRequest) Stats(stats []string) ApiSearchPostWithIndexRequest {
	r.stats = &stats
	return r
}

// Specify which field to use for suggestions.
func (r ApiSearchPostWithIndexRequest) SuggestField(suggestField string) ApiSearchPostWithIndexRequest {
	r.suggestField = &suggestField
	return r
}

// Specify suggest mode.
func (r ApiSearchPostWithIndexRequest) SuggestMode(suggestMode SuggestMode) ApiSearchPostWithIndexRequest {
	r.suggestMode = &suggestMode
	return r
}

// How many suggestions to return in response.
func (r ApiSearchPostWithIndexRequest) SuggestSize(suggestSize int32) ApiSearchPostWithIndexRequest {
	r.suggestSize = &suggestSize
	return r
}

// The source text for which the suggestions should be returned.
func (r ApiSearchPostWithIndexRequest) SuggestText(suggestText string) ApiSearchPostWithIndexRequest {
	r.suggestText = &suggestText
	return r
}

// Operation timeout.
func (r ApiSearchPostWithIndexRequest) Timeout(timeout string) ApiSearchPostWithIndexRequest {
	r.timeout = &timeout
	return r
}

// Whether to calculate and return scores even if they are not used for sorting.
func (r ApiSearchPostWithIndexRequest) TrackScores(trackScores bool) ApiSearchPostWithIndexRequest {
	r.trackScores = &trackScores
	return r
}

// Indicate if the number of documents that match the query should be tracked.
func (r ApiSearchPostWithIndexRequest) TrackTotalHits(trackTotalHits bool) ApiSearchPostWithIndexRequest {
	r.trackTotalHits = &trackTotalHits
	return r
}

// Indicate if an error should be returned if there is a partial search failure or timeout.
func (r ApiSearchPostWithIndexRequest) AllowPartialSearchResults(allowPartialSearchResults bool) ApiSearchPostWithIndexRequest {
	r.allowPartialSearchResults = &allowPartialSearchResults
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiSearchPostWithIndexRequest) TypedKeys(typedKeys bool) ApiSearchPostWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Whether to return document version as part of a hit.
func (r ApiSearchPostWithIndexRequest) Version(version bool) ApiSearchPostWithIndexRequest {
	r.version = &version
	return r
}

// Specify whether to return sequence number and primary term of the last modification of each hit.
func (r ApiSearchPostWithIndexRequest) SeqNoPrimaryTerm(seqNoPrimaryTerm bool) ApiSearchPostWithIndexRequest {
	r.seqNoPrimaryTerm = &seqNoPrimaryTerm
	return r
}

// Specify if request cache should be used for this request or not, defaults to index level setting.
func (r ApiSearchPostWithIndexRequest) RequestCache(requestCache bool) ApiSearchPostWithIndexRequest {
	r.requestCache = &requestCache
	return r
}

// The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
func (r ApiSearchPostWithIndexRequest) BatchedReduceSize(batchedReduceSize int32) ApiSearchPostWithIndexRequest {
	r.batchedReduceSize = &batchedReduceSize
	return r
}

// The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r ApiSearchPostWithIndexRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) ApiSearchPostWithIndexRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r ApiSearchPostWithIndexRequest) PreFilterShardSize(preFilterShardSize int32) ApiSearchPostWithIndexRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiSearchPostWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiSearchPostWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r ApiSearchPostWithIndexRequest) SearchBodyParams(searchBodyParams SearchBodyParams) ApiSearchPostWithIndexRequest {
	r.searchBodyParams = &searchBodyParams
	return r
}

func (r ApiSearchPostWithIndexRequest) Execute() (*SearchPostWithIndexResponseContent, *http.Response, error) {
	return r.ApiService.SearchPostWithIndexExecute(r)
}

/*
SearchPostWithIndex Method for SearchPostWithIndex

Returns results matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiSearchPostWithIndexRequest
*/
func (a *DefaultAPIService) SearchPostWithIndex(ctx context.Context, index string) ApiSearchPostWithIndexRequest {
	return ApiSearchPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
//  @return SearchPostWithIndexResponseContent
func (a *DefaultAPIService) SearchPostWithIndexExecute(r ApiSearchPostWithIndexRequest) (*SearchPostWithIndexResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchPostWithIndexResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchPostWithIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_search"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.docvalueFields != nil {
		t := *r.docvalueFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", t, "multi")
		}
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	} else {
		var defaultValue int32 = 0
		r.from = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	if r.stats != nil {
		t := *r.stats
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stats", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stats", t, "multi")
		}
	}
	if r.suggestField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_field", r.suggestField, "")
	}
	if r.suggestMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_mode", r.suggestMode, "")
	}
	if r.suggestSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_size", r.suggestSize, "")
	}
	if r.suggestText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_text", r.suggestText, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.trackScores != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_scores", r.trackScores, "")
	}
	if r.trackTotalHits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_total_hits", r.trackTotalHits, "")
	}
	if r.allowPartialSearchResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_partial_search_results", r.allowPartialSearchResults, "")
	} else {
		var defaultValue bool = true
		r.allowPartialSearchResults = &defaultValue
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.seqNoPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seq_no_primary_term", r.seqNoPrimaryTerm, "")
	}
	if r.requestCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_cache", r.requestCache, "")
	}
	if r.batchedReduceSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batched_reduce_size", r.batchedReduceSize, "")
	} else {
		var defaultValue int32 = 512
		r.batchedReduceSize = &defaultValue
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.searchBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchShardsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	preference *string
	routing *string
	local *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Specify the node or shard the operation should be performed on.
func (r ApiSearchShardsGetRequest) Preference(preference string) ApiSearchShardsGetRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r ApiSearchShardsGetRequest) Routing(routing string) ApiSearchShardsGetRequest {
	r.routing = &routing
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiSearchShardsGetRequest) Local(local bool) ApiSearchShardsGetRequest {
	r.local = &local
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiSearchShardsGetRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSearchShardsGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiSearchShardsGetRequest) AllowNoIndices(allowNoIndices bool) ApiSearchShardsGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiSearchShardsGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiSearchShardsGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiSearchShardsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchShardsGetExecute(r)
}

/*
SearchShardsGet Method for SearchShardsGet

Returns information about the indices and shards that a search request would be executed against.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchShardsGetRequest
*/
func (a *DefaultAPIService) SearchShardsGet(ctx context.Context) ApiSearchShardsGetRequest {
	return ApiSearchShardsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchShardsGetExecute(r ApiSearchShardsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchShardsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search_shards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchShardsGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	preference *string
	routing *string
	local *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Specify the node or shard the operation should be performed on.
func (r ApiSearchShardsGetWithIndexRequest) Preference(preference string) ApiSearchShardsGetWithIndexRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r ApiSearchShardsGetWithIndexRequest) Routing(routing string) ApiSearchShardsGetWithIndexRequest {
	r.routing = &routing
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiSearchShardsGetWithIndexRequest) Local(local bool) ApiSearchShardsGetWithIndexRequest {
	r.local = &local
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiSearchShardsGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSearchShardsGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiSearchShardsGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiSearchShardsGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiSearchShardsGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiSearchShardsGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiSearchShardsGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchShardsGetWithIndexExecute(r)
}

/*
SearchShardsGetWithIndex Method for SearchShardsGetWithIndex

Returns information about the indices and shards that a search request would be executed against.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiSearchShardsGetWithIndexRequest
*/
func (a *DefaultAPIService) SearchShardsGetWithIndex(ctx context.Context, index string) ApiSearchShardsGetWithIndexRequest {
	return ApiSearchShardsGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchShardsGetWithIndexExecute(r ApiSearchShardsGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchShardsGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_search_shards"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchShardsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	preference *string
	routing *string
	local *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Specify the node or shard the operation should be performed on.
func (r ApiSearchShardsPostRequest) Preference(preference string) ApiSearchShardsPostRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r ApiSearchShardsPostRequest) Routing(routing string) ApiSearchShardsPostRequest {
	r.routing = &routing
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiSearchShardsPostRequest) Local(local bool) ApiSearchShardsPostRequest {
	r.local = &local
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiSearchShardsPostRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSearchShardsPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiSearchShardsPostRequest) AllowNoIndices(allowNoIndices bool) ApiSearchShardsPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiSearchShardsPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiSearchShardsPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiSearchShardsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchShardsPostExecute(r)
}

/*
SearchShardsPost Method for SearchShardsPost

Returns information about the indices and shards that a search request would be executed against.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchShardsPostRequest
*/
func (a *DefaultAPIService) SearchShardsPost(ctx context.Context) ApiSearchShardsPostRequest {
	return ApiSearchShardsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchShardsPostExecute(r ApiSearchShardsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchShardsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search_shards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchShardsPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	preference *string
	routing *string
	local *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Specify the node or shard the operation should be performed on.
func (r ApiSearchShardsPostWithIndexRequest) Preference(preference string) ApiSearchShardsPostWithIndexRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r ApiSearchShardsPostWithIndexRequest) Routing(routing string) ApiSearchShardsPostWithIndexRequest {
	r.routing = &routing
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiSearchShardsPostWithIndexRequest) Local(local bool) ApiSearchShardsPostWithIndexRequest {
	r.local = &local
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiSearchShardsPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSearchShardsPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiSearchShardsPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiSearchShardsPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiSearchShardsPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiSearchShardsPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r ApiSearchShardsPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchShardsPostWithIndexExecute(r)
}

/*
SearchShardsPostWithIndex Method for SearchShardsPostWithIndex

Returns information about the indices and shards that a search request would be executed against.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiSearchShardsPostWithIndexRequest
*/
func (a *DefaultAPIService) SearchShardsPostWithIndex(ctx context.Context, index string) ApiSearchShardsPostWithIndexRequest {
	return ApiSearchShardsPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchShardsPostWithIndexExecute(r ApiSearchShardsPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchShardsPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_search_shards"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchTemplateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	preference *string
	routing *[]string
	scroll *string
	searchType *SearchTypeMulti
	explain *bool
	profile *bool
	typedKeys *bool
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiSearchTemplateGetRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSearchTemplateGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r ApiSearchTemplateGetRequest) IgnoreThrottled(ignoreThrottled bool) ApiSearchTemplateGetRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiSearchTemplateGetRequest) AllowNoIndices(allowNoIndices bool) ApiSearchTemplateGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiSearchTemplateGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiSearchTemplateGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiSearchTemplateGetRequest) Preference(preference string) ApiSearchTemplateGetRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r ApiSearchTemplateGetRequest) Routing(routing []string) ApiSearchTemplateGetRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiSearchTemplateGetRequest) Scroll(scroll string) ApiSearchTemplateGetRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r ApiSearchTemplateGetRequest) SearchType(searchType SearchTypeMulti) ApiSearchTemplateGetRequest {
	r.searchType = &searchType
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r ApiSearchTemplateGetRequest) Explain(explain bool) ApiSearchTemplateGetRequest {
	r.explain = &explain
	return r
}

// Specify whether to profile the query execution.
func (r ApiSearchTemplateGetRequest) Profile(profile bool) ApiSearchTemplateGetRequest {
	r.profile = &profile
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiSearchTemplateGetRequest) TypedKeys(typedKeys bool) ApiSearchTemplateGetRequest {
	r.typedKeys = &typedKeys
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiSearchTemplateGetRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiSearchTemplateGetRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiSearchTemplateGetRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiSearchTemplateGetRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r ApiSearchTemplateGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchTemplateGetExecute(r)
}

/*
SearchTemplateGet Method for SearchTemplateGet

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchTemplateGetRequest
*/
func (a *DefaultAPIService) SearchTemplateGet(ctx context.Context) ApiSearchTemplateGetRequest {
	return ApiSearchTemplateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchTemplateGetExecute(r ApiSearchTemplateGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchTemplateGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchTemplateGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	preference *string
	routing *[]string
	scroll *string
	searchType *SearchTypeMulti
	explain *bool
	profile *bool
	typedKeys *bool
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiSearchTemplateGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSearchTemplateGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r ApiSearchTemplateGetWithIndexRequest) IgnoreThrottled(ignoreThrottled bool) ApiSearchTemplateGetWithIndexRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiSearchTemplateGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiSearchTemplateGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiSearchTemplateGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiSearchTemplateGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiSearchTemplateGetWithIndexRequest) Preference(preference string) ApiSearchTemplateGetWithIndexRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r ApiSearchTemplateGetWithIndexRequest) Routing(routing []string) ApiSearchTemplateGetWithIndexRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiSearchTemplateGetWithIndexRequest) Scroll(scroll string) ApiSearchTemplateGetWithIndexRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r ApiSearchTemplateGetWithIndexRequest) SearchType(searchType SearchTypeMulti) ApiSearchTemplateGetWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r ApiSearchTemplateGetWithIndexRequest) Explain(explain bool) ApiSearchTemplateGetWithIndexRequest {
	r.explain = &explain
	return r
}

// Specify whether to profile the query execution.
func (r ApiSearchTemplateGetWithIndexRequest) Profile(profile bool) ApiSearchTemplateGetWithIndexRequest {
	r.profile = &profile
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiSearchTemplateGetWithIndexRequest) TypedKeys(typedKeys bool) ApiSearchTemplateGetWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiSearchTemplateGetWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiSearchTemplateGetWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiSearchTemplateGetWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiSearchTemplateGetWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r ApiSearchTemplateGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchTemplateGetWithIndexExecute(r)
}

/*
SearchTemplateGetWithIndex Method for SearchTemplateGetWithIndex

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiSearchTemplateGetWithIndexRequest
*/
func (a *DefaultAPIService) SearchTemplateGetWithIndex(ctx context.Context, index string) ApiSearchTemplateGetWithIndexRequest {
	return ApiSearchTemplateGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchTemplateGetWithIndexExecute(r ApiSearchTemplateGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchTemplateGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_search/template"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchTemplatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	preference *string
	routing *[]string
	scroll *string
	searchType *SearchTypeMulti
	explain *bool
	profile *bool
	typedKeys *bool
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

func (r ApiSearchTemplatePostRequest) Body(body map[string]interface{}) ApiSearchTemplatePostRequest {
	r.body = &body
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiSearchTemplatePostRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSearchTemplatePostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r ApiSearchTemplatePostRequest) IgnoreThrottled(ignoreThrottled bool) ApiSearchTemplatePostRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiSearchTemplatePostRequest) AllowNoIndices(allowNoIndices bool) ApiSearchTemplatePostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiSearchTemplatePostRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiSearchTemplatePostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiSearchTemplatePostRequest) Preference(preference string) ApiSearchTemplatePostRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r ApiSearchTemplatePostRequest) Routing(routing []string) ApiSearchTemplatePostRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiSearchTemplatePostRequest) Scroll(scroll string) ApiSearchTemplatePostRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r ApiSearchTemplatePostRequest) SearchType(searchType SearchTypeMulti) ApiSearchTemplatePostRequest {
	r.searchType = &searchType
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r ApiSearchTemplatePostRequest) Explain(explain bool) ApiSearchTemplatePostRequest {
	r.explain = &explain
	return r
}

// Specify whether to profile the query execution.
func (r ApiSearchTemplatePostRequest) Profile(profile bool) ApiSearchTemplatePostRequest {
	r.profile = &profile
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiSearchTemplatePostRequest) TypedKeys(typedKeys bool) ApiSearchTemplatePostRequest {
	r.typedKeys = &typedKeys
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiSearchTemplatePostRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiSearchTemplatePostRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiSearchTemplatePostRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiSearchTemplatePostRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r ApiSearchTemplatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchTemplatePostExecute(r)
}

/*
SearchTemplatePost Method for SearchTemplatePost

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchTemplatePostRequest
*/
func (a *DefaultAPIService) SearchTemplatePost(ctx context.Context) ApiSearchTemplatePostRequest {
	return ApiSearchTemplatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchTemplatePostExecute(r ApiSearchTemplatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchTemplatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchTemplatePostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	preference *string
	routing *[]string
	scroll *string
	searchType *SearchTypeMulti
	explain *bool
	profile *bool
	typedKeys *bool
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

func (r ApiSearchTemplatePostWithIndexRequest) Body(body map[string]interface{}) ApiSearchTemplatePostWithIndexRequest {
	r.body = &body
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiSearchTemplatePostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSearchTemplatePostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r ApiSearchTemplatePostWithIndexRequest) IgnoreThrottled(ignoreThrottled bool) ApiSearchTemplatePostWithIndexRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiSearchTemplatePostWithIndexRequest) AllowNoIndices(allowNoIndices bool) ApiSearchTemplatePostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiSearchTemplatePostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiSearchTemplatePostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiSearchTemplatePostWithIndexRequest) Preference(preference string) ApiSearchTemplatePostWithIndexRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r ApiSearchTemplatePostWithIndexRequest) Routing(routing []string) ApiSearchTemplatePostWithIndexRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiSearchTemplatePostWithIndexRequest) Scroll(scroll string) ApiSearchTemplatePostWithIndexRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r ApiSearchTemplatePostWithIndexRequest) SearchType(searchType SearchTypeMulti) ApiSearchTemplatePostWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r ApiSearchTemplatePostWithIndexRequest) Explain(explain bool) ApiSearchTemplatePostWithIndexRequest {
	r.explain = &explain
	return r
}

// Specify whether to profile the query execution.
func (r ApiSearchTemplatePostWithIndexRequest) Profile(profile bool) ApiSearchTemplatePostWithIndexRequest {
	r.profile = &profile
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r ApiSearchTemplatePostWithIndexRequest) TypedKeys(typedKeys bool) ApiSearchTemplatePostWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r ApiSearchTemplatePostWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) ApiSearchTemplatePostWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r ApiSearchTemplatePostWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) ApiSearchTemplatePostWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r ApiSearchTemplatePostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchTemplatePostWithIndexExecute(r)
}

/*
SearchTemplatePostWithIndex Method for SearchTemplatePostWithIndex

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiSearchTemplatePostWithIndexRequest
*/
func (a *DefaultAPIService) SearchTemplatePostWithIndex(ctx context.Context, index string) ApiSearchTemplatePostWithIndexRequest {
	return ApiSearchTemplatePostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchTemplatePostWithIndexExecute(r ApiSearchTemplatePostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchTemplatePostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_search/template"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSecurityHealthRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiSecurityHealthRequest) Execute() (*SecurityHealthResponseContent, *http.Response, error) {
	return r.ApiService.SecurityHealthExecute(r)
}

/*
SecurityHealth Method for SecurityHealth

Checks to see if the Security plugin is up and running.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSecurityHealthRequest
*/
func (a *DefaultAPIService) SecurityHealth(ctx context.Context) ApiSecurityHealthRequest {
	return ApiSecurityHealthRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SecurityHealthResponseContent
func (a *DefaultAPIService) SecurityHealthExecute(r ApiSecurityHealthRequest) (*SecurityHealthResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecurityHealthResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SecurityHealth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSnapshotCleanupRepositoryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
}

// Operation timeout for connection to master node.
func (r ApiSnapshotCleanupRepositoryRequest) MasterTimeout(masterTimeout string) ApiSnapshotCleanupRepositoryRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotCleanupRepositoryRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotCleanupRepositoryRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r ApiSnapshotCleanupRepositoryRequest) Timeout(timeout string) ApiSnapshotCleanupRepositoryRequest {
	r.timeout = &timeout
	return r
}

func (r ApiSnapshotCleanupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotCleanupRepositoryExecute(r)
}

/*
SnapshotCleanupRepository Method for SnapshotCleanupRepository

Removes stale data from repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @return ApiSnapshotCleanupRepositoryRequest
*/
func (a *DefaultAPIService) SnapshotCleanupRepository(ctx context.Context, repository string) ApiSnapshotCleanupRepositoryRequest {
	return ApiSnapshotCleanupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotCleanupRepositoryExecute(r ApiSnapshotCleanupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotCleanupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/_cleanup"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotCloneRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	snapshot string
	targetSnapshot string
	body *map[string]interface{}
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r ApiSnapshotCloneRequest) Body(body map[string]interface{}) ApiSnapshotCloneRequest {
	r.body = &body
	return r
}

// Operation timeout for connection to master node.
func (r ApiSnapshotCloneRequest) MasterTimeout(masterTimeout string) ApiSnapshotCloneRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotCloneRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotCloneRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiSnapshotCloneRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotCloneExecute(r)
}

/*
SnapshotClone Method for SnapshotClone

Clones indices from one snapshot into another snapshot in the same repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @param snapshot Snapshot name.
 @param targetSnapshot The name of the cloned snapshot to create.
 @return ApiSnapshotCloneRequest
*/
func (a *DefaultAPIService) SnapshotClone(ctx context.Context, repository string, snapshot string, targetSnapshot string) ApiSnapshotCloneRequest {
	return ApiSnapshotCloneRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
		snapshot: snapshot,
		targetSnapshot: targetSnapshot,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotCloneExecute(r ApiSnapshotCloneRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotClone")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/{snapshot}/_clone/{target_snapshot}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot"+"}", url.PathEscape(parameterValueToString(r.snapshot, "snapshot")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target_snapshot"+"}", url.PathEscape(parameterValueToString(r.targetSnapshot, "targetSnapshot")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotCreatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	snapshot string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForCompletion *bool
	body *map[string]interface{}
}

// Operation timeout for connection to master node.
func (r ApiSnapshotCreatePostRequest) MasterTimeout(masterTimeout string) ApiSnapshotCreatePostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotCreatePostRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotCreatePostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Should this request wait until the operation has completed before returning.
func (r ApiSnapshotCreatePostRequest) WaitForCompletion(waitForCompletion bool) ApiSnapshotCreatePostRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

func (r ApiSnapshotCreatePostRequest) Body(body map[string]interface{}) ApiSnapshotCreatePostRequest {
	r.body = &body
	return r
}

func (r ApiSnapshotCreatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotCreatePostExecute(r)
}

/*
SnapshotCreatePost Method for SnapshotCreatePost

Creates a snapshot in a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @param snapshot Snapshot name.
 @return ApiSnapshotCreatePostRequest
*/
func (a *DefaultAPIService) SnapshotCreatePost(ctx context.Context, repository string, snapshot string) ApiSnapshotCreatePostRequest {
	return ApiSnapshotCreatePostRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
		snapshot: snapshot,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotCreatePostExecute(r ApiSnapshotCreatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotCreatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/{snapshot}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot"+"}", url.PathEscape(parameterValueToString(r.snapshot, "snapshot")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotCreatePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	snapshot string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForCompletion *bool
	body *map[string]interface{}
}

// Operation timeout for connection to master node.
func (r ApiSnapshotCreatePutRequest) MasterTimeout(masterTimeout string) ApiSnapshotCreatePutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotCreatePutRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotCreatePutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Should this request wait until the operation has completed before returning.
func (r ApiSnapshotCreatePutRequest) WaitForCompletion(waitForCompletion bool) ApiSnapshotCreatePutRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

func (r ApiSnapshotCreatePutRequest) Body(body map[string]interface{}) ApiSnapshotCreatePutRequest {
	r.body = &body
	return r
}

func (r ApiSnapshotCreatePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotCreatePutExecute(r)
}

/*
SnapshotCreatePut Method for SnapshotCreatePut

Creates a snapshot in a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @param snapshot Snapshot name.
 @return ApiSnapshotCreatePutRequest
*/
func (a *DefaultAPIService) SnapshotCreatePut(ctx context.Context, repository string, snapshot string) ApiSnapshotCreatePutRequest {
	return ApiSnapshotCreatePutRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
		snapshot: snapshot,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotCreatePutExecute(r ApiSnapshotCreatePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotCreatePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/{snapshot}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot"+"}", url.PathEscape(parameterValueToString(r.snapshot, "snapshot")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotCreateRepositoryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	body *map[string]interface{}
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	verify *bool
}

func (r ApiSnapshotCreateRepositoryPostRequest) Body(body map[string]interface{}) ApiSnapshotCreateRepositoryPostRequest {
	r.body = &body
	return r
}

// Operation timeout for connection to master node.
func (r ApiSnapshotCreateRepositoryPostRequest) MasterTimeout(masterTimeout string) ApiSnapshotCreateRepositoryPostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotCreateRepositoryPostRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotCreateRepositoryPostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r ApiSnapshotCreateRepositoryPostRequest) Timeout(timeout string) ApiSnapshotCreateRepositoryPostRequest {
	r.timeout = &timeout
	return r
}

// Whether to verify the repository after creation.
func (r ApiSnapshotCreateRepositoryPostRequest) Verify(verify bool) ApiSnapshotCreateRepositoryPostRequest {
	r.verify = &verify
	return r
}

func (r ApiSnapshotCreateRepositoryPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotCreateRepositoryPostExecute(r)
}

/*
SnapshotCreateRepositoryPost Method for SnapshotCreateRepositoryPost

Creates a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @return ApiSnapshotCreateRepositoryPostRequest
*/
func (a *DefaultAPIService) SnapshotCreateRepositoryPost(ctx context.Context, repository string) ApiSnapshotCreateRepositoryPostRequest {
	return ApiSnapshotCreateRepositoryPostRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotCreateRepositoryPostExecute(r ApiSnapshotCreateRepositoryPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotCreateRepositoryPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.verify != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verify", r.verify, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotCreateRepositoryPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	body *map[string]interface{}
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	verify *bool
}

func (r ApiSnapshotCreateRepositoryPutRequest) Body(body map[string]interface{}) ApiSnapshotCreateRepositoryPutRequest {
	r.body = &body
	return r
}

// Operation timeout for connection to master node.
func (r ApiSnapshotCreateRepositoryPutRequest) MasterTimeout(masterTimeout string) ApiSnapshotCreateRepositoryPutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotCreateRepositoryPutRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotCreateRepositoryPutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r ApiSnapshotCreateRepositoryPutRequest) Timeout(timeout string) ApiSnapshotCreateRepositoryPutRequest {
	r.timeout = &timeout
	return r
}

// Whether to verify the repository after creation.
func (r ApiSnapshotCreateRepositoryPutRequest) Verify(verify bool) ApiSnapshotCreateRepositoryPutRequest {
	r.verify = &verify
	return r
}

func (r ApiSnapshotCreateRepositoryPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotCreateRepositoryPutExecute(r)
}

/*
SnapshotCreateRepositoryPut Method for SnapshotCreateRepositoryPut

Creates a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @return ApiSnapshotCreateRepositoryPutRequest
*/
func (a *DefaultAPIService) SnapshotCreateRepositoryPut(ctx context.Context, repository string) ApiSnapshotCreateRepositoryPutRequest {
	return ApiSnapshotCreateRepositoryPutRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotCreateRepositoryPutExecute(r ApiSnapshotCreateRepositoryPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotCreateRepositoryPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.verify != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verify", r.verify, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	snapshot string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout for connection to master node.
func (r ApiSnapshotDeleteRequest) MasterTimeout(masterTimeout string) ApiSnapshotDeleteRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotDeleteRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotDeleteRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r ApiSnapshotDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotDeleteExecute(r)
}

/*
SnapshotDelete Method for SnapshotDelete

Deletes a snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @param snapshot Snapshot name.
 @return ApiSnapshotDeleteRequest
*/
func (a *DefaultAPIService) SnapshotDelete(ctx context.Context, repository string, snapshot string) ApiSnapshotDeleteRequest {
	return ApiSnapshotDeleteRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
		snapshot: snapshot,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotDeleteExecute(r ApiSnapshotDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/{snapshot}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot"+"}", url.PathEscape(parameterValueToString(r.snapshot, "snapshot")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotDeleteRepositoryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
}

// Operation timeout for connection to master node.
func (r ApiSnapshotDeleteRepositoryRequest) MasterTimeout(masterTimeout string) ApiSnapshotDeleteRepositoryRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotDeleteRepositoryRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotDeleteRepositoryRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r ApiSnapshotDeleteRepositoryRequest) Timeout(timeout string) ApiSnapshotDeleteRepositoryRequest {
	r.timeout = &timeout
	return r
}

func (r ApiSnapshotDeleteRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotDeleteRepositoryExecute(r)
}

/*
SnapshotDeleteRepository Method for SnapshotDeleteRepository

Deletes a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Name of the snapshot repository to unregister. Wildcard (`*`) patterns are supported.
 @return ApiSnapshotDeleteRepositoryRequest
*/
func (a *DefaultAPIService) SnapshotDeleteRepository(ctx context.Context, repository string) ApiSnapshotDeleteRepositoryRequest {
	return ApiSnapshotDeleteRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotDeleteRepositoryExecute(r ApiSnapshotDeleteRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotDeleteRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	snapshot string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	verbose *bool
}

// Operation timeout for connection to master node.
func (r ApiSnapshotGetRequest) MasterTimeout(masterTimeout string) ApiSnapshotGetRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotGetRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotGetRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
func (r ApiSnapshotGetRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSnapshotGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to show verbose snapshot info or only show the basic info found in the repository index blob.
func (r ApiSnapshotGetRequest) Verbose(verbose bool) ApiSnapshotGetRequest {
	r.verbose = &verbose
	return r
}

func (r ApiSnapshotGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotGetExecute(r)
}

/*
SnapshotGet Method for SnapshotGet

Returns information about a snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @param snapshot Comma-separated list of snapshot names.
 @return ApiSnapshotGetRequest
*/
func (a *DefaultAPIService) SnapshotGet(ctx context.Context, repository string, snapshot string) ApiSnapshotGetRequest {
	return ApiSnapshotGetRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
		snapshot: snapshot,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotGetExecute(r ApiSnapshotGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/{snapshot}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot"+"}", url.PathEscape(parameterValueToString(r.snapshot, "snapshot")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotGetRepositoryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Operation timeout for connection to master node.
func (r ApiSnapshotGetRepositoryRequest) MasterTimeout(masterTimeout string) ApiSnapshotGetRepositoryRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotGetRepositoryRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotGetRepositoryRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiSnapshotGetRepositoryRequest) Local(local bool) ApiSnapshotGetRepositoryRequest {
	r.local = &local
	return r
}

func (r ApiSnapshotGetRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotGetRepositoryExecute(r)
}

/*
SnapshotGetRepository Method for SnapshotGetRepository

Returns information about a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSnapshotGetRepositoryRequest
*/
func (a *DefaultAPIService) SnapshotGetRepository(ctx context.Context) ApiSnapshotGetRepositoryRequest {
	return ApiSnapshotGetRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotGetRepositoryExecute(r ApiSnapshotGetRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotGetRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotGetRepositoryWithRepositoryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Operation timeout for connection to master node.
func (r ApiSnapshotGetRepositoryWithRepositoryRequest) MasterTimeout(masterTimeout string) ApiSnapshotGetRepositoryWithRepositoryRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotGetRepositoryWithRepositoryRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotGetRepositoryWithRepositoryRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r ApiSnapshotGetRepositoryWithRepositoryRequest) Local(local bool) ApiSnapshotGetRepositoryWithRepositoryRequest {
	r.local = &local
	return r
}

func (r ApiSnapshotGetRepositoryWithRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotGetRepositoryWithRepositoryExecute(r)
}

/*
SnapshotGetRepositoryWithRepository Method for SnapshotGetRepositoryWithRepository

Returns information about a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Comma-separated list of repository names.
 @return ApiSnapshotGetRepositoryWithRepositoryRequest
*/
func (a *DefaultAPIService) SnapshotGetRepositoryWithRepository(ctx context.Context, repository string) ApiSnapshotGetRepositoryWithRepositoryRequest {
	return ApiSnapshotGetRepositoryWithRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotGetRepositoryWithRepositoryExecute(r ApiSnapshotGetRepositoryWithRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotGetRepositoryWithRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotRestoreRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	snapshot string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForCompletion *bool
	body *map[string]interface{}
}

// Operation timeout for connection to master node.
func (r ApiSnapshotRestoreRequest) MasterTimeout(masterTimeout string) ApiSnapshotRestoreRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotRestoreRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotRestoreRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Should this request wait until the operation has completed before returning.
func (r ApiSnapshotRestoreRequest) WaitForCompletion(waitForCompletion bool) ApiSnapshotRestoreRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

func (r ApiSnapshotRestoreRequest) Body(body map[string]interface{}) ApiSnapshotRestoreRequest {
	r.body = &body
	return r
}

func (r ApiSnapshotRestoreRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotRestoreExecute(r)
}

/*
SnapshotRestore Method for SnapshotRestore

Restores a snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @param snapshot Snapshot name.
 @return ApiSnapshotRestoreRequest
*/
func (a *DefaultAPIService) SnapshotRestore(ctx context.Context, repository string, snapshot string) ApiSnapshotRestoreRequest {
	return ApiSnapshotRestoreRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
		snapshot: snapshot,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotRestoreExecute(r ApiSnapshotRestoreRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotRestore")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/{snapshot}/_restore"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot"+"}", url.PathEscape(parameterValueToString(r.snapshot, "snapshot")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotStatusRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
}

// Operation timeout for connection to master node.
func (r ApiSnapshotStatusRequest) MasterTimeout(masterTimeout string) ApiSnapshotStatusRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotStatusRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotStatusRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
func (r ApiSnapshotStatusRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSnapshotStatusRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

func (r ApiSnapshotStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotStatusExecute(r)
}

/*
SnapshotStatus Method for SnapshotStatus

Returns information about the status of a snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSnapshotStatusRequest
*/
func (a *DefaultAPIService) SnapshotStatus(ctx context.Context) ApiSnapshotStatusRequest {
	return ApiSnapshotStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotStatusExecute(r ApiSnapshotStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/_status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotStatusWithRepositoryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
}

// Operation timeout for connection to master node.
func (r ApiSnapshotStatusWithRepositoryRequest) MasterTimeout(masterTimeout string) ApiSnapshotStatusWithRepositoryRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotStatusWithRepositoryRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotStatusWithRepositoryRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
func (r ApiSnapshotStatusWithRepositoryRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSnapshotStatusWithRepositoryRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

func (r ApiSnapshotStatusWithRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotStatusWithRepositoryExecute(r)
}

/*
SnapshotStatusWithRepository Method for SnapshotStatusWithRepository

Returns information about the status of a snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @return ApiSnapshotStatusWithRepositoryRequest
*/
func (a *DefaultAPIService) SnapshotStatusWithRepository(ctx context.Context, repository string) ApiSnapshotStatusWithRepositoryRequest {
	return ApiSnapshotStatusWithRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotStatusWithRepositoryExecute(r ApiSnapshotStatusWithRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotStatusWithRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/_status"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotStatusWithRepositorySnapshotRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	snapshot string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
}

// Operation timeout for connection to master node.
func (r ApiSnapshotStatusWithRepositorySnapshotRequest) MasterTimeout(masterTimeout string) ApiSnapshotStatusWithRepositorySnapshotRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotStatusWithRepositorySnapshotRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotStatusWithRepositorySnapshotRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
func (r ApiSnapshotStatusWithRepositorySnapshotRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiSnapshotStatusWithRepositorySnapshotRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

func (r ApiSnapshotStatusWithRepositorySnapshotRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotStatusWithRepositorySnapshotExecute(r)
}

/*
SnapshotStatusWithRepositorySnapshot Method for SnapshotStatusWithRepositorySnapshot

Returns information about the status of a snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @param snapshot Comma-separated list of snapshot names.
 @return ApiSnapshotStatusWithRepositorySnapshotRequest
*/
func (a *DefaultAPIService) SnapshotStatusWithRepositorySnapshot(ctx context.Context, repository string, snapshot string) ApiSnapshotStatusWithRepositorySnapshotRequest {
	return ApiSnapshotStatusWithRepositorySnapshotRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
		snapshot: snapshot,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotStatusWithRepositorySnapshotExecute(r ApiSnapshotStatusWithRepositorySnapshotRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotStatusWithRepositorySnapshot")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/{snapshot}/_status"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot"+"}", url.PathEscape(parameterValueToString(r.snapshot, "snapshot")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnapshotVerifyRepositoryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
}

// Operation timeout for connection to master node.
func (r ApiSnapshotVerifyRepositoryRequest) MasterTimeout(masterTimeout string) ApiSnapshotVerifyRepositoryRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r ApiSnapshotVerifyRepositoryRequest) ClusterManagerTimeout(clusterManagerTimeout string) ApiSnapshotVerifyRepositoryRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r ApiSnapshotVerifyRepositoryRequest) Timeout(timeout string) ApiSnapshotVerifyRepositoryRequest {
	r.timeout = &timeout
	return r
}

func (r ApiSnapshotVerifyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotVerifyRepositoryExecute(r)
}

/*
SnapshotVerifyRepository Method for SnapshotVerifyRepository

Verifies a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @return ApiSnapshotVerifyRepositoryRequest
*/
func (a *DefaultAPIService) SnapshotVerifyRepository(ctx context.Context, repository string) ApiSnapshotVerifyRepositoryRequest {
	return ApiSnapshotVerifyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotVerifyRepositoryExecute(r ApiSnapshotVerifyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotVerifyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/_verify"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTasksCancelRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodes *[]string
	actions *[]string
	parentTaskId *string
	waitForCompletion *bool
}

// Comma-separated list of node IDs or names to limit the returned information; use &#x60;_local&#x60; to return information from the node you&#39;re connecting to, leave empty to get information from all nodes.
func (r ApiTasksCancelRequest) Nodes(nodes []string) ApiTasksCancelRequest {
	r.nodes = &nodes
	return r
}

// Comma-separated list of actions that should be cancelled. Leave empty to cancel all.
func (r ApiTasksCancelRequest) Actions(actions []string) ApiTasksCancelRequest {
	r.actions = &actions
	return r
}

// Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
func (r ApiTasksCancelRequest) ParentTaskId(parentTaskId string) ApiTasksCancelRequest {
	r.parentTaskId = &parentTaskId
	return r
}

// Should this request wait until the operation has completed before returning.
func (r ApiTasksCancelRequest) WaitForCompletion(waitForCompletion bool) ApiTasksCancelRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

func (r ApiTasksCancelRequest) Execute() (*http.Response, error) {
	return r.ApiService.TasksCancelExecute(r)
}

/*
TasksCancel Method for TasksCancel

Cancels a task, if it can be cancelled through an API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTasksCancelRequest
*/
func (a *DefaultAPIService) TasksCancel(ctx context.Context) ApiTasksCancelRequest {
	return ApiTasksCancelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TasksCancelExecute(r ApiTasksCancelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TasksCancel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_tasks/_cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodes != nil {
		t := *r.nodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", t, "multi")
		}
	}
	if r.actions != nil {
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "multi")
		}
	}
	if r.parentTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_task_id", r.parentTaskId, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTasksCancelWithTaskIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	nodes *[]string
	actions *[]string
	parentTaskId *string
	waitForCompletion *bool
}

// Comma-separated list of node IDs or names to limit the returned information; use &#x60;_local&#x60; to return information from the node you&#39;re connecting to, leave empty to get information from all nodes.
func (r ApiTasksCancelWithTaskIdRequest) Nodes(nodes []string) ApiTasksCancelWithTaskIdRequest {
	r.nodes = &nodes
	return r
}

// Comma-separated list of actions that should be cancelled. Leave empty to cancel all.
func (r ApiTasksCancelWithTaskIdRequest) Actions(actions []string) ApiTasksCancelWithTaskIdRequest {
	r.actions = &actions
	return r
}

// Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
func (r ApiTasksCancelWithTaskIdRequest) ParentTaskId(parentTaskId string) ApiTasksCancelWithTaskIdRequest {
	r.parentTaskId = &parentTaskId
	return r
}

// Should this request wait until the operation has completed before returning.
func (r ApiTasksCancelWithTaskIdRequest) WaitForCompletion(waitForCompletion bool) ApiTasksCancelWithTaskIdRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

func (r ApiTasksCancelWithTaskIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.TasksCancelWithTaskIdExecute(r)
}

/*
TasksCancelWithTaskId Method for TasksCancelWithTaskId

Cancels a task, if it can be cancelled through an API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId Cancel the task with specified task id (node_id:task_number).
 @return ApiTasksCancelWithTaskIdRequest
*/
func (a *DefaultAPIService) TasksCancelWithTaskId(ctx context.Context, taskId string) ApiTasksCancelWithTaskIdRequest {
	return ApiTasksCancelWithTaskIdRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TasksCancelWithTaskIdExecute(r ApiTasksCancelWithTaskIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TasksCancelWithTaskId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_tasks/{task_id}/_cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodes != nil {
		t := *r.nodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", t, "multi")
		}
	}
	if r.actions != nil {
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "multi")
		}
	}
	if r.parentTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_task_id", r.parentTaskId, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTasksGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	waitForCompletion *bool
	timeout *string
}

// Should this request wait until the operation has completed before returning.
func (r ApiTasksGetRequest) WaitForCompletion(waitForCompletion bool) ApiTasksGetRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

// Operation timeout.
func (r ApiTasksGetRequest) Timeout(timeout string) ApiTasksGetRequest {
	r.timeout = &timeout
	return r
}

func (r ApiTasksGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.TasksGetExecute(r)
}

/*
TasksGet Method for TasksGet

Returns information about a task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId Return the task with specified id (node_id:task_number).
 @return ApiTasksGetRequest
*/
func (a *DefaultAPIService) TasksGet(ctx context.Context, taskId string) ApiTasksGetRequest {
	return ApiTasksGetRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TasksGetExecute(r ApiTasksGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TasksGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_tasks/{task_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTasksListRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodes *[]string
	actions *[]string
	detailed *bool
	parentTaskId *string
	waitForCompletion *bool
	groupBy *GroupBy
	timeout *string
}

// Comma-separated list of node IDs or names to limit the returned information; use &#x60;_local&#x60; to return information from the node you&#39;re connecting to, leave empty to get information from all nodes.
func (r ApiTasksListRequest) Nodes(nodes []string) ApiTasksListRequest {
	r.nodes = &nodes
	return r
}

// Comma-separated list of actions that should be returned. Leave empty to return all.
func (r ApiTasksListRequest) Actions(actions []string) ApiTasksListRequest {
	r.actions = &actions
	return r
}

// Return detailed task information.
func (r ApiTasksListRequest) Detailed(detailed bool) ApiTasksListRequest {
	r.detailed = &detailed
	return r
}

// Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
func (r ApiTasksListRequest) ParentTaskId(parentTaskId string) ApiTasksListRequest {
	r.parentTaskId = &parentTaskId
	return r
}

// Should this request wait until the operation has completed before returning.
func (r ApiTasksListRequest) WaitForCompletion(waitForCompletion bool) ApiTasksListRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

// Group tasks by nodes or parent/child relationships.
func (r ApiTasksListRequest) GroupBy(groupBy GroupBy) ApiTasksListRequest {
	r.groupBy = &groupBy
	return r
}

// Operation timeout.
func (r ApiTasksListRequest) Timeout(timeout string) ApiTasksListRequest {
	r.timeout = &timeout
	return r
}

func (r ApiTasksListRequest) Execute() (*http.Response, error) {
	return r.ApiService.TasksListExecute(r)
}

/*
TasksList Method for TasksList

Returns a list of tasks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTasksListRequest
*/
func (a *DefaultAPIService) TasksList(ctx context.Context) ApiTasksListRequest {
	return ApiTasksListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TasksListExecute(r ApiTasksListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TasksList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodes != nil {
		t := *r.nodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", t, "multi")
		}
	}
	if r.actions != nil {
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "multi")
		}
	}
	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.parentTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_task_id", r.parentTaskId, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	if r.groupBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", r.groupBy, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTermvectorsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
}

// Specifies if total term frequency and document frequency should be returned.
func (r ApiTermvectorsGetRequest) TermStatistics(termStatistics bool) ApiTermvectorsGetRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
func (r ApiTermvectorsGetRequest) FieldStatistics(fieldStatistics bool) ApiTermvectorsGetRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return.
func (r ApiTermvectorsGetRequest) Fields(fields []string) ApiTermvectorsGetRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned.
func (r ApiTermvectorsGetRequest) Offsets(offsets bool) ApiTermvectorsGetRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned.
func (r ApiTermvectorsGetRequest) Positions(positions bool) ApiTermvectorsGetRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned.
func (r ApiTermvectorsGetRequest) Payloads(payloads bool) ApiTermvectorsGetRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiTermvectorsGetRequest) Preference(preference string) ApiTermvectorsGetRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r ApiTermvectorsGetRequest) Routing(routing string) ApiTermvectorsGetRequest {
	r.routing = &routing
	return r
}

// Specifies if request is real-time as opposed to near-real-time.
func (r ApiTermvectorsGetRequest) Realtime(realtime bool) ApiTermvectorsGetRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r ApiTermvectorsGetRequest) Version(version int32) ApiTermvectorsGetRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiTermvectorsGetRequest) VersionType(versionType VersionType) ApiTermvectorsGetRequest {
	r.versionType = &versionType
	return r
}

func (r ApiTermvectorsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.TermvectorsGetExecute(r)
}

/*
TermvectorsGet Method for TermvectorsGet

Returns information and statistics about terms in the fields of a particular document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The index in which the document resides.
 @return ApiTermvectorsGetRequest
*/
func (a *DefaultAPIService) TermvectorsGet(ctx context.Context, index string) ApiTermvectorsGetRequest {
	return ApiTermvectorsGetRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TermvectorsGetExecute(r ApiTermvectorsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TermvectorsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_termvectors"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTermvectorsGetWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	id string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
}

// Specifies if total term frequency and document frequency should be returned.
func (r ApiTermvectorsGetWithIdRequest) TermStatistics(termStatistics bool) ApiTermvectorsGetWithIdRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
func (r ApiTermvectorsGetWithIdRequest) FieldStatistics(fieldStatistics bool) ApiTermvectorsGetWithIdRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return.
func (r ApiTermvectorsGetWithIdRequest) Fields(fields []string) ApiTermvectorsGetWithIdRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned.
func (r ApiTermvectorsGetWithIdRequest) Offsets(offsets bool) ApiTermvectorsGetWithIdRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned.
func (r ApiTermvectorsGetWithIdRequest) Positions(positions bool) ApiTermvectorsGetWithIdRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned.
func (r ApiTermvectorsGetWithIdRequest) Payloads(payloads bool) ApiTermvectorsGetWithIdRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiTermvectorsGetWithIdRequest) Preference(preference string) ApiTermvectorsGetWithIdRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r ApiTermvectorsGetWithIdRequest) Routing(routing string) ApiTermvectorsGetWithIdRequest {
	r.routing = &routing
	return r
}

// Specifies if request is real-time as opposed to near-real-time.
func (r ApiTermvectorsGetWithIdRequest) Realtime(realtime bool) ApiTermvectorsGetWithIdRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r ApiTermvectorsGetWithIdRequest) Version(version int32) ApiTermvectorsGetWithIdRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiTermvectorsGetWithIdRequest) VersionType(versionType VersionType) ApiTermvectorsGetWithIdRequest {
	r.versionType = &versionType
	return r
}

func (r ApiTermvectorsGetWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.TermvectorsGetWithIdExecute(r)
}

/*
TermvectorsGetWithId Method for TermvectorsGetWithId

Returns information and statistics about terms in the fields of a particular document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The index in which the document resides.
 @param id Document ID. When not specified a doc param should be supplied.
 @return ApiTermvectorsGetWithIdRequest
*/
func (a *DefaultAPIService) TermvectorsGetWithId(ctx context.Context, index string, id string) ApiTermvectorsGetWithIdRequest {
	return ApiTermvectorsGetWithIdRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TermvectorsGetWithIdExecute(r ApiTermvectorsGetWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TermvectorsGetWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_termvectors/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTermvectorsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
	body *map[string]interface{}
}

// Specifies if total term frequency and document frequency should be returned.
func (r ApiTermvectorsPostRequest) TermStatistics(termStatistics bool) ApiTermvectorsPostRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
func (r ApiTermvectorsPostRequest) FieldStatistics(fieldStatistics bool) ApiTermvectorsPostRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return.
func (r ApiTermvectorsPostRequest) Fields(fields []string) ApiTermvectorsPostRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned.
func (r ApiTermvectorsPostRequest) Offsets(offsets bool) ApiTermvectorsPostRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned.
func (r ApiTermvectorsPostRequest) Positions(positions bool) ApiTermvectorsPostRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned.
func (r ApiTermvectorsPostRequest) Payloads(payloads bool) ApiTermvectorsPostRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiTermvectorsPostRequest) Preference(preference string) ApiTermvectorsPostRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r ApiTermvectorsPostRequest) Routing(routing string) ApiTermvectorsPostRequest {
	r.routing = &routing
	return r
}

// Specifies if request is real-time as opposed to near-real-time.
func (r ApiTermvectorsPostRequest) Realtime(realtime bool) ApiTermvectorsPostRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r ApiTermvectorsPostRequest) Version(version int32) ApiTermvectorsPostRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiTermvectorsPostRequest) VersionType(versionType VersionType) ApiTermvectorsPostRequest {
	r.versionType = &versionType
	return r
}

func (r ApiTermvectorsPostRequest) Body(body map[string]interface{}) ApiTermvectorsPostRequest {
	r.body = &body
	return r
}

func (r ApiTermvectorsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.TermvectorsPostExecute(r)
}

/*
TermvectorsPost Method for TermvectorsPost

Returns information and statistics about terms in the fields of a particular document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The index in which the document resides.
 @return ApiTermvectorsPostRequest
*/
func (a *DefaultAPIService) TermvectorsPost(ctx context.Context, index string) ApiTermvectorsPostRequest {
	return ApiTermvectorsPostRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TermvectorsPostExecute(r ApiTermvectorsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TermvectorsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_termvectors"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTermvectorsPostWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	id string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
	body *map[string]interface{}
}

// Specifies if total term frequency and document frequency should be returned.
func (r ApiTermvectorsPostWithIdRequest) TermStatistics(termStatistics bool) ApiTermvectorsPostWithIdRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
func (r ApiTermvectorsPostWithIdRequest) FieldStatistics(fieldStatistics bool) ApiTermvectorsPostWithIdRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return.
func (r ApiTermvectorsPostWithIdRequest) Fields(fields []string) ApiTermvectorsPostWithIdRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned.
func (r ApiTermvectorsPostWithIdRequest) Offsets(offsets bool) ApiTermvectorsPostWithIdRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned.
func (r ApiTermvectorsPostWithIdRequest) Positions(positions bool) ApiTermvectorsPostWithIdRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned.
func (r ApiTermvectorsPostWithIdRequest) Payloads(payloads bool) ApiTermvectorsPostWithIdRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiTermvectorsPostWithIdRequest) Preference(preference string) ApiTermvectorsPostWithIdRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r ApiTermvectorsPostWithIdRequest) Routing(routing string) ApiTermvectorsPostWithIdRequest {
	r.routing = &routing
	return r
}

// Specifies if request is real-time as opposed to near-real-time.
func (r ApiTermvectorsPostWithIdRequest) Realtime(realtime bool) ApiTermvectorsPostWithIdRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r ApiTermvectorsPostWithIdRequest) Version(version int32) ApiTermvectorsPostWithIdRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r ApiTermvectorsPostWithIdRequest) VersionType(versionType VersionType) ApiTermvectorsPostWithIdRequest {
	r.versionType = &versionType
	return r
}

func (r ApiTermvectorsPostWithIdRequest) Body(body map[string]interface{}) ApiTermvectorsPostWithIdRequest {
	r.body = &body
	return r
}

func (r ApiTermvectorsPostWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.TermvectorsPostWithIdExecute(r)
}

/*
TermvectorsPostWithId Method for TermvectorsPostWithId

Returns information and statistics about terms in the fields of a particular document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The index in which the document resides.
 @param id Document ID. When not specified a doc param should be supplied.
 @return ApiTermvectorsPostWithIdRequest
*/
func (a *DefaultAPIService) TermvectorsPostWithId(ctx context.Context, index string, id string) ApiTermvectorsPostWithIdRequest {
	return ApiTermvectorsPostWithIdRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TermvectorsPostWithIdExecute(r ApiTermvectorsPostWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TermvectorsPostWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_termvectors/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	lang *string
	refresh *RefreshEnum
	retryOnConflict *int32
	routing *string
	timeout *string
	ifSeqNo *int32
	ifPrimaryTerm *int32
	requireAlias *bool
}

func (r ApiUpdateRequest) Body(body map[string]interface{}) ApiUpdateRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r ApiUpdateRequest) WaitForActiveShards(waitForActiveShards string) ApiUpdateRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiUpdateRequest) Source(source []string) ApiUpdateRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiUpdateRequest) SourceExcludes(sourceExcludes []string) ApiUpdateRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiUpdateRequest) SourceIncludes(sourceIncludes []string) ApiUpdateRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The script language.
func (r ApiUpdateRequest) Lang(lang string) ApiUpdateRequest {
	r.lang = &lang
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r ApiUpdateRequest) Refresh(refresh RefreshEnum) ApiUpdateRequest {
	r.refresh = &refresh
	return r
}

// Specify how many times should the operation be retried when a conflict occurs.
func (r ApiUpdateRequest) RetryOnConflict(retryOnConflict int32) ApiUpdateRequest {
	r.retryOnConflict = &retryOnConflict
	return r
}

// Routing value.
func (r ApiUpdateRequest) Routing(routing string) ApiUpdateRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r ApiUpdateRequest) Timeout(timeout string) ApiUpdateRequest {
	r.timeout = &timeout
	return r
}

// only perform the operation if the last operation that has changed the document has the specified sequence number.
func (r ApiUpdateRequest) IfSeqNo(ifSeqNo int32) ApiUpdateRequest {
	r.ifSeqNo = &ifSeqNo
	return r
}

// only perform the operation if the last operation that has changed the document has the specified primary term.
func (r ApiUpdateRequest) IfPrimaryTerm(ifPrimaryTerm int32) ApiUpdateRequest {
	r.ifPrimaryTerm = &ifPrimaryTerm
	return r
}

// When true, requires destination to be an alias.
func (r ApiUpdateRequest) RequireAlias(requireAlias bool) ApiUpdateRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r ApiUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateExecute(r)
}

/*
Update Method for Update

Updates a document with a script or partial document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return ApiUpdateRequest
*/
func (a *DefaultAPIService) Update(ctx context.Context, id string, index string) ApiUpdateRequest {
	return ApiUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) UpdateExecute(r ApiUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Update")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_update/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.lang != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang", r.lang, "")
	} else {
		var defaultValue string = "painless"
		r.lang = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.retryOnConflict != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retry_on_conflict", r.retryOnConflict, "")
	} else {
		var defaultValue int32 = 0
		r.retryOnConflict = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.ifSeqNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_seq_no", r.ifSeqNo, "")
	}
	if r.ifPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_primary_term", r.ifPrimaryTerm, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAuditConfigurationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	auditConfig *AuditConfig
}

func (r ApiUpdateAuditConfigurationRequest) AuditConfig(auditConfig AuditConfig) ApiUpdateAuditConfigurationRequest {
	r.auditConfig = &auditConfig
	return r
}

func (r ApiUpdateAuditConfigurationRequest) Execute() (*UpdateAuditConfigurationResponseContent, *http.Response, error) {
	return r.ApiService.UpdateAuditConfigurationExecute(r)
}

/*
UpdateAuditConfiguration Method for UpdateAuditConfiguration

Updates the audit configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuditConfigurationRequest
*/
func (a *DefaultAPIService) UpdateAuditConfiguration(ctx context.Context) ApiUpdateAuditConfigurationRequest {
	return ApiUpdateAuditConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateAuditConfigurationResponseContent
func (a *DefaultAPIService) UpdateAuditConfigurationExecute(r ApiUpdateAuditConfigurationRequest) (*UpdateAuditConfigurationResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateAuditConfigurationResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateAuditConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/audit/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.auditConfig == nil {
		return localVarReturnValue, nil, reportError("auditConfig is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.auditConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateByQueryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	from *int32
	ignoreUnavailable *bool
	allowNoIndices *bool
	conflicts *Conflicts
	expandWildcards *ExpandWildcards
	lenient *bool
	pipeline *string
	preference *string
	q *string
	routing *[]string
	scroll *string
	searchType *SearchType
	searchTimeout *string
	size *int32
	maxDocs *int32
	sort *[]string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	terminateAfter *int32
	stats *[]string
	version *bool
	requestCache *bool
	refresh *bool
	timeout *string
	waitForActiveShards *string
	scrollSize *int32
	waitForCompletion *bool
	requestsPerSecond *int32
	slices *string
	body *map[string]interface{}
}

// The analyzer to use for the query string.
func (r ApiUpdateByQueryRequest) Analyzer(analyzer string) ApiUpdateByQueryRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r ApiUpdateByQueryRequest) AnalyzeWildcard(analyzeWildcard bool) ApiUpdateByQueryRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r ApiUpdateByQueryRequest) DefaultOperator(defaultOperator DefaultOperator) ApiUpdateByQueryRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r ApiUpdateByQueryRequest) Df(df string) ApiUpdateByQueryRequest {
	r.df = &df
	return r
}

// Starting offset.
func (r ApiUpdateByQueryRequest) From(from int32) ApiUpdateByQueryRequest {
	r.from = &from
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r ApiUpdateByQueryRequest) IgnoreUnavailable(ignoreUnavailable bool) ApiUpdateByQueryRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r ApiUpdateByQueryRequest) AllowNoIndices(allowNoIndices bool) ApiUpdateByQueryRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// What to do when the operation encounters version conflicts?.
func (r ApiUpdateByQueryRequest) Conflicts(conflicts Conflicts) ApiUpdateByQueryRequest {
	r.conflicts = &conflicts
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r ApiUpdateByQueryRequest) ExpandWildcards(expandWildcards ExpandWildcards) ApiUpdateByQueryRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r ApiUpdateByQueryRequest) Lenient(lenient bool) ApiUpdateByQueryRequest {
	r.lenient = &lenient
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r ApiUpdateByQueryRequest) Pipeline(pipeline string) ApiUpdateByQueryRequest {
	r.pipeline = &pipeline
	return r
}

// Specify the node or shard the operation should be performed on.
func (r ApiUpdateByQueryRequest) Preference(preference string) ApiUpdateByQueryRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r ApiUpdateByQueryRequest) Q(q string) ApiUpdateByQueryRequest {
	r.q = &q
	return r
}

// Comma-separated list of specific routing values.
func (r ApiUpdateByQueryRequest) Routing(routing []string) ApiUpdateByQueryRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r ApiUpdateByQueryRequest) Scroll(scroll string) ApiUpdateByQueryRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r ApiUpdateByQueryRequest) SearchType(searchType SearchType) ApiUpdateByQueryRequest {
	r.searchType = &searchType
	return r
}

// Explicit timeout for each search request. Defaults to no timeout.
func (r ApiUpdateByQueryRequest) SearchTimeout(searchTimeout string) ApiUpdateByQueryRequest {
	r.searchTimeout = &searchTimeout
	return r
}

// Deprecated, please use &#x60;max_docs&#x60; instead.
func (r ApiUpdateByQueryRequest) Size(size int32) ApiUpdateByQueryRequest {
	r.size = &size
	return r
}

// Maximum number of documents to process (default: all documents).
func (r ApiUpdateByQueryRequest) MaxDocs(maxDocs int32) ApiUpdateByQueryRequest {
	r.maxDocs = &maxDocs
	return r
}

// Comma-separated list of &lt;field&gt;:&lt;direction&gt; pairs.
func (r ApiUpdateByQueryRequest) Sort(sort []string) ApiUpdateByQueryRequest {
	r.sort = &sort
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r ApiUpdateByQueryRequest) Source(source []string) ApiUpdateByQueryRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r ApiUpdateByQueryRequest) SourceExcludes(sourceExcludes []string) ApiUpdateByQueryRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r ApiUpdateByQueryRequest) SourceIncludes(sourceIncludes []string) ApiUpdateByQueryRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r ApiUpdateByQueryRequest) TerminateAfter(terminateAfter int32) ApiUpdateByQueryRequest {
	r.terminateAfter = &terminateAfter
	return r
}

// Specific &#39;tag&#39; of the request for logging and statistical purposes.
func (r ApiUpdateByQueryRequest) Stats(stats []string) ApiUpdateByQueryRequest {
	r.stats = &stats
	return r
}

// Whether to return document version as part of a hit.
func (r ApiUpdateByQueryRequest) Version(version bool) ApiUpdateByQueryRequest {
	r.version = &version
	return r
}

// Specify if request cache should be used for this request or not, defaults to index level setting.
func (r ApiUpdateByQueryRequest) RequestCache(requestCache bool) ApiUpdateByQueryRequest {
	r.requestCache = &requestCache
	return r
}

// Should the affected indexes be refreshed?.
func (r ApiUpdateByQueryRequest) Refresh(refresh bool) ApiUpdateByQueryRequest {
	r.refresh = &refresh
	return r
}

// Time each individual bulk request should wait for shards that are unavailable.
func (r ApiUpdateByQueryRequest) Timeout(timeout string) ApiUpdateByQueryRequest {
	r.timeout = &timeout
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r ApiUpdateByQueryRequest) WaitForActiveShards(waitForActiveShards string) ApiUpdateByQueryRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Size on the scroll request powering the operation.
func (r ApiUpdateByQueryRequest) ScrollSize(scrollSize int32) ApiUpdateByQueryRequest {
	r.scrollSize = &scrollSize
	return r
}

// Should this request wait until the operation has completed before returning.
func (r ApiUpdateByQueryRequest) WaitForCompletion(waitForCompletion bool) ApiUpdateByQueryRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

// The throttle for this request in sub-requests per second. -1 means no throttle.
func (r ApiUpdateByQueryRequest) RequestsPerSecond(requestsPerSecond int32) ApiUpdateByQueryRequest {
	r.requestsPerSecond = &requestsPerSecond
	return r
}

// The number of slices this task should be divided into. Defaults to 1, meaning the task isn&#39;t sliced into subtasks. Can be set to &#x60;auto&#x60;.
func (r ApiUpdateByQueryRequest) Slices(slices string) ApiUpdateByQueryRequest {
	r.slices = &slices
	return r
}

func (r ApiUpdateByQueryRequest) Body(body map[string]interface{}) ApiUpdateByQueryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateByQueryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateByQueryExecute(r)
}

/*
UpdateByQuery Method for UpdateByQuery

Performs an update on every document in the index without changing the source,
for example to pick up a mapping change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return ApiUpdateByQueryRequest
*/
func (a *DefaultAPIService) UpdateByQuery(ctx context.Context, index string) ApiUpdateByQueryRequest {
	return ApiUpdateByQueryRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) UpdateByQueryExecute(r ApiUpdateByQueryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateByQuery")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_update_by_query"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	} else {
		var defaultValue int32 = 0
		r.from = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.searchTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_timeout", r.searchTimeout, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.maxDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_docs", r.maxDocs, "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	if r.stats != nil {
		t := *r.stats
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stats", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stats", t, "multi")
		}
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.requestCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_cache", r.requestCache, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	} else {
		var defaultValue string = "1m"
		r.timeout = &defaultValue
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.scrollSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll_size", r.scrollSize, "")
	} else {
		var defaultValue int32 = 100
		r.scrollSize = &defaultValue
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = true
		r.waitForCompletion = &defaultValue
	}
	if r.requestsPerSecond != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requests_per_second", r.requestsPerSecond, "")
	} else {
		var defaultValue int32 = 0
		r.requestsPerSecond = &defaultValue
	}
	if r.slices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slices", r.slices, "")
	} else {
		var defaultValue string = "1"
		r.slices = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateByQueryRethrottleRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	requestsPerSecond *int32
}

// The throttle for this request in sub-requests per second. -1 means no throttle.
func (r ApiUpdateByQueryRethrottleRequest) RequestsPerSecond(requestsPerSecond int32) ApiUpdateByQueryRethrottleRequest {
	r.requestsPerSecond = &requestsPerSecond
	return r
}

func (r ApiUpdateByQueryRethrottleRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateByQueryRethrottleExecute(r)
}

/*
UpdateByQueryRethrottle Method for UpdateByQueryRethrottle

Changes the number of requests per second for a particular Update By Query operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id to rethrottle.
 @return ApiUpdateByQueryRethrottleRequest
*/
func (a *DefaultAPIService) UpdateByQueryRethrottle(ctx context.Context, taskId string) ApiUpdateByQueryRethrottleRequest {
	return ApiUpdateByQueryRethrottleRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) UpdateByQueryRethrottleExecute(r ApiUpdateByQueryRethrottleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateByQueryRethrottle")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_update_by_query/{task_id}/_rethrottle"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestsPerSecond == nil {
		return nil, reportError("requestsPerSecond is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "requests_per_second", r.requestsPerSecond, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateConfigurationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	dynamicConfig *DynamicConfig
}

func (r ApiUpdateConfigurationRequest) DynamicConfig(dynamicConfig DynamicConfig) ApiUpdateConfigurationRequest {
	r.dynamicConfig = &dynamicConfig
	return r
}

func (r ApiUpdateConfigurationRequest) Execute() (*UpdateConfigurationResponseContent, *http.Response, error) {
	return r.ApiService.UpdateConfigurationExecute(r)
}

/*
UpdateConfiguration Method for UpdateConfiguration

Adds or updates the existing configuration using the REST API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateConfigurationRequest
*/
func (a *DefaultAPIService) UpdateConfiguration(ctx context.Context) ApiUpdateConfigurationRequest {
	return ApiUpdateConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateConfigurationResponseContent
func (a *DefaultAPIService) UpdateConfigurationExecute(r ApiUpdateConfigurationRequest) (*UpdateConfigurationResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateConfigurationResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/securityconfig/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dynamicConfig == nil {
		return localVarReturnValue, nil, reportError("dynamicConfig is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dynamicConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDistinguishedNamesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	clusterName string
	distinguishedNames *DistinguishedNames
}

func (r ApiUpdateDistinguishedNamesRequest) DistinguishedNames(distinguishedNames DistinguishedNames) ApiUpdateDistinguishedNamesRequest {
	r.distinguishedNames = &distinguishedNames
	return r
}

func (r ApiUpdateDistinguishedNamesRequest) Execute() (*UpdateDistinguishedNamesResponseContent, *http.Response, error) {
	return r.ApiService.UpdateDistinguishedNamesExecute(r)
}

/*
UpdateDistinguishedNames Method for UpdateDistinguishedNames

Adds or updates the specified distinguished names in the cluster’s or node’s allow list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName
 @return ApiUpdateDistinguishedNamesRequest
*/
func (a *DefaultAPIService) UpdateDistinguishedNames(ctx context.Context, clusterName string) ApiUpdateDistinguishedNamesRequest {
	return ApiUpdateDistinguishedNamesRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return UpdateDistinguishedNamesResponseContent
func (a *DefaultAPIService) UpdateDistinguishedNamesExecute(r ApiUpdateDistinguishedNamesRequest) (*UpdateDistinguishedNamesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateDistinguishedNamesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateDistinguishedNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/nodesdn/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.distinguishedNames
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
