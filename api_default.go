/*
OpenSearch

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2021-11-23
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package opensearch

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type DefaultAPIBulkPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	waitForActiveShards *string
	refresh *RefreshEnum
	routing *string
	timeout *string
	type_ *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	pipeline *string
	requireAlias *bool
}

func (r DefaultAPIBulkPostRequest) Body(body map[string]interface{}) DefaultAPIBulkPostRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r DefaultAPIBulkPostRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIBulkPostRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r DefaultAPIBulkPostRequest) Refresh(refresh RefreshEnum) DefaultAPIBulkPostRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIBulkPostRequest) Routing(routing string) DefaultAPIBulkPostRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r DefaultAPIBulkPostRequest) Timeout(timeout string) DefaultAPIBulkPostRequest {
	r.timeout = &timeout
	return r
}

// Default document type for items which don&#39;t provide one.
func (r DefaultAPIBulkPostRequest) Type_(type_ string) DefaultAPIBulkPostRequest {
	r.type_ = &type_
	return r
}

// True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
func (r DefaultAPIBulkPostRequest) Source(source []string) DefaultAPIBulkPostRequest {
	r.source = &source
	return r
}

// Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
func (r DefaultAPIBulkPostRequest) SourceExcludes(sourceExcludes []string) DefaultAPIBulkPostRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
func (r DefaultAPIBulkPostRequest) SourceIncludes(sourceIncludes []string) DefaultAPIBulkPostRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r DefaultAPIBulkPostRequest) Pipeline(pipeline string) DefaultAPIBulkPostRequest {
	r.pipeline = &pipeline
	return r
}

// Sets require_alias for all incoming documents.
func (r DefaultAPIBulkPostRequest) RequireAlias(requireAlias bool) DefaultAPIBulkPostRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r DefaultAPIBulkPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkPostExecute(r)
}

/*
BulkPost Method for BulkPost

Allows to perform multiple index/update/delete operations in a single request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIBulkPostRequest
*/
func (a *DefaultAPIService) BulkPost(ctx context.Context) DefaultAPIBulkPostRequest {
	return DefaultAPIBulkPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) BulkPostExecute(r DefaultAPIBulkPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.BulkPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIBulkPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	refresh *RefreshEnum
	routing *string
	timeout *string
	type_ *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	pipeline *string
	requireAlias *bool
}

func (r DefaultAPIBulkPostWithIndexRequest) Body(body map[string]interface{}) DefaultAPIBulkPostWithIndexRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r DefaultAPIBulkPostWithIndexRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIBulkPostWithIndexRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r DefaultAPIBulkPostWithIndexRequest) Refresh(refresh RefreshEnum) DefaultAPIBulkPostWithIndexRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIBulkPostWithIndexRequest) Routing(routing string) DefaultAPIBulkPostWithIndexRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r DefaultAPIBulkPostWithIndexRequest) Timeout(timeout string) DefaultAPIBulkPostWithIndexRequest {
	r.timeout = &timeout
	return r
}

// Default document type for items which don&#39;t provide one.
func (r DefaultAPIBulkPostWithIndexRequest) Type_(type_ string) DefaultAPIBulkPostWithIndexRequest {
	r.type_ = &type_
	return r
}

// True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
func (r DefaultAPIBulkPostWithIndexRequest) Source(source []string) DefaultAPIBulkPostWithIndexRequest {
	r.source = &source
	return r
}

// Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
func (r DefaultAPIBulkPostWithIndexRequest) SourceExcludes(sourceExcludes []string) DefaultAPIBulkPostWithIndexRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
func (r DefaultAPIBulkPostWithIndexRequest) SourceIncludes(sourceIncludes []string) DefaultAPIBulkPostWithIndexRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r DefaultAPIBulkPostWithIndexRequest) Pipeline(pipeline string) DefaultAPIBulkPostWithIndexRequest {
	r.pipeline = &pipeline
	return r
}

// Sets require_alias for all incoming documents.
func (r DefaultAPIBulkPostWithIndexRequest) RequireAlias(requireAlias bool) DefaultAPIBulkPostWithIndexRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r DefaultAPIBulkPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkPostWithIndexExecute(r)
}

/*
BulkPostWithIndex Method for BulkPostWithIndex

Allows to perform multiple index/update/delete operations in a single request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Default index for items which don't provide one.
 @return DefaultAPIBulkPostWithIndexRequest
*/
func (a *DefaultAPIService) BulkPostWithIndex(ctx context.Context, index string) DefaultAPIBulkPostWithIndexRequest {
	return DefaultAPIBulkPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) BulkPostWithIndexExecute(r DefaultAPIBulkPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.BulkPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIBulkPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	waitForActiveShards *string
	refresh *RefreshEnum
	routing *string
	timeout *string
	type_ *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	pipeline *string
	requireAlias *bool
}

func (r DefaultAPIBulkPutRequest) Body(body map[string]interface{}) DefaultAPIBulkPutRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r DefaultAPIBulkPutRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIBulkPutRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r DefaultAPIBulkPutRequest) Refresh(refresh RefreshEnum) DefaultAPIBulkPutRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIBulkPutRequest) Routing(routing string) DefaultAPIBulkPutRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r DefaultAPIBulkPutRequest) Timeout(timeout string) DefaultAPIBulkPutRequest {
	r.timeout = &timeout
	return r
}

// Default document type for items which don&#39;t provide one.
func (r DefaultAPIBulkPutRequest) Type_(type_ string) DefaultAPIBulkPutRequest {
	r.type_ = &type_
	return r
}

// True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
func (r DefaultAPIBulkPutRequest) Source(source []string) DefaultAPIBulkPutRequest {
	r.source = &source
	return r
}

// Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
func (r DefaultAPIBulkPutRequest) SourceExcludes(sourceExcludes []string) DefaultAPIBulkPutRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
func (r DefaultAPIBulkPutRequest) SourceIncludes(sourceIncludes []string) DefaultAPIBulkPutRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r DefaultAPIBulkPutRequest) Pipeline(pipeline string) DefaultAPIBulkPutRequest {
	r.pipeline = &pipeline
	return r
}

// Sets require_alias for all incoming documents.
func (r DefaultAPIBulkPutRequest) RequireAlias(requireAlias bool) DefaultAPIBulkPutRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r DefaultAPIBulkPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkPutExecute(r)
}

/*
BulkPut Method for BulkPut

Allows to perform multiple index/update/delete operations in a single request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIBulkPutRequest
*/
func (a *DefaultAPIService) BulkPut(ctx context.Context) DefaultAPIBulkPutRequest {
	return DefaultAPIBulkPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) BulkPutExecute(r DefaultAPIBulkPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.BulkPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIBulkPutWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	refresh *RefreshEnum
	routing *string
	timeout *string
	type_ *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	pipeline *string
	requireAlias *bool
}

func (r DefaultAPIBulkPutWithIndexRequest) Body(body map[string]interface{}) DefaultAPIBulkPutWithIndexRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r DefaultAPIBulkPutWithIndexRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIBulkPutWithIndexRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r DefaultAPIBulkPutWithIndexRequest) Refresh(refresh RefreshEnum) DefaultAPIBulkPutWithIndexRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIBulkPutWithIndexRequest) Routing(routing string) DefaultAPIBulkPutWithIndexRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r DefaultAPIBulkPutWithIndexRequest) Timeout(timeout string) DefaultAPIBulkPutWithIndexRequest {
	r.timeout = &timeout
	return r
}

// Default document type for items which don&#39;t provide one.
func (r DefaultAPIBulkPutWithIndexRequest) Type_(type_ string) DefaultAPIBulkPutWithIndexRequest {
	r.type_ = &type_
	return r
}

// True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
func (r DefaultAPIBulkPutWithIndexRequest) Source(source []string) DefaultAPIBulkPutWithIndexRequest {
	r.source = &source
	return r
}

// Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
func (r DefaultAPIBulkPutWithIndexRequest) SourceExcludes(sourceExcludes []string) DefaultAPIBulkPutWithIndexRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
func (r DefaultAPIBulkPutWithIndexRequest) SourceIncludes(sourceIncludes []string) DefaultAPIBulkPutWithIndexRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r DefaultAPIBulkPutWithIndexRequest) Pipeline(pipeline string) DefaultAPIBulkPutWithIndexRequest {
	r.pipeline = &pipeline
	return r
}

// Sets require_alias for all incoming documents.
func (r DefaultAPIBulkPutWithIndexRequest) RequireAlias(requireAlias bool) DefaultAPIBulkPutWithIndexRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r DefaultAPIBulkPutWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkPutWithIndexExecute(r)
}

/*
BulkPutWithIndex Method for BulkPutWithIndex

Allows to perform multiple index/update/delete operations in a single request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Default index for items which don't provide one.
 @return DefaultAPIBulkPutWithIndexRequest
*/
func (a *DefaultAPIService) BulkPutWithIndex(ctx context.Context, index string) DefaultAPIBulkPutWithIndexRequest {
	return DefaultAPIBulkPutWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) BulkPutWithIndexExecute(r DefaultAPIBulkPutWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.BulkPutWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatAliasesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	h *[]string
	help *bool
	s *[]string
	v *bool
	expandWildcards *ExpandWildcards
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatAliasesRequest) Format(format string) DefaultAPICatAliasesRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatAliasesRequest) Local(local bool) DefaultAPICatAliasesRequest {
	r.local = &local
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatAliasesRequest) H(h []string) DefaultAPICatAliasesRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatAliasesRequest) Help(help bool) DefaultAPICatAliasesRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatAliasesRequest) S(s []string) DefaultAPICatAliasesRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatAliasesRequest) V(v bool) DefaultAPICatAliasesRequest {
	r.v = &v
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPICatAliasesRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPICatAliasesRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPICatAliasesRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatAliasesExecute(r)
}

/*
CatAliases Method for CatAliases

Shows information about currently configured aliases to indices including filter and routing infos.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatAliasesRequest
*/
func (a *DefaultAPIService) CatAliases(ctx context.Context) DefaultAPICatAliasesRequest {
	return DefaultAPICatAliasesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatAliasesExecute(r DefaultAPICatAliasesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatAliases")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/aliases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatAliasesWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	format *string
	local *bool
	h *[]string
	help *bool
	s *[]string
	v *bool
	expandWildcards *ExpandWildcards
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatAliasesWithNameRequest) Format(format string) DefaultAPICatAliasesWithNameRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatAliasesWithNameRequest) Local(local bool) DefaultAPICatAliasesWithNameRequest {
	r.local = &local
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatAliasesWithNameRequest) H(h []string) DefaultAPICatAliasesWithNameRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatAliasesWithNameRequest) Help(help bool) DefaultAPICatAliasesWithNameRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatAliasesWithNameRequest) S(s []string) DefaultAPICatAliasesWithNameRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatAliasesWithNameRequest) V(v bool) DefaultAPICatAliasesWithNameRequest {
	r.v = &v
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPICatAliasesWithNameRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPICatAliasesWithNameRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPICatAliasesWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatAliasesWithNameExecute(r)
}

/*
CatAliasesWithName Method for CatAliasesWithName

Shows information about currently configured aliases to indices including filter and routing infos.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of alias names.
 @return DefaultAPICatAliasesWithNameRequest
*/
func (a *DefaultAPIService) CatAliasesWithName(ctx context.Context, name string) DefaultAPICatAliasesWithNameRequest {
	return DefaultAPICatAliasesWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatAliasesWithNameExecute(r DefaultAPICatAliasesWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatAliasesWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/aliases/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatAllPitSegmentsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPICatAllPitSegmentsRequest) Execute() (*CatAllPitSegmentsResponseContent, *http.Response, error) {
	return r.ApiService.CatAllPitSegmentsExecute(r)
}

/*
CatAllPitSegments Method for CatAllPitSegments

Lists all active point-in-time segments.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatAllPitSegmentsRequest
*/
func (a *DefaultAPIService) CatAllPitSegments(ctx context.Context) DefaultAPICatAllPitSegmentsRequest {
	return DefaultAPICatAllPitSegmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CatAllPitSegmentsResponseContent
func (a *DefaultAPIService) CatAllPitSegmentsExecute(r DefaultAPICatAllPitSegmentsRequest) (*CatAllPitSegmentsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatAllPitSegmentsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatAllPitSegments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/pit_segments/_all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICatAllocationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	bytes *Bytes
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatAllocationRequest) Format(format string) DefaultAPICatAllocationRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r DefaultAPICatAllocationRequest) Bytes(bytes Bytes) DefaultAPICatAllocationRequest {
	r.bytes = &bytes
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatAllocationRequest) Local(local bool) DefaultAPICatAllocationRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatAllocationRequest) MasterTimeout(masterTimeout string) DefaultAPICatAllocationRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatAllocationRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatAllocationRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatAllocationRequest) H(h []string) DefaultAPICatAllocationRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatAllocationRequest) Help(help bool) DefaultAPICatAllocationRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatAllocationRequest) S(s []string) DefaultAPICatAllocationRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatAllocationRequest) V(v bool) DefaultAPICatAllocationRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatAllocationRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatAllocationExecute(r)
}

/*
CatAllocation Method for CatAllocation

Provides a snapshot of how many shards are allocated to each data node and how much disk space they are using.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatAllocationRequest
*/
func (a *DefaultAPIService) CatAllocation(ctx context.Context) DefaultAPICatAllocationRequest {
	return DefaultAPICatAllocationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatAllocationExecute(r DefaultAPICatAllocationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatAllocation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/allocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatAllocationWithNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	format *string
	bytes *Bytes
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatAllocationWithNodeIdRequest) Format(format string) DefaultAPICatAllocationWithNodeIdRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r DefaultAPICatAllocationWithNodeIdRequest) Bytes(bytes Bytes) DefaultAPICatAllocationWithNodeIdRequest {
	r.bytes = &bytes
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatAllocationWithNodeIdRequest) Local(local bool) DefaultAPICatAllocationWithNodeIdRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatAllocationWithNodeIdRequest) MasterTimeout(masterTimeout string) DefaultAPICatAllocationWithNodeIdRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatAllocationWithNodeIdRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatAllocationWithNodeIdRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatAllocationWithNodeIdRequest) H(h []string) DefaultAPICatAllocationWithNodeIdRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatAllocationWithNodeIdRequest) Help(help bool) DefaultAPICatAllocationWithNodeIdRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatAllocationWithNodeIdRequest) S(s []string) DefaultAPICatAllocationWithNodeIdRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatAllocationWithNodeIdRequest) V(v bool) DefaultAPICatAllocationWithNodeIdRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatAllocationWithNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatAllocationWithNodeIdExecute(r)
}

/*
CatAllocationWithNodeId Method for CatAllocationWithNodeId

Provides a snapshot of how many shards are allocated to each data node and how much disk space they are using.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information.
 @return DefaultAPICatAllocationWithNodeIdRequest
*/
func (a *DefaultAPIService) CatAllocationWithNodeId(ctx context.Context, nodeId string) DefaultAPICatAllocationWithNodeIdRequest {
	return DefaultAPICatAllocationWithNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatAllocationWithNodeIdExecute(r DefaultAPICatAllocationWithNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatAllocationWithNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/allocation/{node_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatClusterManagerRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatClusterManagerRequest) Format(format string) DefaultAPICatClusterManagerRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatClusterManagerRequest) Local(local bool) DefaultAPICatClusterManagerRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatClusterManagerRequest) MasterTimeout(masterTimeout string) DefaultAPICatClusterManagerRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatClusterManagerRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatClusterManagerRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatClusterManagerRequest) H(h []string) DefaultAPICatClusterManagerRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatClusterManagerRequest) Help(help bool) DefaultAPICatClusterManagerRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatClusterManagerRequest) S(s []string) DefaultAPICatClusterManagerRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatClusterManagerRequest) V(v bool) DefaultAPICatClusterManagerRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatClusterManagerRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatClusterManagerExecute(r)
}

/*
CatClusterManager Method for CatClusterManager

Returns information about the cluster-manager node.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatClusterManagerRequest
*/
func (a *DefaultAPIService) CatClusterManager(ctx context.Context) DefaultAPICatClusterManagerRequest {
	return DefaultAPICatClusterManagerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatClusterManagerExecute(r DefaultAPICatClusterManagerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatClusterManager")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/cluster_manager"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatCountRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatCountRequest) Format(format string) DefaultAPICatCountRequest {
	r.format = &format
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatCountRequest) H(h []string) DefaultAPICatCountRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatCountRequest) Help(help bool) DefaultAPICatCountRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatCountRequest) S(s []string) DefaultAPICatCountRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatCountRequest) V(v bool) DefaultAPICatCountRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatCountRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatCountExecute(r)
}

/*
CatCount Method for CatCount

Provides quick access to the document count of the entire cluster, or individual indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatCountRequest
*/
func (a *DefaultAPIService) CatCount(ctx context.Context) DefaultAPICatCountRequest {
	return DefaultAPICatCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatCountExecute(r DefaultAPICatCountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatCount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatCountWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	format *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatCountWithIndexRequest) Format(format string) DefaultAPICatCountWithIndexRequest {
	r.format = &format
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatCountWithIndexRequest) H(h []string) DefaultAPICatCountWithIndexRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatCountWithIndexRequest) Help(help bool) DefaultAPICatCountWithIndexRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatCountWithIndexRequest) S(s []string) DefaultAPICatCountWithIndexRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatCountWithIndexRequest) V(v bool) DefaultAPICatCountWithIndexRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatCountWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatCountWithIndexExecute(r)
}

/*
CatCountWithIndex Method for CatCountWithIndex

Provides quick access to the document count of the entire cluster, or individual indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to limit the returned information.
 @return DefaultAPICatCountWithIndexRequest
*/
func (a *DefaultAPIService) CatCountWithIndex(ctx context.Context, index string) DefaultAPICatCountWithIndexRequest {
	return DefaultAPICatCountWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatCountWithIndexExecute(r DefaultAPICatCountWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatCountWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/count/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatFielddataRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	bytes *Bytes
	h *[]string
	help *bool
	s *[]string
	v *bool
	fields *[]string
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatFielddataRequest) Format(format string) DefaultAPICatFielddataRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r DefaultAPICatFielddataRequest) Bytes(bytes Bytes) DefaultAPICatFielddataRequest {
	r.bytes = &bytes
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatFielddataRequest) H(h []string) DefaultAPICatFielddataRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatFielddataRequest) Help(help bool) DefaultAPICatFielddataRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatFielddataRequest) S(s []string) DefaultAPICatFielddataRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatFielddataRequest) V(v bool) DefaultAPICatFielddataRequest {
	r.v = &v
	return r
}

// Comma-separated list of fields to return in the output.
func (r DefaultAPICatFielddataRequest) Fields(fields []string) DefaultAPICatFielddataRequest {
	r.fields = &fields
	return r
}

func (r DefaultAPICatFielddataRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatFielddataExecute(r)
}

/*
CatFielddata Method for CatFielddata

Shows how much heap memory is currently being used by fielddata on every data node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatFielddataRequest
*/
func (a *DefaultAPIService) CatFielddata(ctx context.Context) DefaultAPICatFielddataRequest {
	return DefaultAPICatFielddataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatFielddataExecute(r DefaultAPICatFielddataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatFielddata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/fielddata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatFielddataWithFieldsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	fields string
	format *string
	bytes *Bytes
	h *[]string
	help *bool
	s *[]string
	v *bool
	fields2 *[]string
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatFielddataWithFieldsRequest) Format(format string) DefaultAPICatFielddataWithFieldsRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r DefaultAPICatFielddataWithFieldsRequest) Bytes(bytes Bytes) DefaultAPICatFielddataWithFieldsRequest {
	r.bytes = &bytes
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatFielddataWithFieldsRequest) H(h []string) DefaultAPICatFielddataWithFieldsRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatFielddataWithFieldsRequest) Help(help bool) DefaultAPICatFielddataWithFieldsRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatFielddataWithFieldsRequest) S(s []string) DefaultAPICatFielddataWithFieldsRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatFielddataWithFieldsRequest) V(v bool) DefaultAPICatFielddataWithFieldsRequest {
	r.v = &v
	return r
}

// Comma-separated list of fields to return in the output.
func (r DefaultAPICatFielddataWithFieldsRequest) Fields2(fields2 []string) DefaultAPICatFielddataWithFieldsRequest {
	r.fields2 = &fields2
	return r
}

func (r DefaultAPICatFielddataWithFieldsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatFielddataWithFieldsExecute(r)
}

/*
CatFielddataWithFields Method for CatFielddataWithFields

Shows how much heap memory is currently being used by fielddata on every data node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fields Comma-separated list of fields to return the fielddata size.
 @return DefaultAPICatFielddataWithFieldsRequest
*/
func (a *DefaultAPIService) CatFielddataWithFields(ctx context.Context, fields string) DefaultAPICatFielddataWithFieldsRequest {
	return DefaultAPICatFielddataWithFieldsRequest{
		ApiService: a,
		ctx: ctx,
		fields: fields,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatFielddataWithFieldsExecute(r DefaultAPICatFielddataWithFieldsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatFielddataWithFields")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/fielddata/{fields}"
	localVarPath = strings.Replace(localVarPath, "{"+"fields"+"}", url.PathEscape(parameterValueToString(r.fields, "fields")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	if r.fields2 != nil {
		t := *r.fields2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatHealthRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	ts *bool
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatHealthRequest) Format(format string) DefaultAPICatHealthRequest {
	r.format = &format
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatHealthRequest) H(h []string) DefaultAPICatHealthRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatHealthRequest) Help(help bool) DefaultAPICatHealthRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatHealthRequest) S(s []string) DefaultAPICatHealthRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r DefaultAPICatHealthRequest) Time(time Time) DefaultAPICatHealthRequest {
	r.time = &time
	return r
}

// Set to false to disable timestamping.
func (r DefaultAPICatHealthRequest) Ts(ts bool) DefaultAPICatHealthRequest {
	r.ts = &ts
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatHealthRequest) V(v bool) DefaultAPICatHealthRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatHealthRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatHealthExecute(r)
}

/*
CatHealth Method for CatHealth

Returns a concise representation of the cluster health.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatHealthRequest
*/
func (a *DefaultAPIService) CatHealth(ctx context.Context) DefaultAPICatHealthRequest {
	return DefaultAPICatHealthRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatHealthExecute(r DefaultAPICatHealthRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatHealth")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.ts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ts", r.ts, "")
	} else {
		var defaultValue bool = true
		r.ts = &defaultValue
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatHelpRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	help *bool
	s *[]string
}

// Return help information.
func (r DefaultAPICatHelpRequest) Help(help bool) DefaultAPICatHelpRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatHelpRequest) S(s []string) DefaultAPICatHelpRequest {
	r.s = &s
	return r
}

func (r DefaultAPICatHelpRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatHelpExecute(r)
}

/*
CatHelp Method for CatHelp

Returns help for the Cat APIs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatHelpRequest
*/
func (a *DefaultAPIService) CatHelp(ctx context.Context) DefaultAPICatHelpRequest {
	return DefaultAPICatHelpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatHelpExecute(r DefaultAPICatHelpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatHelp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatIndicesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	bytes *Bytes
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	health *Health
	help *bool
	pri *bool
	s *[]string
	time *Time
	v *bool
	includeUnloadedSegments *bool
	expandWildcards *ExpandWildcards
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatIndicesRequest) Format(format string) DefaultAPICatIndicesRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r DefaultAPICatIndicesRequest) Bytes(bytes Bytes) DefaultAPICatIndicesRequest {
	r.bytes = &bytes
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatIndicesRequest) Local(local bool) DefaultAPICatIndicesRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatIndicesRequest) MasterTimeout(masterTimeout string) DefaultAPICatIndicesRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatIndicesRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatIndicesRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatIndicesRequest) H(h []string) DefaultAPICatIndicesRequest {
	r.h = &h
	return r
}

// Health status (&#39;green&#39;, &#39;yellow&#39;, or &#39;red&#39;) to filter only indices matching the specified health status.
func (r DefaultAPICatIndicesRequest) Health(health Health) DefaultAPICatIndicesRequest {
	r.health = &health
	return r
}

// Return help information.
func (r DefaultAPICatIndicesRequest) Help(help bool) DefaultAPICatIndicesRequest {
	r.help = &help
	return r
}

// Set to true to return stats only for primary shards.
func (r DefaultAPICatIndicesRequest) Pri(pri bool) DefaultAPICatIndicesRequest {
	r.pri = &pri
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatIndicesRequest) S(s []string) DefaultAPICatIndicesRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r DefaultAPICatIndicesRequest) Time(time Time) DefaultAPICatIndicesRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatIndicesRequest) V(v bool) DefaultAPICatIndicesRequest {
	r.v = &v
	return r
}

// If set to true segment stats will include stats for segments that are not currently loaded into memory.
func (r DefaultAPICatIndicesRequest) IncludeUnloadedSegments(includeUnloadedSegments bool) DefaultAPICatIndicesRequest {
	r.includeUnloadedSegments = &includeUnloadedSegments
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPICatIndicesRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPICatIndicesRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPICatIndicesRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatIndicesExecute(r)
}

/*
CatIndices Method for CatIndices

Returns information about indices: number of primaries and replicas, document counts, disk size, ...

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatIndicesRequest
*/
func (a *DefaultAPIService) CatIndices(ctx context.Context) DefaultAPICatIndicesRequest {
	return DefaultAPICatIndicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatIndicesExecute(r DefaultAPICatIndicesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatIndices")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/indices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.health != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "health", r.health, "")
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.pri != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pri", r.pri, "")
	} else {
		var defaultValue bool = false
		r.pri = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	if r.includeUnloadedSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unloaded_segments", r.includeUnloadedSegments, "")
	} else {
		var defaultValue bool = false
		r.includeUnloadedSegments = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatIndicesWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	format *string
	bytes *Bytes
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	health *Health
	help *bool
	pri *bool
	s *[]string
	time *Time
	v *bool
	includeUnloadedSegments *bool
	expandWildcards *ExpandWildcards
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatIndicesWithIndexRequest) Format(format string) DefaultAPICatIndicesWithIndexRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r DefaultAPICatIndicesWithIndexRequest) Bytes(bytes Bytes) DefaultAPICatIndicesWithIndexRequest {
	r.bytes = &bytes
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatIndicesWithIndexRequest) Local(local bool) DefaultAPICatIndicesWithIndexRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatIndicesWithIndexRequest) MasterTimeout(masterTimeout string) DefaultAPICatIndicesWithIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatIndicesWithIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatIndicesWithIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatIndicesWithIndexRequest) H(h []string) DefaultAPICatIndicesWithIndexRequest {
	r.h = &h
	return r
}

// Health status (&#39;green&#39;, &#39;yellow&#39;, or &#39;red&#39;) to filter only indices matching the specified health status.
func (r DefaultAPICatIndicesWithIndexRequest) Health(health Health) DefaultAPICatIndicesWithIndexRequest {
	r.health = &health
	return r
}

// Return help information.
func (r DefaultAPICatIndicesWithIndexRequest) Help(help bool) DefaultAPICatIndicesWithIndexRequest {
	r.help = &help
	return r
}

// Set to true to return stats only for primary shards.
func (r DefaultAPICatIndicesWithIndexRequest) Pri(pri bool) DefaultAPICatIndicesWithIndexRequest {
	r.pri = &pri
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatIndicesWithIndexRequest) S(s []string) DefaultAPICatIndicesWithIndexRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r DefaultAPICatIndicesWithIndexRequest) Time(time Time) DefaultAPICatIndicesWithIndexRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatIndicesWithIndexRequest) V(v bool) DefaultAPICatIndicesWithIndexRequest {
	r.v = &v
	return r
}

// If set to true segment stats will include stats for segments that are not currently loaded into memory.
func (r DefaultAPICatIndicesWithIndexRequest) IncludeUnloadedSegments(includeUnloadedSegments bool) DefaultAPICatIndicesWithIndexRequest {
	r.includeUnloadedSegments = &includeUnloadedSegments
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPICatIndicesWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPICatIndicesWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPICatIndicesWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatIndicesWithIndexExecute(r)
}

/*
CatIndicesWithIndex Method for CatIndicesWithIndex

Returns information about indices: number of primaries and replicas, document counts, disk size, ...

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to limit the returned information.
 @return DefaultAPICatIndicesWithIndexRequest
*/
func (a *DefaultAPIService) CatIndicesWithIndex(ctx context.Context, index string) DefaultAPICatIndicesWithIndexRequest {
	return DefaultAPICatIndicesWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatIndicesWithIndexExecute(r DefaultAPICatIndicesWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatIndicesWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/indices/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.health != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "health", r.health, "")
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.pri != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pri", r.pri, "")
	} else {
		var defaultValue bool = false
		r.pri = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	if r.includeUnloadedSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unloaded_segments", r.includeUnloadedSegments, "")
	} else {
		var defaultValue bool = false
		r.includeUnloadedSegments = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatMasterRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatMasterRequest) Format(format string) DefaultAPICatMasterRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatMasterRequest) Local(local bool) DefaultAPICatMasterRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatMasterRequest) MasterTimeout(masterTimeout string) DefaultAPICatMasterRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatMasterRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatMasterRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatMasterRequest) H(h []string) DefaultAPICatMasterRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatMasterRequest) Help(help bool) DefaultAPICatMasterRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatMasterRequest) S(s []string) DefaultAPICatMasterRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatMasterRequest) V(v bool) DefaultAPICatMasterRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatMasterRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatMasterExecute(r)
}

/*
CatMaster Method for CatMaster

Returns information about the cluster-manager node.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatMasterRequest

Deprecated
*/
func (a *DefaultAPIService) CatMaster(ctx context.Context) DefaultAPICatMasterRequest {
	return DefaultAPICatMasterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) CatMasterExecute(r DefaultAPICatMasterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatMaster")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/master"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatNodeattrsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatNodeattrsRequest) Format(format string) DefaultAPICatNodeattrsRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatNodeattrsRequest) Local(local bool) DefaultAPICatNodeattrsRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatNodeattrsRequest) MasterTimeout(masterTimeout string) DefaultAPICatNodeattrsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatNodeattrsRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatNodeattrsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatNodeattrsRequest) H(h []string) DefaultAPICatNodeattrsRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatNodeattrsRequest) Help(help bool) DefaultAPICatNodeattrsRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatNodeattrsRequest) S(s []string) DefaultAPICatNodeattrsRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatNodeattrsRequest) V(v bool) DefaultAPICatNodeattrsRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatNodeattrsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatNodeattrsExecute(r)
}

/*
CatNodeattrs Method for CatNodeattrs

Returns information about custom node attributes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatNodeattrsRequest
*/
func (a *DefaultAPIService) CatNodeattrs(ctx context.Context) DefaultAPICatNodeattrsRequest {
	return DefaultAPICatNodeattrsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatNodeattrsExecute(r DefaultAPICatNodeattrsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatNodeattrs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/nodeattrs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatNodesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	bytes *Bytes
	format *string
	fullId *bool
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	v *bool
}

// The unit in which to display byte values.
func (r DefaultAPICatNodesRequest) Bytes(bytes Bytes) DefaultAPICatNodesRequest {
	r.bytes = &bytes
	return r
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatNodesRequest) Format(format string) DefaultAPICatNodesRequest {
	r.format = &format
	return r
}

// Return the full node ID instead of the shortened version.
func (r DefaultAPICatNodesRequest) FullId(fullId bool) DefaultAPICatNodesRequest {
	r.fullId = &fullId
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatNodesRequest) Local(local bool) DefaultAPICatNodesRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatNodesRequest) MasterTimeout(masterTimeout string) DefaultAPICatNodesRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatNodesRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatNodesRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatNodesRequest) H(h []string) DefaultAPICatNodesRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatNodesRequest) Help(help bool) DefaultAPICatNodesRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatNodesRequest) S(s []string) DefaultAPICatNodesRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r DefaultAPICatNodesRequest) Time(time Time) DefaultAPICatNodesRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatNodesRequest) V(v bool) DefaultAPICatNodesRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatNodesRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatNodesExecute(r)
}

/*
CatNodes Method for CatNodes

Returns basic statistics about performance of cluster nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatNodesRequest
*/
func (a *DefaultAPIService) CatNodes(ctx context.Context) DefaultAPICatNodesRequest {
	return DefaultAPICatNodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatNodesExecute(r DefaultAPICatNodesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatNodes")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/nodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.fullId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "full_id", r.fullId, "")
	} else {
		var defaultValue bool = false
		r.fullId = &defaultValue
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatPendingTasksRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatPendingTasksRequest) Format(format string) DefaultAPICatPendingTasksRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatPendingTasksRequest) Local(local bool) DefaultAPICatPendingTasksRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatPendingTasksRequest) MasterTimeout(masterTimeout string) DefaultAPICatPendingTasksRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatPendingTasksRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatPendingTasksRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatPendingTasksRequest) H(h []string) DefaultAPICatPendingTasksRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatPendingTasksRequest) Help(help bool) DefaultAPICatPendingTasksRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatPendingTasksRequest) S(s []string) DefaultAPICatPendingTasksRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r DefaultAPICatPendingTasksRequest) Time(time Time) DefaultAPICatPendingTasksRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatPendingTasksRequest) V(v bool) DefaultAPICatPendingTasksRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatPendingTasksRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatPendingTasksExecute(r)
}

/*
CatPendingTasks Method for CatPendingTasks

Returns a concise representation of the cluster pending tasks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatPendingTasksRequest
*/
func (a *DefaultAPIService) CatPendingTasks(ctx context.Context) DefaultAPICatPendingTasksRequest {
	return DefaultAPICatPendingTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatPendingTasksExecute(r DefaultAPICatPendingTasksRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatPendingTasks")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/pending_tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatPitSegmentsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	catPitSegmentsBodyParams *CatPitSegmentsBodyParams
}

func (r DefaultAPICatPitSegmentsRequest) CatPitSegmentsBodyParams(catPitSegmentsBodyParams CatPitSegmentsBodyParams) DefaultAPICatPitSegmentsRequest {
	r.catPitSegmentsBodyParams = &catPitSegmentsBodyParams
	return r
}

func (r DefaultAPICatPitSegmentsRequest) Execute() (*CatPitSegmentsResponseContent, *http.Response, error) {
	return r.ApiService.CatPitSegmentsExecute(r)
}

/*
CatPitSegments Method for CatPitSegments

List segments for one or several PITs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatPitSegmentsRequest
*/
func (a *DefaultAPIService) CatPitSegments(ctx context.Context) DefaultAPICatPitSegmentsRequest {
	return DefaultAPICatPitSegmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CatPitSegmentsResponseContent
func (a *DefaultAPIService) CatPitSegmentsExecute(r DefaultAPICatPitSegmentsRequest) (*CatPitSegmentsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatPitSegmentsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatPitSegments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/pit_segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.catPitSegmentsBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICatPluginsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatPluginsRequest) Format(format string) DefaultAPICatPluginsRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatPluginsRequest) Local(local bool) DefaultAPICatPluginsRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatPluginsRequest) MasterTimeout(masterTimeout string) DefaultAPICatPluginsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatPluginsRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatPluginsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatPluginsRequest) H(h []string) DefaultAPICatPluginsRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatPluginsRequest) Help(help bool) DefaultAPICatPluginsRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatPluginsRequest) S(s []string) DefaultAPICatPluginsRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatPluginsRequest) V(v bool) DefaultAPICatPluginsRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatPluginsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatPluginsExecute(r)
}

/*
CatPlugins Method for CatPlugins

Returns information about installed plugins across nodes node.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatPluginsRequest
*/
func (a *DefaultAPIService) CatPlugins(ctx context.Context) DefaultAPICatPluginsRequest {
	return DefaultAPICatPluginsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatPluginsExecute(r DefaultAPICatPluginsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatPlugins")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/plugins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatRecoveryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	activeOnly *bool
	bytes *Bytes
	detailed *bool
	h *[]string
	help *bool
	index *[]string
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatRecoveryRequest) Format(format string) DefaultAPICatRecoveryRequest {
	r.format = &format
	return r
}

// If &#x60;true&#x60;, the response only includes ongoing shard recoveries.
func (r DefaultAPICatRecoveryRequest) ActiveOnly(activeOnly bool) DefaultAPICatRecoveryRequest {
	r.activeOnly = &activeOnly
	return r
}

// The unit in which to display byte values.
func (r DefaultAPICatRecoveryRequest) Bytes(bytes Bytes) DefaultAPICatRecoveryRequest {
	r.bytes = &bytes
	return r
}

// If &#x60;true&#x60;, the response includes detailed information about shard recoveries.
func (r DefaultAPICatRecoveryRequest) Detailed(detailed bool) DefaultAPICatRecoveryRequest {
	r.detailed = &detailed
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatRecoveryRequest) H(h []string) DefaultAPICatRecoveryRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatRecoveryRequest) Help(help bool) DefaultAPICatRecoveryRequest {
	r.help = &help
	return r
}

// Comma-separated list or wildcard expression of index names to limit the returned information.
func (r DefaultAPICatRecoveryRequest) Index(index []string) DefaultAPICatRecoveryRequest {
	r.index = &index
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatRecoveryRequest) S(s []string) DefaultAPICatRecoveryRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r DefaultAPICatRecoveryRequest) Time(time Time) DefaultAPICatRecoveryRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatRecoveryRequest) V(v bool) DefaultAPICatRecoveryRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatRecoveryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatRecoveryExecute(r)
}

/*
CatRecovery Method for CatRecovery

Returns information about index shard recoveries, both on-going completed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatRecoveryRequest
*/
func (a *DefaultAPIService) CatRecovery(ctx context.Context) DefaultAPICatRecoveryRequest {
	return DefaultAPICatRecoveryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatRecoveryExecute(r DefaultAPICatRecoveryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatRecovery")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/recovery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_only", r.activeOnly, "")
	} else {
		var defaultValue bool = false
		r.activeOnly = &defaultValue
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.index != nil {
		t := *r.index
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "index", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "index", t, "multi")
		}
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatRecoveryWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	format *string
	activeOnly *bool
	bytes *Bytes
	detailed *bool
	h *[]string
	help *bool
	index2 *[]string
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatRecoveryWithIndexRequest) Format(format string) DefaultAPICatRecoveryWithIndexRequest {
	r.format = &format
	return r
}

// If &#x60;true&#x60;, the response only includes ongoing shard recoveries.
func (r DefaultAPICatRecoveryWithIndexRequest) ActiveOnly(activeOnly bool) DefaultAPICatRecoveryWithIndexRequest {
	r.activeOnly = &activeOnly
	return r
}

// The unit in which to display byte values.
func (r DefaultAPICatRecoveryWithIndexRequest) Bytes(bytes Bytes) DefaultAPICatRecoveryWithIndexRequest {
	r.bytes = &bytes
	return r
}

// If &#x60;true&#x60;, the response includes detailed information about shard recoveries.
func (r DefaultAPICatRecoveryWithIndexRequest) Detailed(detailed bool) DefaultAPICatRecoveryWithIndexRequest {
	r.detailed = &detailed
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatRecoveryWithIndexRequest) H(h []string) DefaultAPICatRecoveryWithIndexRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatRecoveryWithIndexRequest) Help(help bool) DefaultAPICatRecoveryWithIndexRequest {
	r.help = &help
	return r
}

// Comma-separated list or wildcard expression of index names to limit the returned information.
func (r DefaultAPICatRecoveryWithIndexRequest) Index2(index2 []string) DefaultAPICatRecoveryWithIndexRequest {
	r.index2 = &index2
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatRecoveryWithIndexRequest) S(s []string) DefaultAPICatRecoveryWithIndexRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r DefaultAPICatRecoveryWithIndexRequest) Time(time Time) DefaultAPICatRecoveryWithIndexRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatRecoveryWithIndexRequest) V(v bool) DefaultAPICatRecoveryWithIndexRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatRecoveryWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatRecoveryWithIndexExecute(r)
}

/*
CatRecoveryWithIndex Method for CatRecoveryWithIndex

Returns information about index shard recoveries, both on-going completed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list or wildcard expression of index names to limit the returned information.
 @return DefaultAPICatRecoveryWithIndexRequest
*/
func (a *DefaultAPIService) CatRecoveryWithIndex(ctx context.Context, index string) DefaultAPICatRecoveryWithIndexRequest {
	return DefaultAPICatRecoveryWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatRecoveryWithIndexExecute(r DefaultAPICatRecoveryWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatRecoveryWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/recovery/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_only", r.activeOnly, "")
	} else {
		var defaultValue bool = false
		r.activeOnly = &defaultValue
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.index2 != nil {
		t := *r.index2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "index", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "index", t, "multi")
		}
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatRepositoriesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatRepositoriesRequest) Format(format string) DefaultAPICatRepositoriesRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatRepositoriesRequest) Local(local bool) DefaultAPICatRepositoriesRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatRepositoriesRequest) MasterTimeout(masterTimeout string) DefaultAPICatRepositoriesRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatRepositoriesRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatRepositoriesRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatRepositoriesRequest) H(h []string) DefaultAPICatRepositoriesRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatRepositoriesRequest) Help(help bool) DefaultAPICatRepositoriesRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatRepositoriesRequest) S(s []string) DefaultAPICatRepositoriesRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatRepositoriesRequest) V(v bool) DefaultAPICatRepositoriesRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatRepositoriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatRepositoriesExecute(r)
}

/*
CatRepositories Method for CatRepositories

Returns information about snapshot repositories registered in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatRepositoriesRequest
*/
func (a *DefaultAPIService) CatRepositories(ctx context.Context) DefaultAPICatRepositoriesRequest {
	return DefaultAPICatRepositoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatRepositoriesExecute(r DefaultAPICatRepositoriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatRepositories")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/repositories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatSegmentReplicationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	activeOnly *bool
	completedOnly *bool
	bytes *Bytes
	detailed *bool
	shards *[]string
	h *[]string
	help *bool
	index *[]string
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatSegmentReplicationRequest) Format(format string) DefaultAPICatSegmentReplicationRequest {
	r.format = &format
	return r
}

// If &#x60;true&#x60;, the response only includes ongoing segment replication events.
func (r DefaultAPICatSegmentReplicationRequest) ActiveOnly(activeOnly bool) DefaultAPICatSegmentReplicationRequest {
	r.activeOnly = &activeOnly
	return r
}

// If &#x60;true&#x60;, the response only includes latest completed segment replication events.
func (r DefaultAPICatSegmentReplicationRequest) CompletedOnly(completedOnly bool) DefaultAPICatSegmentReplicationRequest {
	r.completedOnly = &completedOnly
	return r
}

// The unit in which to display byte values.
func (r DefaultAPICatSegmentReplicationRequest) Bytes(bytes Bytes) DefaultAPICatSegmentReplicationRequest {
	r.bytes = &bytes
	return r
}

// If &#x60;true&#x60;, the response includes detailed information about segment replications.
func (r DefaultAPICatSegmentReplicationRequest) Detailed(detailed bool) DefaultAPICatSegmentReplicationRequest {
	r.detailed = &detailed
	return r
}

// Comma-separated list of shards to display.
func (r DefaultAPICatSegmentReplicationRequest) Shards(shards []string) DefaultAPICatSegmentReplicationRequest {
	r.shards = &shards
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatSegmentReplicationRequest) H(h []string) DefaultAPICatSegmentReplicationRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatSegmentReplicationRequest) Help(help bool) DefaultAPICatSegmentReplicationRequest {
	r.help = &help
	return r
}

// Comma-separated list or wildcard expression of index names to limit the returned information.
func (r DefaultAPICatSegmentReplicationRequest) Index(index []string) DefaultAPICatSegmentReplicationRequest {
	r.index = &index
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatSegmentReplicationRequest) S(s []string) DefaultAPICatSegmentReplicationRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r DefaultAPICatSegmentReplicationRequest) Time(time Time) DefaultAPICatSegmentReplicationRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatSegmentReplicationRequest) V(v bool) DefaultAPICatSegmentReplicationRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatSegmentReplicationRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatSegmentReplicationExecute(r)
}

/*
CatSegmentReplication Method for CatSegmentReplication

Returns information about both on-going and latest completed Segment Replication events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatSegmentReplicationRequest
*/
func (a *DefaultAPIService) CatSegmentReplication(ctx context.Context) DefaultAPICatSegmentReplicationRequest {
	return DefaultAPICatSegmentReplicationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatSegmentReplicationExecute(r DefaultAPICatSegmentReplicationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatSegmentReplication")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/segment_replication"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_only", r.activeOnly, "")
	} else {
		var defaultValue bool = false
		r.activeOnly = &defaultValue
	}
	if r.completedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completed_only", r.completedOnly, "")
	} else {
		var defaultValue bool = false
		r.completedOnly = &defaultValue
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.shards != nil {
		t := *r.shards
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shards", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shards", t, "multi")
		}
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.index != nil {
		t := *r.index
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "index", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "index", t, "multi")
		}
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatSegmentReplicationWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	format *string
	activeOnly *bool
	completedOnly *bool
	bytes *Bytes
	detailed *bool
	shards *[]string
	h *[]string
	help *bool
	index2 *[]string
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatSegmentReplicationWithIndexRequest) Format(format string) DefaultAPICatSegmentReplicationWithIndexRequest {
	r.format = &format
	return r
}

// If &#x60;true&#x60;, the response only includes ongoing segment replication events.
func (r DefaultAPICatSegmentReplicationWithIndexRequest) ActiveOnly(activeOnly bool) DefaultAPICatSegmentReplicationWithIndexRequest {
	r.activeOnly = &activeOnly
	return r
}

// If &#x60;true&#x60;, the response only includes latest completed segment replication events.
func (r DefaultAPICatSegmentReplicationWithIndexRequest) CompletedOnly(completedOnly bool) DefaultAPICatSegmentReplicationWithIndexRequest {
	r.completedOnly = &completedOnly
	return r
}

// The unit in which to display byte values.
func (r DefaultAPICatSegmentReplicationWithIndexRequest) Bytes(bytes Bytes) DefaultAPICatSegmentReplicationWithIndexRequest {
	r.bytes = &bytes
	return r
}

// If &#x60;true&#x60;, the response includes detailed information about segment replications.
func (r DefaultAPICatSegmentReplicationWithIndexRequest) Detailed(detailed bool) DefaultAPICatSegmentReplicationWithIndexRequest {
	r.detailed = &detailed
	return r
}

// Comma-separated list of shards to display.
func (r DefaultAPICatSegmentReplicationWithIndexRequest) Shards(shards []string) DefaultAPICatSegmentReplicationWithIndexRequest {
	r.shards = &shards
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatSegmentReplicationWithIndexRequest) H(h []string) DefaultAPICatSegmentReplicationWithIndexRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatSegmentReplicationWithIndexRequest) Help(help bool) DefaultAPICatSegmentReplicationWithIndexRequest {
	r.help = &help
	return r
}

// Comma-separated list or wildcard expression of index names to limit the returned information.
func (r DefaultAPICatSegmentReplicationWithIndexRequest) Index2(index2 []string) DefaultAPICatSegmentReplicationWithIndexRequest {
	r.index2 = &index2
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatSegmentReplicationWithIndexRequest) S(s []string) DefaultAPICatSegmentReplicationWithIndexRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r DefaultAPICatSegmentReplicationWithIndexRequest) Time(time Time) DefaultAPICatSegmentReplicationWithIndexRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatSegmentReplicationWithIndexRequest) V(v bool) DefaultAPICatSegmentReplicationWithIndexRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatSegmentReplicationWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatSegmentReplicationWithIndexExecute(r)
}

/*
CatSegmentReplicationWithIndex Method for CatSegmentReplicationWithIndex

Returns information about both on-going and latest completed Segment Replication events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list or wildcard expression of index names to limit the returned information.
 @return DefaultAPICatSegmentReplicationWithIndexRequest
*/
func (a *DefaultAPIService) CatSegmentReplicationWithIndex(ctx context.Context, index string) DefaultAPICatSegmentReplicationWithIndexRequest {
	return DefaultAPICatSegmentReplicationWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatSegmentReplicationWithIndexExecute(r DefaultAPICatSegmentReplicationWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatSegmentReplicationWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/segment_replication/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_only", r.activeOnly, "")
	} else {
		var defaultValue bool = false
		r.activeOnly = &defaultValue
	}
	if r.completedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completed_only", r.completedOnly, "")
	} else {
		var defaultValue bool = false
		r.completedOnly = &defaultValue
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.shards != nil {
		t := *r.shards
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shards", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shards", t, "multi")
		}
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.index2 != nil {
		t := *r.index2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "index", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "index", t, "multi")
		}
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatSegmentsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	bytes *Bytes
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatSegmentsRequest) Format(format string) DefaultAPICatSegmentsRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r DefaultAPICatSegmentsRequest) Bytes(bytes Bytes) DefaultAPICatSegmentsRequest {
	r.bytes = &bytes
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatSegmentsRequest) MasterTimeout(masterTimeout string) DefaultAPICatSegmentsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatSegmentsRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatSegmentsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatSegmentsRequest) H(h []string) DefaultAPICatSegmentsRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatSegmentsRequest) Help(help bool) DefaultAPICatSegmentsRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatSegmentsRequest) S(s []string) DefaultAPICatSegmentsRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatSegmentsRequest) V(v bool) DefaultAPICatSegmentsRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatSegmentsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatSegmentsExecute(r)
}

/*
CatSegments Method for CatSegments

Provides low-level information about the segments in the shards of an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatSegmentsRequest
*/
func (a *DefaultAPIService) CatSegments(ctx context.Context) DefaultAPICatSegmentsRequest {
	return DefaultAPICatSegmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatSegmentsExecute(r DefaultAPICatSegmentsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatSegments")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatSegmentsWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	format *string
	bytes *Bytes
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatSegmentsWithIndexRequest) Format(format string) DefaultAPICatSegmentsWithIndexRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r DefaultAPICatSegmentsWithIndexRequest) Bytes(bytes Bytes) DefaultAPICatSegmentsWithIndexRequest {
	r.bytes = &bytes
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatSegmentsWithIndexRequest) MasterTimeout(masterTimeout string) DefaultAPICatSegmentsWithIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatSegmentsWithIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatSegmentsWithIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatSegmentsWithIndexRequest) H(h []string) DefaultAPICatSegmentsWithIndexRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatSegmentsWithIndexRequest) Help(help bool) DefaultAPICatSegmentsWithIndexRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatSegmentsWithIndexRequest) S(s []string) DefaultAPICatSegmentsWithIndexRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatSegmentsWithIndexRequest) V(v bool) DefaultAPICatSegmentsWithIndexRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatSegmentsWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatSegmentsWithIndexExecute(r)
}

/*
CatSegmentsWithIndex Method for CatSegmentsWithIndex

Provides low-level information about the segments in the shards of an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to limit the returned information.
 @return DefaultAPICatSegmentsWithIndexRequest
*/
func (a *DefaultAPIService) CatSegmentsWithIndex(ctx context.Context, index string) DefaultAPICatSegmentsWithIndexRequest {
	return DefaultAPICatSegmentsWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatSegmentsWithIndexExecute(r DefaultAPICatSegmentsWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatSegmentsWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/segments/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatShardsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	bytes *Bytes
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatShardsRequest) Format(format string) DefaultAPICatShardsRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r DefaultAPICatShardsRequest) Bytes(bytes Bytes) DefaultAPICatShardsRequest {
	r.bytes = &bytes
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatShardsRequest) Local(local bool) DefaultAPICatShardsRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatShardsRequest) MasterTimeout(masterTimeout string) DefaultAPICatShardsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatShardsRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatShardsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatShardsRequest) H(h []string) DefaultAPICatShardsRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatShardsRequest) Help(help bool) DefaultAPICatShardsRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatShardsRequest) S(s []string) DefaultAPICatShardsRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r DefaultAPICatShardsRequest) Time(time Time) DefaultAPICatShardsRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatShardsRequest) V(v bool) DefaultAPICatShardsRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatShardsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatShardsExecute(r)
}

/*
CatShards Method for CatShards

Provides a detailed view of shard allocation on nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatShardsRequest
*/
func (a *DefaultAPIService) CatShards(ctx context.Context) DefaultAPICatShardsRequest {
	return DefaultAPICatShardsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatShardsExecute(r DefaultAPICatShardsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatShards")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/shards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatShardsWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	format *string
	bytes *Bytes
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatShardsWithIndexRequest) Format(format string) DefaultAPICatShardsWithIndexRequest {
	r.format = &format
	return r
}

// The unit in which to display byte values.
func (r DefaultAPICatShardsWithIndexRequest) Bytes(bytes Bytes) DefaultAPICatShardsWithIndexRequest {
	r.bytes = &bytes
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatShardsWithIndexRequest) Local(local bool) DefaultAPICatShardsWithIndexRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatShardsWithIndexRequest) MasterTimeout(masterTimeout string) DefaultAPICatShardsWithIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatShardsWithIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatShardsWithIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatShardsWithIndexRequest) H(h []string) DefaultAPICatShardsWithIndexRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatShardsWithIndexRequest) Help(help bool) DefaultAPICatShardsWithIndexRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatShardsWithIndexRequest) S(s []string) DefaultAPICatShardsWithIndexRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r DefaultAPICatShardsWithIndexRequest) Time(time Time) DefaultAPICatShardsWithIndexRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatShardsWithIndexRequest) V(v bool) DefaultAPICatShardsWithIndexRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatShardsWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatShardsWithIndexExecute(r)
}

/*
CatShardsWithIndex Method for CatShardsWithIndex

Provides a detailed view of shard allocation on nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to limit the returned information.
 @return DefaultAPICatShardsWithIndexRequest
*/
func (a *DefaultAPIService) CatShardsWithIndex(ctx context.Context, index string) DefaultAPICatShardsWithIndexRequest {
	return DefaultAPICatShardsWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatShardsWithIndexExecute(r DefaultAPICatShardsWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatShardsWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/shards/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatSnapshotsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	ignoreUnavailable *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatSnapshotsRequest) Format(format string) DefaultAPICatSnapshotsRequest {
	r.format = &format
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPICatSnapshotsRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPICatSnapshotsRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatSnapshotsRequest) MasterTimeout(masterTimeout string) DefaultAPICatSnapshotsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatSnapshotsRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatSnapshotsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatSnapshotsRequest) H(h []string) DefaultAPICatSnapshotsRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatSnapshotsRequest) Help(help bool) DefaultAPICatSnapshotsRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatSnapshotsRequest) S(s []string) DefaultAPICatSnapshotsRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r DefaultAPICatSnapshotsRequest) Time(time Time) DefaultAPICatSnapshotsRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatSnapshotsRequest) V(v bool) DefaultAPICatSnapshotsRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatSnapshotsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatSnapshotsExecute(r)
}

/*
CatSnapshots Method for CatSnapshots

Returns all snapshots in a specific repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatSnapshotsRequest
*/
func (a *DefaultAPIService) CatSnapshots(ctx context.Context) DefaultAPICatSnapshotsRequest {
	return DefaultAPICatSnapshotsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatSnapshotsExecute(r DefaultAPICatSnapshotsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatSnapshots")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/snapshots"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatSnapshotsWithRepositoryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	format *string
	ignoreUnavailable *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatSnapshotsWithRepositoryRequest) Format(format string) DefaultAPICatSnapshotsWithRepositoryRequest {
	r.format = &format
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPICatSnapshotsWithRepositoryRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPICatSnapshotsWithRepositoryRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatSnapshotsWithRepositoryRequest) MasterTimeout(masterTimeout string) DefaultAPICatSnapshotsWithRepositoryRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatSnapshotsWithRepositoryRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatSnapshotsWithRepositoryRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatSnapshotsWithRepositoryRequest) H(h []string) DefaultAPICatSnapshotsWithRepositoryRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatSnapshotsWithRepositoryRequest) Help(help bool) DefaultAPICatSnapshotsWithRepositoryRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatSnapshotsWithRepositoryRequest) S(s []string) DefaultAPICatSnapshotsWithRepositoryRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r DefaultAPICatSnapshotsWithRepositoryRequest) Time(time Time) DefaultAPICatSnapshotsWithRepositoryRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatSnapshotsWithRepositoryRequest) V(v bool) DefaultAPICatSnapshotsWithRepositoryRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatSnapshotsWithRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatSnapshotsWithRepositoryExecute(r)
}

/*
CatSnapshotsWithRepository Method for CatSnapshotsWithRepository

Returns all snapshots in a specific repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Comma-separated list of repository names.
 @return DefaultAPICatSnapshotsWithRepositoryRequest
*/
func (a *DefaultAPIService) CatSnapshotsWithRepository(ctx context.Context, repository string) DefaultAPICatSnapshotsWithRepositoryRequest {
	return DefaultAPICatSnapshotsWithRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatSnapshotsWithRepositoryExecute(r DefaultAPICatSnapshotsWithRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatSnapshotsWithRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/snapshots/{repository}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatTasksRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	nodes *[]string
	actions *[]string
	detailed *bool
	parentTaskId *string
	h *[]string
	help *bool
	s *[]string
	time *Time
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatTasksRequest) Format(format string) DefaultAPICatTasksRequest {
	r.format = &format
	return r
}

// Comma-separated list of node IDs or names to limit the returned information; use &#x60;_local&#x60; to return information from the node you&#39;re connecting to, leave empty to get information from all nodes.
func (r DefaultAPICatTasksRequest) Nodes(nodes []string) DefaultAPICatTasksRequest {
	r.nodes = &nodes
	return r
}

// Comma-separated list of actions that should be returned. Leave empty to return all.
func (r DefaultAPICatTasksRequest) Actions(actions []string) DefaultAPICatTasksRequest {
	r.actions = &actions
	return r
}

// Return detailed task information.
func (r DefaultAPICatTasksRequest) Detailed(detailed bool) DefaultAPICatTasksRequest {
	r.detailed = &detailed
	return r
}

// Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
func (r DefaultAPICatTasksRequest) ParentTaskId(parentTaskId string) DefaultAPICatTasksRequest {
	r.parentTaskId = &parentTaskId
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatTasksRequest) H(h []string) DefaultAPICatTasksRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatTasksRequest) Help(help bool) DefaultAPICatTasksRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatTasksRequest) S(s []string) DefaultAPICatTasksRequest {
	r.s = &s
	return r
}

// The unit in which to display time values.
func (r DefaultAPICatTasksRequest) Time(time Time) DefaultAPICatTasksRequest {
	r.time = &time
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatTasksRequest) V(v bool) DefaultAPICatTasksRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatTasksRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatTasksExecute(r)
}

/*
CatTasks Method for CatTasks

Returns information about the tasks currently executing on one or more nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatTasksRequest
*/
func (a *DefaultAPIService) CatTasks(ctx context.Context) DefaultAPICatTasksRequest {
	return DefaultAPICatTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatTasksExecute(r DefaultAPICatTasksRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatTasks")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.nodes != nil {
		t := *r.nodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", t, "multi")
		}
	}
	if r.actions != nil {
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "multi")
		}
	}
	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.parentTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_task_id", r.parentTaskId, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "")
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatTemplatesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatTemplatesRequest) Format(format string) DefaultAPICatTemplatesRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatTemplatesRequest) Local(local bool) DefaultAPICatTemplatesRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatTemplatesRequest) MasterTimeout(masterTimeout string) DefaultAPICatTemplatesRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatTemplatesRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatTemplatesRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatTemplatesRequest) H(h []string) DefaultAPICatTemplatesRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatTemplatesRequest) Help(help bool) DefaultAPICatTemplatesRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatTemplatesRequest) S(s []string) DefaultAPICatTemplatesRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatTemplatesRequest) V(v bool) DefaultAPICatTemplatesRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatTemplatesRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatTemplatesExecute(r)
}

/*
CatTemplates Method for CatTemplates

Returns information about existing templates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatTemplatesRequest
*/
func (a *DefaultAPIService) CatTemplates(ctx context.Context) DefaultAPICatTemplatesRequest {
	return DefaultAPICatTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatTemplatesExecute(r DefaultAPICatTemplatesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatTemplates")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatTemplatesWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	format *string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatTemplatesWithNameRequest) Format(format string) DefaultAPICatTemplatesWithNameRequest {
	r.format = &format
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatTemplatesWithNameRequest) Local(local bool) DefaultAPICatTemplatesWithNameRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatTemplatesWithNameRequest) MasterTimeout(masterTimeout string) DefaultAPICatTemplatesWithNameRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatTemplatesWithNameRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatTemplatesWithNameRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatTemplatesWithNameRequest) H(h []string) DefaultAPICatTemplatesWithNameRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatTemplatesWithNameRequest) Help(help bool) DefaultAPICatTemplatesWithNameRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatTemplatesWithNameRequest) S(s []string) DefaultAPICatTemplatesWithNameRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatTemplatesWithNameRequest) V(v bool) DefaultAPICatTemplatesWithNameRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatTemplatesWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatTemplatesWithNameExecute(r)
}

/*
CatTemplatesWithName Method for CatTemplatesWithName

Returns information about existing templates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return DefaultAPICatTemplatesWithNameRequest
*/
func (a *DefaultAPIService) CatTemplatesWithName(ctx context.Context, name string) DefaultAPICatTemplatesWithNameRequest {
	return DefaultAPICatTemplatesWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatTemplatesWithNameExecute(r DefaultAPICatTemplatesWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatTemplatesWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/templates/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatThreadPoolRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	format *string
	size *int32
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatThreadPoolRequest) Format(format string) DefaultAPICatThreadPoolRequest {
	r.format = &format
	return r
}

// The multiplier in which to display values.
func (r DefaultAPICatThreadPoolRequest) Size(size int32) DefaultAPICatThreadPoolRequest {
	r.size = &size
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatThreadPoolRequest) Local(local bool) DefaultAPICatThreadPoolRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatThreadPoolRequest) MasterTimeout(masterTimeout string) DefaultAPICatThreadPoolRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatThreadPoolRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatThreadPoolRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatThreadPoolRequest) H(h []string) DefaultAPICatThreadPoolRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatThreadPoolRequest) Help(help bool) DefaultAPICatThreadPoolRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatThreadPoolRequest) S(s []string) DefaultAPICatThreadPoolRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatThreadPoolRequest) V(v bool) DefaultAPICatThreadPoolRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatThreadPoolRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatThreadPoolExecute(r)
}

/*
CatThreadPool Method for CatThreadPool

Returns cluster-wide thread pool statistics per node.
By default the active, queue and rejected statistics are returned for all thread pools.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICatThreadPoolRequest
*/
func (a *DefaultAPIService) CatThreadPool(ctx context.Context) DefaultAPICatThreadPoolRequest {
	return DefaultAPICatThreadPoolRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatThreadPoolExecute(r DefaultAPICatThreadPoolRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatThreadPool")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/thread_pool"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICatThreadPoolWithThreadPoolPatternsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	threadPoolPatterns string
	format *string
	size *int32
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	h *[]string
	help *bool
	s *[]string
	v *bool
}

// A short version of the Accept header, e.g. json, yaml.
func (r DefaultAPICatThreadPoolWithThreadPoolPatternsRequest) Format(format string) DefaultAPICatThreadPoolWithThreadPoolPatternsRequest {
	r.format = &format
	return r
}

// The multiplier in which to display values.
func (r DefaultAPICatThreadPoolWithThreadPoolPatternsRequest) Size(size int32) DefaultAPICatThreadPoolWithThreadPoolPatternsRequest {
	r.size = &size
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPICatThreadPoolWithThreadPoolPatternsRequest) Local(local bool) DefaultAPICatThreadPoolWithThreadPoolPatternsRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPICatThreadPoolWithThreadPoolPatternsRequest) MasterTimeout(masterTimeout string) DefaultAPICatThreadPoolWithThreadPoolPatternsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPICatThreadPoolWithThreadPoolPatternsRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPICatThreadPoolWithThreadPoolPatternsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Comma-separated list of column names to display.
func (r DefaultAPICatThreadPoolWithThreadPoolPatternsRequest) H(h []string) DefaultAPICatThreadPoolWithThreadPoolPatternsRequest {
	r.h = &h
	return r
}

// Return help information.
func (r DefaultAPICatThreadPoolWithThreadPoolPatternsRequest) Help(help bool) DefaultAPICatThreadPoolWithThreadPoolPatternsRequest {
	r.help = &help
	return r
}

// Comma-separated list of column names or column aliases to sort by.
func (r DefaultAPICatThreadPoolWithThreadPoolPatternsRequest) S(s []string) DefaultAPICatThreadPoolWithThreadPoolPatternsRequest {
	r.s = &s
	return r
}

// Verbose mode. Display column headers.
func (r DefaultAPICatThreadPoolWithThreadPoolPatternsRequest) V(v bool) DefaultAPICatThreadPoolWithThreadPoolPatternsRequest {
	r.v = &v
	return r
}

func (r DefaultAPICatThreadPoolWithThreadPoolPatternsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatThreadPoolWithThreadPoolPatternsExecute(r)
}

/*
CatThreadPoolWithThreadPoolPatterns Method for CatThreadPoolWithThreadPoolPatterns

Returns cluster-wide thread pool statistics per node.
By default the active, queue and rejected statistics are returned for all thread pools.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param threadPoolPatterns Comma-separated list of regular-expressions to filter the thread pools in the output.
 @return DefaultAPICatThreadPoolWithThreadPoolPatternsRequest
*/
func (a *DefaultAPIService) CatThreadPoolWithThreadPoolPatterns(ctx context.Context, threadPoolPatterns string) DefaultAPICatThreadPoolWithThreadPoolPatternsRequest {
	return DefaultAPICatThreadPoolWithThreadPoolPatternsRequest{
		ApiService: a,
		ctx: ctx,
		threadPoolPatterns: threadPoolPatterns,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CatThreadPoolWithThreadPoolPatternsExecute(r DefaultAPICatThreadPoolWithThreadPoolPatternsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CatThreadPoolWithThreadPoolPatterns")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cat/thread_pool/{thread_pool_patterns}"
	localVarPath = strings.Replace(localVarPath, "{"+"thread_pool_patterns"+"}", url.PathEscape(parameterValueToString(r.threadPoolPatterns, "threadPoolPatterns")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.h != nil {
		t := *r.h
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "h", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "h", t, "multi")
		}
	}
	if r.help != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "help", r.help, "")
	} else {
		var defaultValue bool = false
		r.help = &defaultValue
	}
	if r.s != nil {
		t := *r.s
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "s", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "s", t, "multi")
		}
	}
	if r.v != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v", r.v, "")
	} else {
		var defaultValue bool = false
		r.v = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIChangePasswordRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	changePasswordRequestContent *ChangePasswordRequestContent
}

func (r DefaultAPIChangePasswordRequest) ChangePasswordRequestContent(changePasswordRequestContent ChangePasswordRequestContent) DefaultAPIChangePasswordRequest {
	r.changePasswordRequestContent = &changePasswordRequestContent
	return r
}

func (r DefaultAPIChangePasswordRequest) Execute() (*ChangePasswordResponseContent, *http.Response, error) {
	return r.ApiService.ChangePasswordExecute(r)
}

/*
ChangePassword Method for ChangePassword

Changes the password for the current user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIChangePasswordRequest
*/
func (a *DefaultAPIService) ChangePassword(ctx context.Context) DefaultAPIChangePasswordRequest {
	return DefaultAPIChangePasswordRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangePasswordResponseContent
func (a *DefaultAPIService) ChangePasswordExecute(r DefaultAPIChangePasswordRequest) (*ChangePasswordResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangePasswordResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ChangePassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.changePasswordRequestContent == nil {
		return localVarReturnValue, nil, reportError("changePasswordRequestContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.changePasswordRequestContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIClearScrollRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
}

func (r DefaultAPIClearScrollRequest) Body(body map[string]interface{}) DefaultAPIClearScrollRequest {
	r.body = &body
	return r
}

func (r DefaultAPIClearScrollRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClearScrollExecute(r)
}

/*
ClearScroll Method for ClearScroll

Explicitly clears the search context for a scroll.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClearScrollRequest
*/
func (a *DefaultAPIService) ClearScroll(ctx context.Context) DefaultAPIClearScrollRequest {
	return DefaultAPIClearScrollRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClearScrollExecute(r DefaultAPIClearScrollRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClearScroll")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/scroll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClearScrollWithScrollIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	scrollId string
	body *map[string]interface{}
}

func (r DefaultAPIClearScrollWithScrollIdRequest) Body(body map[string]interface{}) DefaultAPIClearScrollWithScrollIdRequest {
	r.body = &body
	return r
}

func (r DefaultAPIClearScrollWithScrollIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClearScrollWithScrollIdExecute(r)
}

/*
ClearScrollWithScrollId Method for ClearScrollWithScrollId

Explicitly clears the search context for a scroll.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param scrollId Comma-separated list of scroll IDs to clear.
 @return DefaultAPIClearScrollWithScrollIdRequest

Deprecated
*/
func (a *DefaultAPIService) ClearScrollWithScrollId(ctx context.Context, scrollId string) DefaultAPIClearScrollWithScrollIdRequest {
	return DefaultAPIClearScrollWithScrollIdRequest{
		ApiService: a,
		ctx: ctx,
		scrollId: scrollId,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) ClearScrollWithScrollIdExecute(r DefaultAPIClearScrollWithScrollIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClearScrollWithScrollId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/scroll/{scroll_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"scroll_id"+"}", url.PathEscape(parameterValueToString(r.scrollId, "scrollId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterAllocationExplainGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	includeYesDecisions *bool
	includeDiskInfo *bool
}

// Return &#39;YES&#39; decisions in explanation.
func (r DefaultAPIClusterAllocationExplainGetRequest) IncludeYesDecisions(includeYesDecisions bool) DefaultAPIClusterAllocationExplainGetRequest {
	r.includeYesDecisions = &includeYesDecisions
	return r
}

// Return information about disk usage and shard sizes.
func (r DefaultAPIClusterAllocationExplainGetRequest) IncludeDiskInfo(includeDiskInfo bool) DefaultAPIClusterAllocationExplainGetRequest {
	r.includeDiskInfo = &includeDiskInfo
	return r
}

func (r DefaultAPIClusterAllocationExplainGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterAllocationExplainGetExecute(r)
}

/*
ClusterAllocationExplainGet Method for ClusterAllocationExplainGet

Provides explanations for shard allocations in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterAllocationExplainGetRequest
*/
func (a *DefaultAPIService) ClusterAllocationExplainGet(ctx context.Context) DefaultAPIClusterAllocationExplainGetRequest {
	return DefaultAPIClusterAllocationExplainGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterAllocationExplainGetExecute(r DefaultAPIClusterAllocationExplainGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterAllocationExplainGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/allocation/explain"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeYesDecisions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_yes_decisions", r.includeYesDecisions, "")
	} else {
		var defaultValue bool = false
		r.includeYesDecisions = &defaultValue
	}
	if r.includeDiskInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_disk_info", r.includeDiskInfo, "")
	} else {
		var defaultValue bool = false
		r.includeDiskInfo = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterAllocationExplainPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	includeYesDecisions *bool
	includeDiskInfo *bool
	body *map[string]interface{}
}

// Return &#39;YES&#39; decisions in explanation.
func (r DefaultAPIClusterAllocationExplainPostRequest) IncludeYesDecisions(includeYesDecisions bool) DefaultAPIClusterAllocationExplainPostRequest {
	r.includeYesDecisions = &includeYesDecisions
	return r
}

// Return information about disk usage and shard sizes.
func (r DefaultAPIClusterAllocationExplainPostRequest) IncludeDiskInfo(includeDiskInfo bool) DefaultAPIClusterAllocationExplainPostRequest {
	r.includeDiskInfo = &includeDiskInfo
	return r
}

func (r DefaultAPIClusterAllocationExplainPostRequest) Body(body map[string]interface{}) DefaultAPIClusterAllocationExplainPostRequest {
	r.body = &body
	return r
}

func (r DefaultAPIClusterAllocationExplainPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterAllocationExplainPostExecute(r)
}

/*
ClusterAllocationExplainPost Method for ClusterAllocationExplainPost

Provides explanations for shard allocations in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterAllocationExplainPostRequest
*/
func (a *DefaultAPIService) ClusterAllocationExplainPost(ctx context.Context) DefaultAPIClusterAllocationExplainPostRequest {
	return DefaultAPIClusterAllocationExplainPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterAllocationExplainPostExecute(r DefaultAPIClusterAllocationExplainPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterAllocationExplainPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/allocation/explain"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeYesDecisions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_yes_decisions", r.includeYesDecisions, "")
	} else {
		var defaultValue bool = false
		r.includeYesDecisions = &defaultValue
	}
	if r.includeDiskInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_disk_info", r.includeDiskInfo, "")
	} else {
		var defaultValue bool = false
		r.includeDiskInfo = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterDeleteComponentTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout.
func (r DefaultAPIClusterDeleteComponentTemplateRequest) Timeout(timeout string) DefaultAPIClusterDeleteComponentTemplateRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterDeleteComponentTemplateRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterDeleteComponentTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIClusterDeleteComponentTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIClusterDeleteComponentTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIClusterDeleteComponentTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterDeleteComponentTemplateExecute(r)
}

/*
ClusterDeleteComponentTemplate Method for ClusterDeleteComponentTemplate

Deletes a component template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return DefaultAPIClusterDeleteComponentTemplateRequest
*/
func (a *DefaultAPIService) ClusterDeleteComponentTemplate(ctx context.Context, name string) DefaultAPIClusterDeleteComponentTemplateRequest {
	return DefaultAPIClusterDeleteComponentTemplateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterDeleteComponentTemplateExecute(r DefaultAPIClusterDeleteComponentTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterDeleteComponentTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_component_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterDeleteDecommissionAwarenessRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIClusterDeleteDecommissionAwarenessRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterDeleteDecommissionAwarenessExecute(r)
}

/*
ClusterDeleteDecommissionAwareness Method for ClusterDeleteDecommissionAwareness

Delete any existing decommission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterDeleteDecommissionAwarenessRequest
*/
func (a *DefaultAPIService) ClusterDeleteDecommissionAwareness(ctx context.Context) DefaultAPIClusterDeleteDecommissionAwarenessRequest {
	return DefaultAPIClusterDeleteDecommissionAwarenessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterDeleteDecommissionAwarenessExecute(r DefaultAPIClusterDeleteDecommissionAwarenessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterDeleteDecommissionAwareness")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/decommission/awareness/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterDeleteVotingConfigExclusionsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	waitForRemoval *bool
}

// Specifies whether to wait for all excluded nodes to be removed from the cluster before clearing the voting configuration exclusions list.
func (r DefaultAPIClusterDeleteVotingConfigExclusionsRequest) WaitForRemoval(waitForRemoval bool) DefaultAPIClusterDeleteVotingConfigExclusionsRequest {
	r.waitForRemoval = &waitForRemoval
	return r
}

func (r DefaultAPIClusterDeleteVotingConfigExclusionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterDeleteVotingConfigExclusionsExecute(r)
}

/*
ClusterDeleteVotingConfigExclusions Method for ClusterDeleteVotingConfigExclusions

Clears cluster voting config exclusions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterDeleteVotingConfigExclusionsRequest
*/
func (a *DefaultAPIService) ClusterDeleteVotingConfigExclusions(ctx context.Context) DefaultAPIClusterDeleteVotingConfigExclusionsRequest {
	return DefaultAPIClusterDeleteVotingConfigExclusionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterDeleteVotingConfigExclusionsExecute(r DefaultAPIClusterDeleteVotingConfigExclusionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterDeleteVotingConfigExclusions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/voting_config_exclusions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.waitForRemoval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_removal", r.waitForRemoval, "")
	} else {
		var defaultValue bool = true
		r.waitForRemoval = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterDeleteWeightedRoutingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIClusterDeleteWeightedRoutingRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterDeleteWeightedRoutingExecute(r)
}

/*
ClusterDeleteWeightedRouting Method for ClusterDeleteWeightedRouting

Delete weighted shard routing weights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterDeleteWeightedRoutingRequest
*/
func (a *DefaultAPIService) ClusterDeleteWeightedRouting(ctx context.Context) DefaultAPIClusterDeleteWeightedRoutingRequest {
	return DefaultAPIClusterDeleteWeightedRoutingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterDeleteWeightedRoutingExecute(r DefaultAPIClusterDeleteWeightedRoutingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterDeleteWeightedRouting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/routing/awareness/weights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterExistsComponentTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	masterTimeout *string
	local *bool
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterExistsComponentTemplateRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterExistsComponentTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIClusterExistsComponentTemplateRequest) Local(local bool) DefaultAPIClusterExistsComponentTemplateRequest {
	r.local = &local
	return r
}

func (r DefaultAPIClusterExistsComponentTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterExistsComponentTemplateExecute(r)
}

/*
ClusterExistsComponentTemplate Method for ClusterExistsComponentTemplate

Returns information about whether a particular component template exist.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return DefaultAPIClusterExistsComponentTemplateRequest
*/
func (a *DefaultAPIService) ClusterExistsComponentTemplate(ctx context.Context, name string) DefaultAPIClusterExistsComponentTemplateRequest {
	return DefaultAPIClusterExistsComponentTemplateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterExistsComponentTemplateExecute(r DefaultAPIClusterExistsComponentTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterExistsComponentTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_component_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterGetComponentTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterGetComponentTemplateRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterGetComponentTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIClusterGetComponentTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIClusterGetComponentTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIClusterGetComponentTemplateRequest) Local(local bool) DefaultAPIClusterGetComponentTemplateRequest {
	r.local = &local
	return r
}

func (r DefaultAPIClusterGetComponentTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterGetComponentTemplateExecute(r)
}

/*
ClusterGetComponentTemplate Method for ClusterGetComponentTemplate

Returns one or more component templates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterGetComponentTemplateRequest
*/
func (a *DefaultAPIService) ClusterGetComponentTemplate(ctx context.Context) DefaultAPIClusterGetComponentTemplateRequest {
	return DefaultAPIClusterGetComponentTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterGetComponentTemplateExecute(r DefaultAPIClusterGetComponentTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterGetComponentTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_component_template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterGetComponentTemplateWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterGetComponentTemplateWithNameRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterGetComponentTemplateWithNameRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIClusterGetComponentTemplateWithNameRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIClusterGetComponentTemplateWithNameRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIClusterGetComponentTemplateWithNameRequest) Local(local bool) DefaultAPIClusterGetComponentTemplateWithNameRequest {
	r.local = &local
	return r
}

func (r DefaultAPIClusterGetComponentTemplateWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterGetComponentTemplateWithNameExecute(r)
}

/*
ClusterGetComponentTemplateWithName Method for ClusterGetComponentTemplateWithName

Returns one or more component templates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The Comma-separated names of the component templates.
 @return DefaultAPIClusterGetComponentTemplateWithNameRequest
*/
func (a *DefaultAPIService) ClusterGetComponentTemplateWithName(ctx context.Context, name string) DefaultAPIClusterGetComponentTemplateWithNameRequest {
	return DefaultAPIClusterGetComponentTemplateWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterGetComponentTemplateWithNameExecute(r DefaultAPIClusterGetComponentTemplateWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterGetComponentTemplateWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_component_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterGetDecommissionAwarenessRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	awarenessAttributeName string
}

func (r DefaultAPIClusterGetDecommissionAwarenessRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterGetDecommissionAwarenessExecute(r)
}

/*
ClusterGetDecommissionAwareness Method for ClusterGetDecommissionAwareness

Get details and status of decommissioned attribute.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awarenessAttributeName Awareness attribute name.
 @return DefaultAPIClusterGetDecommissionAwarenessRequest
*/
func (a *DefaultAPIService) ClusterGetDecommissionAwareness(ctx context.Context, awarenessAttributeName string) DefaultAPIClusterGetDecommissionAwarenessRequest {
	return DefaultAPIClusterGetDecommissionAwarenessRequest{
		ApiService: a,
		ctx: ctx,
		awarenessAttributeName: awarenessAttributeName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterGetDecommissionAwarenessExecute(r DefaultAPIClusterGetDecommissionAwarenessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterGetDecommissionAwareness")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/decommission/awareness/{awareness_attribute_name}/_status"
	localVarPath = strings.Replace(localVarPath, "{"+"awareness_attribute_name"+"}", url.PathEscape(parameterValueToString(r.awarenessAttributeName, "awarenessAttributeName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterGetSettingsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	flatSettings *bool
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	includeDefaults *bool
}

// Return settings in flat format.
func (r DefaultAPIClusterGetSettingsRequest) FlatSettings(flatSettings bool) DefaultAPIClusterGetSettingsRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterGetSettingsRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterGetSettingsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIClusterGetSettingsRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIClusterGetSettingsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r DefaultAPIClusterGetSettingsRequest) Timeout(timeout string) DefaultAPIClusterGetSettingsRequest {
	r.timeout = &timeout
	return r
}

// Whether to return all default clusters setting.
func (r DefaultAPIClusterGetSettingsRequest) IncludeDefaults(includeDefaults bool) DefaultAPIClusterGetSettingsRequest {
	r.includeDefaults = &includeDefaults
	return r
}

func (r DefaultAPIClusterGetSettingsRequest) Execute() (*ClusterGetSettingsResponseContent, *http.Response, error) {
	return r.ApiService.ClusterGetSettingsExecute(r)
}

/*
ClusterGetSettings Method for ClusterGetSettings

Returns cluster settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterGetSettingsRequest
*/
func (a *DefaultAPIService) ClusterGetSettings(ctx context.Context) DefaultAPIClusterGetSettingsRequest {
	return DefaultAPIClusterGetSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClusterGetSettingsResponseContent
func (a *DefaultAPIService) ClusterGetSettingsExecute(r DefaultAPIClusterGetSettingsRequest) (*ClusterGetSettingsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterGetSettingsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterGetSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	} else {
		var defaultValue bool = false
		r.includeDefaults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIClusterGetWeightedRoutingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	attribute string
}

func (r DefaultAPIClusterGetWeightedRoutingRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterGetWeightedRoutingExecute(r)
}

/*
ClusterGetWeightedRouting Method for ClusterGetWeightedRouting

Fetches weighted shard routing weights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attribute Awareness attribute name.
 @return DefaultAPIClusterGetWeightedRoutingRequest
*/
func (a *DefaultAPIService) ClusterGetWeightedRouting(ctx context.Context, attribute string) DefaultAPIClusterGetWeightedRoutingRequest {
	return DefaultAPIClusterGetWeightedRoutingRequest{
		ApiService: a,
		ctx: ctx,
		attribute: attribute,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterGetWeightedRoutingExecute(r DefaultAPIClusterGetWeightedRoutingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterGetWeightedRouting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/routing/awareness/{attribute}/weights"
	localVarPath = strings.Replace(localVarPath, "{"+"attribute"+"}", url.PathEscape(parameterValueToString(r.attribute, "attribute")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterHealthRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	expandWildcards *ExpandWildcards
	level *ClusterHealthLevel
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	waitForActiveShards *string
	waitForNodes *string
	waitForEvents *WaitForEvents
	waitForNoRelocatingShards *bool
	waitForNoInitializingShards *bool
	waitForStatus *WaitForStatus
	awarenessAttribute *string
	ensureNodeCommissioned *bool
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIClusterHealthRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIClusterHealthRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify the level of detail for returned information.
func (r DefaultAPIClusterHealthRequest) Level(level ClusterHealthLevel) DefaultAPIClusterHealthRequest {
	r.level = &level
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIClusterHealthRequest) Local(local bool) DefaultAPIClusterHealthRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterHealthRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterHealthRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIClusterHealthRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIClusterHealthRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r DefaultAPIClusterHealthRequest) Timeout(timeout string) DefaultAPIClusterHealthRequest {
	r.timeout = &timeout
	return r
}

// Wait until the specified number of shards is active.
func (r DefaultAPIClusterHealthRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIClusterHealthRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Wait until the specified number of nodes is available.
func (r DefaultAPIClusterHealthRequest) WaitForNodes(waitForNodes string) DefaultAPIClusterHealthRequest {
	r.waitForNodes = &waitForNodes
	return r
}

// Wait until all currently queued events with the given priority are processed.
func (r DefaultAPIClusterHealthRequest) WaitForEvents(waitForEvents WaitForEvents) DefaultAPIClusterHealthRequest {
	r.waitForEvents = &waitForEvents
	return r
}

// Whether to wait until there are no relocating shards in the cluster.
func (r DefaultAPIClusterHealthRequest) WaitForNoRelocatingShards(waitForNoRelocatingShards bool) DefaultAPIClusterHealthRequest {
	r.waitForNoRelocatingShards = &waitForNoRelocatingShards
	return r
}

// Whether to wait until there are no initializing shards in the cluster.
func (r DefaultAPIClusterHealthRequest) WaitForNoInitializingShards(waitForNoInitializingShards bool) DefaultAPIClusterHealthRequest {
	r.waitForNoInitializingShards = &waitForNoInitializingShards
	return r
}

// Wait until cluster is in a specific state.
func (r DefaultAPIClusterHealthRequest) WaitForStatus(waitForStatus WaitForStatus) DefaultAPIClusterHealthRequest {
	r.waitForStatus = &waitForStatus
	return r
}

// The awareness attribute for which the health is required.
func (r DefaultAPIClusterHealthRequest) AwarenessAttribute(awarenessAttribute string) DefaultAPIClusterHealthRequest {
	r.awarenessAttribute = &awarenessAttribute
	return r
}

// Checks whether local node is commissioned or not. If set to true on a local call it will throw exception if node is decommissioned.
func (r DefaultAPIClusterHealthRequest) EnsureNodeCommissioned(ensureNodeCommissioned bool) DefaultAPIClusterHealthRequest {
	r.ensureNodeCommissioned = &ensureNodeCommissioned
	return r
}

func (r DefaultAPIClusterHealthRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterHealthExecute(r)
}

/*
ClusterHealth Method for ClusterHealth

Returns basic information about the health of the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterHealthRequest
*/
func (a *DefaultAPIService) ClusterHealth(ctx context.Context) DefaultAPIClusterHealthRequest {
	return DefaultAPIClusterHealthRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterHealthExecute(r DefaultAPIClusterHealthRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterHealth")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	if r.waitForNodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_nodes", r.waitForNodes, "")
	}
	if r.waitForEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_events", r.waitForEvents, "")
	}
	if r.waitForNoRelocatingShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_no_relocating_shards", r.waitForNoRelocatingShards, "")
	}
	if r.waitForNoInitializingShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_no_initializing_shards", r.waitForNoInitializingShards, "")
	}
	if r.waitForStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_status", r.waitForStatus, "")
	}
	if r.awarenessAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "awareness_attribute", r.awarenessAttribute, "")
	}
	if r.ensureNodeCommissioned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ensure_node_commissioned", r.ensureNodeCommissioned, "")
	} else {
		var defaultValue bool = false
		r.ensureNodeCommissioned = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterHealthWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	expandWildcards *ExpandWildcards
	level *ClusterHealthLevel
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	waitForActiveShards *string
	waitForNodes *string
	waitForEvents *WaitForEvents
	waitForNoRelocatingShards *bool
	waitForNoInitializingShards *bool
	waitForStatus *WaitForStatus
	awarenessAttribute *string
	ensureNodeCommissioned *bool
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIClusterHealthWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIClusterHealthWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify the level of detail for returned information.
func (r DefaultAPIClusterHealthWithIndexRequest) Level(level ClusterHealthLevel) DefaultAPIClusterHealthWithIndexRequest {
	r.level = &level
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIClusterHealthWithIndexRequest) Local(local bool) DefaultAPIClusterHealthWithIndexRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterHealthWithIndexRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterHealthWithIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIClusterHealthWithIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIClusterHealthWithIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r DefaultAPIClusterHealthWithIndexRequest) Timeout(timeout string) DefaultAPIClusterHealthWithIndexRequest {
	r.timeout = &timeout
	return r
}

// Wait until the specified number of shards is active.
func (r DefaultAPIClusterHealthWithIndexRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIClusterHealthWithIndexRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Wait until the specified number of nodes is available.
func (r DefaultAPIClusterHealthWithIndexRequest) WaitForNodes(waitForNodes string) DefaultAPIClusterHealthWithIndexRequest {
	r.waitForNodes = &waitForNodes
	return r
}

// Wait until all currently queued events with the given priority are processed.
func (r DefaultAPIClusterHealthWithIndexRequest) WaitForEvents(waitForEvents WaitForEvents) DefaultAPIClusterHealthWithIndexRequest {
	r.waitForEvents = &waitForEvents
	return r
}

// Whether to wait until there are no relocating shards in the cluster.
func (r DefaultAPIClusterHealthWithIndexRequest) WaitForNoRelocatingShards(waitForNoRelocatingShards bool) DefaultAPIClusterHealthWithIndexRequest {
	r.waitForNoRelocatingShards = &waitForNoRelocatingShards
	return r
}

// Whether to wait until there are no initializing shards in the cluster.
func (r DefaultAPIClusterHealthWithIndexRequest) WaitForNoInitializingShards(waitForNoInitializingShards bool) DefaultAPIClusterHealthWithIndexRequest {
	r.waitForNoInitializingShards = &waitForNoInitializingShards
	return r
}

// Wait until cluster is in a specific state.
func (r DefaultAPIClusterHealthWithIndexRequest) WaitForStatus(waitForStatus WaitForStatus) DefaultAPIClusterHealthWithIndexRequest {
	r.waitForStatus = &waitForStatus
	return r
}

// The awareness attribute for which the health is required.
func (r DefaultAPIClusterHealthWithIndexRequest) AwarenessAttribute(awarenessAttribute string) DefaultAPIClusterHealthWithIndexRequest {
	r.awarenessAttribute = &awarenessAttribute
	return r
}

// Checks whether local node is commissioned or not. If set to true on a local call it will throw exception if node is decommissioned.
func (r DefaultAPIClusterHealthWithIndexRequest) EnsureNodeCommissioned(ensureNodeCommissioned bool) DefaultAPIClusterHealthWithIndexRequest {
	r.ensureNodeCommissioned = &ensureNodeCommissioned
	return r
}

func (r DefaultAPIClusterHealthWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterHealthWithIndexExecute(r)
}

/*
ClusterHealthWithIndex Method for ClusterHealthWithIndex

Returns basic information about the health of the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Limit the information returned to specific indicies.
 @return DefaultAPIClusterHealthWithIndexRequest
*/
func (a *DefaultAPIService) ClusterHealthWithIndex(ctx context.Context, index string) DefaultAPIClusterHealthWithIndexRequest {
	return DefaultAPIClusterHealthWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterHealthWithIndexExecute(r DefaultAPIClusterHealthWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterHealthWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/health/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	if r.waitForNodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_nodes", r.waitForNodes, "")
	}
	if r.waitForEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_events", r.waitForEvents, "")
	}
	if r.waitForNoRelocatingShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_no_relocating_shards", r.waitForNoRelocatingShards, "")
	}
	if r.waitForNoInitializingShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_no_initializing_shards", r.waitForNoInitializingShards, "")
	}
	if r.waitForStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_status", r.waitForStatus, "")
	}
	if r.awarenessAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "awareness_attribute", r.awarenessAttribute, "")
	}
	if r.ensureNodeCommissioned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ensure_node_commissioned", r.ensureNodeCommissioned, "")
	} else {
		var defaultValue bool = false
		r.ensureNodeCommissioned = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterPendingTasksRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIClusterPendingTasksRequest) Local(local bool) DefaultAPIClusterPendingTasksRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterPendingTasksRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterPendingTasksRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIClusterPendingTasksRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIClusterPendingTasksRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIClusterPendingTasksRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterPendingTasksExecute(r)
}

/*
ClusterPendingTasks Method for ClusterPendingTasks

Returns a list of any cluster-level changes (e.g. create index, update mapping,
allocate or fail shard) which have not yet been executed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterPendingTasksRequest
*/
func (a *DefaultAPIService) ClusterPendingTasks(ctx context.Context) DefaultAPIClusterPendingTasksRequest {
	return DefaultAPIClusterPendingTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterPendingTasksExecute(r DefaultAPIClusterPendingTasksRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterPendingTasks")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/pending_tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterPostVotingConfigExclusionsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeIds *string
	nodeNames *string
	timeout *string
}

// Comma-separated list of the persistent ids of the nodes to exclude from the voting configuration. If specified, you may not also specify ?node_names.
func (r DefaultAPIClusterPostVotingConfigExclusionsRequest) NodeIds(nodeIds string) DefaultAPIClusterPostVotingConfigExclusionsRequest {
	r.nodeIds = &nodeIds
	return r
}

// Comma-separated list of the names of the nodes to exclude from the voting configuration. If specified, you may not also specify ?node_ids.
func (r DefaultAPIClusterPostVotingConfigExclusionsRequest) NodeNames(nodeNames string) DefaultAPIClusterPostVotingConfigExclusionsRequest {
	r.nodeNames = &nodeNames
	return r
}

// Operation timeout.
func (r DefaultAPIClusterPostVotingConfigExclusionsRequest) Timeout(timeout string) DefaultAPIClusterPostVotingConfigExclusionsRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPIClusterPostVotingConfigExclusionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterPostVotingConfigExclusionsExecute(r)
}

/*
ClusterPostVotingConfigExclusions Method for ClusterPostVotingConfigExclusions

Updates the cluster voting config exclusions by node ids or node names.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterPostVotingConfigExclusionsRequest
*/
func (a *DefaultAPIService) ClusterPostVotingConfigExclusions(ctx context.Context) DefaultAPIClusterPostVotingConfigExclusionsRequest {
	return DefaultAPIClusterPostVotingConfigExclusionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterPostVotingConfigExclusionsExecute(r DefaultAPIClusterPostVotingConfigExclusionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterPostVotingConfigExclusions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/voting_config_exclusions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodeIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_ids", r.nodeIds, "")
	}
	if r.nodeNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_names", r.nodeNames, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterPutComponentTemplatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	body *map[string]interface{}
	create *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r DefaultAPIClusterPutComponentTemplatePostRequest) Body(body map[string]interface{}) DefaultAPIClusterPutComponentTemplatePostRequest {
	r.body = &body
	return r
}

// Whether the index template should only be added if new or can also replace an existing one.
func (r DefaultAPIClusterPutComponentTemplatePostRequest) Create(create bool) DefaultAPIClusterPutComponentTemplatePostRequest {
	r.create = &create
	return r
}

// Operation timeout.
func (r DefaultAPIClusterPutComponentTemplatePostRequest) Timeout(timeout string) DefaultAPIClusterPutComponentTemplatePostRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterPutComponentTemplatePostRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterPutComponentTemplatePostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIClusterPutComponentTemplatePostRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIClusterPutComponentTemplatePostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIClusterPutComponentTemplatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterPutComponentTemplatePostExecute(r)
}

/*
ClusterPutComponentTemplatePost Method for ClusterPutComponentTemplatePost

Creates or updates a component template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return DefaultAPIClusterPutComponentTemplatePostRequest
*/
func (a *DefaultAPIService) ClusterPutComponentTemplatePost(ctx context.Context, name string) DefaultAPIClusterPutComponentTemplatePostRequest {
	return DefaultAPIClusterPutComponentTemplatePostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterPutComponentTemplatePostExecute(r DefaultAPIClusterPutComponentTemplatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterPutComponentTemplatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_component_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterPutComponentTemplatePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	body *map[string]interface{}
	create *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r DefaultAPIClusterPutComponentTemplatePutRequest) Body(body map[string]interface{}) DefaultAPIClusterPutComponentTemplatePutRequest {
	r.body = &body
	return r
}

// Whether the index template should only be added if new or can also replace an existing one.
func (r DefaultAPIClusterPutComponentTemplatePutRequest) Create(create bool) DefaultAPIClusterPutComponentTemplatePutRequest {
	r.create = &create
	return r
}

// Operation timeout.
func (r DefaultAPIClusterPutComponentTemplatePutRequest) Timeout(timeout string) DefaultAPIClusterPutComponentTemplatePutRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterPutComponentTemplatePutRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterPutComponentTemplatePutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIClusterPutComponentTemplatePutRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIClusterPutComponentTemplatePutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIClusterPutComponentTemplatePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterPutComponentTemplatePutExecute(r)
}

/*
ClusterPutComponentTemplatePut Method for ClusterPutComponentTemplatePut

Creates or updates a component template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return DefaultAPIClusterPutComponentTemplatePutRequest
*/
func (a *DefaultAPIService) ClusterPutComponentTemplatePut(ctx context.Context, name string) DefaultAPIClusterPutComponentTemplatePutRequest {
	return DefaultAPIClusterPutComponentTemplatePutRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterPutComponentTemplatePutExecute(r DefaultAPIClusterPutComponentTemplatePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterPutComponentTemplatePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_component_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterPutDecommissionAwarenessRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	awarenessAttributeName string
	awarenessAttributeValue string
}

func (r DefaultAPIClusterPutDecommissionAwarenessRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterPutDecommissionAwarenessExecute(r)
}

/*
ClusterPutDecommissionAwareness Method for ClusterPutDecommissionAwareness

Decommissions an awareness attribute.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awarenessAttributeName Awareness attribute name.
 @param awarenessAttributeValue Awareness attribute value.
 @return DefaultAPIClusterPutDecommissionAwarenessRequest
*/
func (a *DefaultAPIService) ClusterPutDecommissionAwareness(ctx context.Context, awarenessAttributeName string, awarenessAttributeValue string) DefaultAPIClusterPutDecommissionAwarenessRequest {
	return DefaultAPIClusterPutDecommissionAwarenessRequest{
		ApiService: a,
		ctx: ctx,
		awarenessAttributeName: awarenessAttributeName,
		awarenessAttributeValue: awarenessAttributeValue,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterPutDecommissionAwarenessExecute(r DefaultAPIClusterPutDecommissionAwarenessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterPutDecommissionAwareness")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/decommission/awareness/{awareness_attribute_name}/{awareness_attribute_value}"
	localVarPath = strings.Replace(localVarPath, "{"+"awareness_attribute_name"+"}", url.PathEscape(parameterValueToString(r.awarenessAttributeName, "awarenessAttributeName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awareness_attribute_value"+"}", url.PathEscape(parameterValueToString(r.awarenessAttributeValue, "awarenessAttributeValue")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterPutSettingsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	clusterPutSettingsBodyParams *ClusterPutSettingsBodyParams
	flatSettings *bool
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
}

func (r DefaultAPIClusterPutSettingsRequest) ClusterPutSettingsBodyParams(clusterPutSettingsBodyParams ClusterPutSettingsBodyParams) DefaultAPIClusterPutSettingsRequest {
	r.clusterPutSettingsBodyParams = &clusterPutSettingsBodyParams
	return r
}

// Return settings in flat format.
func (r DefaultAPIClusterPutSettingsRequest) FlatSettings(flatSettings bool) DefaultAPIClusterPutSettingsRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterPutSettingsRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterPutSettingsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIClusterPutSettingsRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIClusterPutSettingsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r DefaultAPIClusterPutSettingsRequest) Timeout(timeout string) DefaultAPIClusterPutSettingsRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPIClusterPutSettingsRequest) Execute() (*ClusterPutSettingsResponseContent, *http.Response, error) {
	return r.ApiService.ClusterPutSettingsExecute(r)
}

/*
ClusterPutSettings Method for ClusterPutSettings

Updates the cluster settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterPutSettingsRequest
*/
func (a *DefaultAPIService) ClusterPutSettings(ctx context.Context) DefaultAPIClusterPutSettingsRequest {
	return DefaultAPIClusterPutSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClusterPutSettingsResponseContent
func (a *DefaultAPIService) ClusterPutSettingsExecute(r DefaultAPIClusterPutSettingsRequest) (*ClusterPutSettingsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterPutSettingsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterPutSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterPutSettingsBodyParams == nil {
		return localVarReturnValue, nil, reportError("clusterPutSettingsBodyParams is required and must be specified")
	}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clusterPutSettingsBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIClusterPutWeightedRoutingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	attribute string
}

func (r DefaultAPIClusterPutWeightedRoutingRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterPutWeightedRoutingExecute(r)
}

/*
ClusterPutWeightedRouting Method for ClusterPutWeightedRouting

Updates weighted shard routing weights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attribute Awareness attribute name.
 @return DefaultAPIClusterPutWeightedRoutingRequest
*/
func (a *DefaultAPIService) ClusterPutWeightedRouting(ctx context.Context, attribute string) DefaultAPIClusterPutWeightedRoutingRequest {
	return DefaultAPIClusterPutWeightedRoutingRequest{
		ApiService: a,
		ctx: ctx,
		attribute: attribute,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterPutWeightedRoutingExecute(r DefaultAPIClusterPutWeightedRoutingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterPutWeightedRouting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/routing/awareness/{attribute}/weights"
	localVarPath = strings.Replace(localVarPath, "{"+"attribute"+"}", url.PathEscape(parameterValueToString(r.attribute, "attribute")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterRemoteInfoRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIClusterRemoteInfoRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterRemoteInfoExecute(r)
}

/*
ClusterRemoteInfo Method for ClusterRemoteInfo

Returns the information about configured remote clusters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterRemoteInfoRequest
*/
func (a *DefaultAPIService) ClusterRemoteInfo(ctx context.Context) DefaultAPIClusterRemoteInfoRequest {
	return DefaultAPIClusterRemoteInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterRemoteInfoExecute(r DefaultAPIClusterRemoteInfoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterRemoteInfo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_remote/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterRerouteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	dryRun *bool
	explain *bool
	retryFailed *bool
	metric *[]ClusterRerouteMetricMember
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	body *map[string]interface{}
}

// Simulate the operation only and return the resulting state.
func (r DefaultAPIClusterRerouteRequest) DryRun(dryRun bool) DefaultAPIClusterRerouteRequest {
	r.dryRun = &dryRun
	return r
}

// Return an explanation of why the commands can or cannot be executed.
func (r DefaultAPIClusterRerouteRequest) Explain(explain bool) DefaultAPIClusterRerouteRequest {
	r.explain = &explain
	return r
}

// Retries allocation of shards that are blocked due to too many subsequent allocation failures.
func (r DefaultAPIClusterRerouteRequest) RetryFailed(retryFailed bool) DefaultAPIClusterRerouteRequest {
	r.retryFailed = &retryFailed
	return r
}

// Limit the information returned to the specified metrics. Defaults to all but metadata.
func (r DefaultAPIClusterRerouteRequest) Metric(metric []ClusterRerouteMetricMember) DefaultAPIClusterRerouteRequest {
	r.metric = &metric
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterRerouteRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterRerouteRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIClusterRerouteRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIClusterRerouteRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r DefaultAPIClusterRerouteRequest) Timeout(timeout string) DefaultAPIClusterRerouteRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPIClusterRerouteRequest) Body(body map[string]interface{}) DefaultAPIClusterRerouteRequest {
	r.body = &body
	return r
}

func (r DefaultAPIClusterRerouteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterRerouteExecute(r)
}

/*
ClusterReroute Method for ClusterReroute

Allows to manually change the allocation of individual shards in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterRerouteRequest
*/
func (a *DefaultAPIService) ClusterReroute(ctx context.Context) DefaultAPIClusterRerouteRequest {
	return DefaultAPIClusterRerouteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterRerouteExecute(r DefaultAPIClusterRerouteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterReroute")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/reroute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dry_run", r.dryRun, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.retryFailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retry_failed", r.retryFailed, "")
	}
	if r.metric != nil {
		t := *r.metric
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "metric", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "metric", t, "multi")
		}
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterStateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	flatSettings *bool
	waitForMetadataVersion *int32
	waitForTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIClusterStateRequest) Local(local bool) DefaultAPIClusterStateRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterStateRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterStateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIClusterStateRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIClusterStateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return settings in flat format.
func (r DefaultAPIClusterStateRequest) FlatSettings(flatSettings bool) DefaultAPIClusterStateRequest {
	r.flatSettings = &flatSettings
	return r
}

// Wait for the metadata version to be equal or greater than the specified metadata version.
func (r DefaultAPIClusterStateRequest) WaitForMetadataVersion(waitForMetadataVersion int32) DefaultAPIClusterStateRequest {
	r.waitForMetadataVersion = &waitForMetadataVersion
	return r
}

// The maximum time to wait for wait_for_metadata_version before timing out.
func (r DefaultAPIClusterStateRequest) WaitForTimeout(waitForTimeout string) DefaultAPIClusterStateRequest {
	r.waitForTimeout = &waitForTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIClusterStateRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIClusterStateRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIClusterStateRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIClusterStateRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIClusterStateRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIClusterStateRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIClusterStateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterStateExecute(r)
}

/*
ClusterState Method for ClusterState

Returns a comprehensive information about the state of the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterStateRequest
*/
func (a *DefaultAPIService) ClusterState(ctx context.Context) DefaultAPIClusterStateRequest {
	return DefaultAPIClusterStateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterStateExecute(r DefaultAPIClusterStateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterState")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/state"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.waitForMetadataVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_metadata_version", r.waitForMetadataVersion, "")
	}
	if r.waitForTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_timeout", r.waitForTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterStateWithIndexMetricRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	metric string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	flatSettings *bool
	waitForMetadataVersion *int32
	waitForTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIClusterStateWithIndexMetricRequest) Local(local bool) DefaultAPIClusterStateWithIndexMetricRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterStateWithIndexMetricRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterStateWithIndexMetricRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIClusterStateWithIndexMetricRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIClusterStateWithIndexMetricRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return settings in flat format.
func (r DefaultAPIClusterStateWithIndexMetricRequest) FlatSettings(flatSettings bool) DefaultAPIClusterStateWithIndexMetricRequest {
	r.flatSettings = &flatSettings
	return r
}

// Wait for the metadata version to be equal or greater than the specified metadata version.
func (r DefaultAPIClusterStateWithIndexMetricRequest) WaitForMetadataVersion(waitForMetadataVersion int32) DefaultAPIClusterStateWithIndexMetricRequest {
	r.waitForMetadataVersion = &waitForMetadataVersion
	return r
}

// The maximum time to wait for wait_for_metadata_version before timing out.
func (r DefaultAPIClusterStateWithIndexMetricRequest) WaitForTimeout(waitForTimeout string) DefaultAPIClusterStateWithIndexMetricRequest {
	r.waitForTimeout = &waitForTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIClusterStateWithIndexMetricRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIClusterStateWithIndexMetricRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIClusterStateWithIndexMetricRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIClusterStateWithIndexMetricRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIClusterStateWithIndexMetricRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIClusterStateWithIndexMetricRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIClusterStateWithIndexMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterStateWithIndexMetricExecute(r)
}

/*
ClusterStateWithIndexMetric Method for ClusterStateWithIndexMetric

Returns a comprehensive information about the state of the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param metric Limit the information returned to the specified metrics.
 @return DefaultAPIClusterStateWithIndexMetricRequest
*/
func (a *DefaultAPIService) ClusterStateWithIndexMetric(ctx context.Context, index string, metric string) DefaultAPIClusterStateWithIndexMetricRequest {
	return DefaultAPIClusterStateWithIndexMetricRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		metric: metric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterStateWithIndexMetricExecute(r DefaultAPIClusterStateWithIndexMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterStateWithIndexMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/state/{metric}/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.waitForMetadataVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_metadata_version", r.waitForMetadataVersion, "")
	}
	if r.waitForTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_timeout", r.waitForTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterStateWithMetricRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	local *bool
	masterTimeout *string
	clusterManagerTimeout *string
	flatSettings *bool
	waitForMetadataVersion *int32
	waitForTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIClusterStateWithMetricRequest) Local(local bool) DefaultAPIClusterStateWithMetricRequest {
	r.local = &local
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIClusterStateWithMetricRequest) MasterTimeout(masterTimeout string) DefaultAPIClusterStateWithMetricRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIClusterStateWithMetricRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIClusterStateWithMetricRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return settings in flat format.
func (r DefaultAPIClusterStateWithMetricRequest) FlatSettings(flatSettings bool) DefaultAPIClusterStateWithMetricRequest {
	r.flatSettings = &flatSettings
	return r
}

// Wait for the metadata version to be equal or greater than the specified metadata version.
func (r DefaultAPIClusterStateWithMetricRequest) WaitForMetadataVersion(waitForMetadataVersion int32) DefaultAPIClusterStateWithMetricRequest {
	r.waitForMetadataVersion = &waitForMetadataVersion
	return r
}

// The maximum time to wait for wait_for_metadata_version before timing out.
func (r DefaultAPIClusterStateWithMetricRequest) WaitForTimeout(waitForTimeout string) DefaultAPIClusterStateWithMetricRequest {
	r.waitForTimeout = &waitForTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIClusterStateWithMetricRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIClusterStateWithMetricRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIClusterStateWithMetricRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIClusterStateWithMetricRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIClusterStateWithMetricRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIClusterStateWithMetricRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIClusterStateWithMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterStateWithMetricExecute(r)
}

/*
ClusterStateWithMetric Method for ClusterStateWithMetric

Returns a comprehensive information about the state of the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned to the specified metrics.
 @return DefaultAPIClusterStateWithMetricRequest
*/
func (a *DefaultAPIService) ClusterStateWithMetric(ctx context.Context, metric string) DefaultAPIClusterStateWithMetricRequest {
	return DefaultAPIClusterStateWithMetricRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterStateWithMetricExecute(r DefaultAPIClusterStateWithMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterStateWithMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/state/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.waitForMetadataVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_metadata_version", r.waitForMetadataVersion, "")
	}
	if r.waitForTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_timeout", r.waitForTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterStatsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	flatSettings *bool
	timeout *string
}

// Return settings in flat format.
func (r DefaultAPIClusterStatsRequest) FlatSettings(flatSettings bool) DefaultAPIClusterStatsRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout.
func (r DefaultAPIClusterStatsRequest) Timeout(timeout string) DefaultAPIClusterStatsRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPIClusterStatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterStatsExecute(r)
}

/*
ClusterStats Method for ClusterStats

Returns high-level overview of cluster statistics.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIClusterStatsRequest
*/
func (a *DefaultAPIService) ClusterStats(ctx context.Context) DefaultAPIClusterStatsRequest {
	return DefaultAPIClusterStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterStatsExecute(r DefaultAPIClusterStatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterStats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIClusterStatsWithNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	flatSettings *bool
	timeout *string
}

// Return settings in flat format.
func (r DefaultAPIClusterStatsWithNodeIdRequest) FlatSettings(flatSettings bool) DefaultAPIClusterStatsWithNodeIdRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout.
func (r DefaultAPIClusterStatsWithNodeIdRequest) Timeout(timeout string) DefaultAPIClusterStatsWithNodeIdRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPIClusterStatsWithNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClusterStatsWithNodeIdExecute(r)
}

/*
ClusterStatsWithNodeId Method for ClusterStatsWithNodeId

Returns high-level overview of cluster statistics.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return DefaultAPIClusterStatsWithNodeIdRequest
*/
func (a *DefaultAPIService) ClusterStatsWithNodeId(ctx context.Context, nodeId string) DefaultAPIClusterStatsWithNodeIdRequest {
	return DefaultAPIClusterStatsWithNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ClusterStatsWithNodeIdExecute(r DefaultAPIClusterStatsWithNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClusterStatsWithNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/stats/nodes/{node_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICountGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	minScore *int32
	preference *string
	routing *[]string
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	terminateAfter *int32
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPICountGetRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPICountGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r DefaultAPICountGetRequest) IgnoreThrottled(ignoreThrottled bool) DefaultAPICountGetRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPICountGetRequest) AllowNoIndices(allowNoIndices bool) DefaultAPICountGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPICountGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPICountGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Include only documents with a specific &#x60;_score&#x60; value in the result.
func (r DefaultAPICountGetRequest) MinScore(minScore int32) DefaultAPICountGetRequest {
	r.minScore = &minScore
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPICountGetRequest) Preference(preference string) DefaultAPICountGetRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPICountGetRequest) Routing(routing []string) DefaultAPICountGetRequest {
	r.routing = &routing
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPICountGetRequest) Q(q string) DefaultAPICountGetRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r DefaultAPICountGetRequest) Analyzer(analyzer string) DefaultAPICountGetRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r DefaultAPICountGetRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPICountGetRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPICountGetRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPICountGetRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r DefaultAPICountGetRequest) Df(df string) DefaultAPICountGetRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPICountGetRequest) Lenient(lenient bool) DefaultAPICountGetRequest {
	r.lenient = &lenient
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r DefaultAPICountGetRequest) TerminateAfter(terminateAfter int32) DefaultAPICountGetRequest {
	r.terminateAfter = &terminateAfter
	return r
}

func (r DefaultAPICountGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountGetExecute(r)
}

/*
CountGet Method for CountGet

Returns number of documents matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICountGetRequest
*/
func (a *DefaultAPIService) CountGet(ctx context.Context) DefaultAPICountGetRequest {
	return DefaultAPICountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CountGetExecute(r DefaultAPICountGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CountGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.minScore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_score", r.minScore, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICountGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	minScore *int32
	preference *string
	routing *[]string
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	terminateAfter *int32
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPICountGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPICountGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r DefaultAPICountGetWithIndexRequest) IgnoreThrottled(ignoreThrottled bool) DefaultAPICountGetWithIndexRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPICountGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPICountGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPICountGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPICountGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Include only documents with a specific &#x60;_score&#x60; value in the result.
func (r DefaultAPICountGetWithIndexRequest) MinScore(minScore int32) DefaultAPICountGetWithIndexRequest {
	r.minScore = &minScore
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPICountGetWithIndexRequest) Preference(preference string) DefaultAPICountGetWithIndexRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPICountGetWithIndexRequest) Routing(routing []string) DefaultAPICountGetWithIndexRequest {
	r.routing = &routing
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPICountGetWithIndexRequest) Q(q string) DefaultAPICountGetWithIndexRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r DefaultAPICountGetWithIndexRequest) Analyzer(analyzer string) DefaultAPICountGetWithIndexRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r DefaultAPICountGetWithIndexRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPICountGetWithIndexRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPICountGetWithIndexRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPICountGetWithIndexRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r DefaultAPICountGetWithIndexRequest) Df(df string) DefaultAPICountGetWithIndexRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPICountGetWithIndexRequest) Lenient(lenient bool) DefaultAPICountGetWithIndexRequest {
	r.lenient = &lenient
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r DefaultAPICountGetWithIndexRequest) TerminateAfter(terminateAfter int32) DefaultAPICountGetWithIndexRequest {
	r.terminateAfter = &terminateAfter
	return r
}

func (r DefaultAPICountGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountGetWithIndexExecute(r)
}

/*
CountGetWithIndex Method for CountGetWithIndex

Returns number of documents matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to restrict the results.
 @return DefaultAPICountGetWithIndexRequest
*/
func (a *DefaultAPIService) CountGetWithIndex(ctx context.Context, index string) DefaultAPICountGetWithIndexRequest {
	return DefaultAPICountGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CountGetWithIndexExecute(r DefaultAPICountGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CountGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_count"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.minScore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_score", r.minScore, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICountPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	minScore *int32
	preference *string
	routing *[]string
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	terminateAfter *int32
	body *map[string]interface{}
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPICountPostRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPICountPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r DefaultAPICountPostRequest) IgnoreThrottled(ignoreThrottled bool) DefaultAPICountPostRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPICountPostRequest) AllowNoIndices(allowNoIndices bool) DefaultAPICountPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPICountPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPICountPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Include only documents with a specific &#x60;_score&#x60; value in the result.
func (r DefaultAPICountPostRequest) MinScore(minScore int32) DefaultAPICountPostRequest {
	r.minScore = &minScore
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPICountPostRequest) Preference(preference string) DefaultAPICountPostRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPICountPostRequest) Routing(routing []string) DefaultAPICountPostRequest {
	r.routing = &routing
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPICountPostRequest) Q(q string) DefaultAPICountPostRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r DefaultAPICountPostRequest) Analyzer(analyzer string) DefaultAPICountPostRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r DefaultAPICountPostRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPICountPostRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPICountPostRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPICountPostRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r DefaultAPICountPostRequest) Df(df string) DefaultAPICountPostRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPICountPostRequest) Lenient(lenient bool) DefaultAPICountPostRequest {
	r.lenient = &lenient
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r DefaultAPICountPostRequest) TerminateAfter(terminateAfter int32) DefaultAPICountPostRequest {
	r.terminateAfter = &terminateAfter
	return r
}

func (r DefaultAPICountPostRequest) Body(body map[string]interface{}) DefaultAPICountPostRequest {
	r.body = &body
	return r
}

func (r DefaultAPICountPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountPostExecute(r)
}

/*
CountPost Method for CountPost

Returns number of documents matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICountPostRequest
*/
func (a *DefaultAPIService) CountPost(ctx context.Context) DefaultAPICountPostRequest {
	return DefaultAPICountPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CountPostExecute(r DefaultAPICountPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CountPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.minScore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_score", r.minScore, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICountPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	minScore *int32
	preference *string
	routing *[]string
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	terminateAfter *int32
	body *map[string]interface{}
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPICountPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPICountPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r DefaultAPICountPostWithIndexRequest) IgnoreThrottled(ignoreThrottled bool) DefaultAPICountPostWithIndexRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPICountPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPICountPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPICountPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPICountPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Include only documents with a specific &#x60;_score&#x60; value in the result.
func (r DefaultAPICountPostWithIndexRequest) MinScore(minScore int32) DefaultAPICountPostWithIndexRequest {
	r.minScore = &minScore
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPICountPostWithIndexRequest) Preference(preference string) DefaultAPICountPostWithIndexRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPICountPostWithIndexRequest) Routing(routing []string) DefaultAPICountPostWithIndexRequest {
	r.routing = &routing
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPICountPostWithIndexRequest) Q(q string) DefaultAPICountPostWithIndexRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r DefaultAPICountPostWithIndexRequest) Analyzer(analyzer string) DefaultAPICountPostWithIndexRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r DefaultAPICountPostWithIndexRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPICountPostWithIndexRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPICountPostWithIndexRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPICountPostWithIndexRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r DefaultAPICountPostWithIndexRequest) Df(df string) DefaultAPICountPostWithIndexRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPICountPostWithIndexRequest) Lenient(lenient bool) DefaultAPICountPostWithIndexRequest {
	r.lenient = &lenient
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r DefaultAPICountPostWithIndexRequest) TerminateAfter(terminateAfter int32) DefaultAPICountPostWithIndexRequest {
	r.terminateAfter = &terminateAfter
	return r
}

func (r DefaultAPICountPostWithIndexRequest) Body(body map[string]interface{}) DefaultAPICountPostWithIndexRequest {
	r.body = &body
	return r
}

func (r DefaultAPICountPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountPostWithIndexExecute(r)
}

/*
CountPostWithIndex Method for CountPostWithIndex

Returns number of documents matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to restrict the results.
 @return DefaultAPICountPostWithIndexRequest
*/
func (a *DefaultAPIService) CountPostWithIndex(ctx context.Context, index string) DefaultAPICountPostWithIndexRequest {
	return DefaultAPICountPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CountPostWithIndexExecute(r DefaultAPICountPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CountPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_count"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.minScore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_score", r.minScore, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICreateActionGroupRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	actionGroup string
	actionGroup2 *ActionGroup
}

func (r DefaultAPICreateActionGroupRequest) ActionGroup2(actionGroup2 ActionGroup) DefaultAPICreateActionGroupRequest {
	r.actionGroup2 = &actionGroup2
	return r
}

func (r DefaultAPICreateActionGroupRequest) Execute() (*CreateActionGroupResponseContent, *http.Response, error) {
	return r.ApiService.CreateActionGroupExecute(r)
}

/*
CreateActionGroup Method for CreateActionGroup

Creates or replaces the specified action group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionGroup The name of the action group to create or replace
 @return DefaultAPICreateActionGroupRequest
*/
func (a *DefaultAPIService) CreateActionGroup(ctx context.Context, actionGroup string) DefaultAPICreateActionGroupRequest {
	return DefaultAPICreateActionGroupRequest{
		ApiService: a,
		ctx: ctx,
		actionGroup: actionGroup,
	}
}

// Execute executes the request
//  @return CreateActionGroupResponseContent
func (a *DefaultAPIService) CreateActionGroupExecute(r DefaultAPICreateActionGroupRequest) (*CreateActionGroupResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateActionGroupResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateActionGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/actiongroups/{action_group}"
	localVarPath = strings.Replace(localVarPath, "{"+"action_group"+"}", url.PathEscape(parameterValueToString(r.actionGroup, "actionGroup")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionGroup2 == nil {
		return localVarReturnValue, nil, reportError("actionGroup2 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionGroup2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICreatePitRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	allowPartialPitCreation *bool
	keepAlive *string
	preference *string
	routing *[]string
	expandWildcards *ExpandWildcards
}

// Allow if point in time can be created with partial failures.
func (r DefaultAPICreatePitRequest) AllowPartialPitCreation(allowPartialPitCreation bool) DefaultAPICreatePitRequest {
	r.allowPartialPitCreation = &allowPartialPitCreation
	return r
}

// Specify the keep alive for point in time.
func (r DefaultAPICreatePitRequest) KeepAlive(keepAlive string) DefaultAPICreatePitRequest {
	r.keepAlive = &keepAlive
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPICreatePitRequest) Preference(preference string) DefaultAPICreatePitRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPICreatePitRequest) Routing(routing []string) DefaultAPICreatePitRequest {
	r.routing = &routing
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPICreatePitRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPICreatePitRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPICreatePitRequest) Execute() (*CreatePitResponseContent, *http.Response, error) {
	return r.ApiService.CreatePitExecute(r)
}

/*
CreatePit Method for CreatePit

Creates point in time context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPICreatePitRequest
*/
func (a *DefaultAPIService) CreatePit(ctx context.Context, index string) DefaultAPICreatePitRequest {
	return DefaultAPICreatePitRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
//  @return CreatePitResponseContent
func (a *DefaultAPIService) CreatePitExecute(r DefaultAPICreatePitRequest) (*CreatePitResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePitResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreatePit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_search/point_in_time"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowPartialPitCreation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_partial_pit_creation", r.allowPartialPitCreation, "")
	}
	if r.keepAlive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keep_alive", r.keepAlive, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICreatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	refresh *RefreshEnum
	routing *string
	timeout *string
	version *int32
	versionType *VersionType
	pipeline *string
}

func (r DefaultAPICreatePostRequest) Body(body map[string]interface{}) DefaultAPICreatePostRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r DefaultAPICreatePostRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPICreatePostRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r DefaultAPICreatePostRequest) Refresh(refresh RefreshEnum) DefaultAPICreatePostRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPICreatePostRequest) Routing(routing string) DefaultAPICreatePostRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r DefaultAPICreatePostRequest) Timeout(timeout string) DefaultAPICreatePostRequest {
	r.timeout = &timeout
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPICreatePostRequest) Version(version int32) DefaultAPICreatePostRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPICreatePostRequest) VersionType(versionType VersionType) DefaultAPICreatePostRequest {
	r.versionType = &versionType
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r DefaultAPICreatePostRequest) Pipeline(pipeline string) DefaultAPICreatePostRequest {
	r.pipeline = &pipeline
	return r
}

func (r DefaultAPICreatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreatePostExecute(r)
}

/*
CreatePost Method for CreatePost

Creates a new document in the index.

Returns a 409 response when a document with a same ID already exists in the index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return DefaultAPICreatePostRequest
*/
func (a *DefaultAPIService) CreatePost(ctx context.Context, id string, index string) DefaultAPICreatePostRequest {
	return DefaultAPICreatePostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CreatePostExecute(r DefaultAPICreatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_create/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICreatePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	refresh *RefreshEnum
	routing *string
	timeout *string
	version *int32
	versionType *VersionType
	pipeline *string
}

func (r DefaultAPICreatePutRequest) Body(body map[string]interface{}) DefaultAPICreatePutRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r DefaultAPICreatePutRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPICreatePutRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r DefaultAPICreatePutRequest) Refresh(refresh RefreshEnum) DefaultAPICreatePutRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPICreatePutRequest) Routing(routing string) DefaultAPICreatePutRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r DefaultAPICreatePutRequest) Timeout(timeout string) DefaultAPICreatePutRequest {
	r.timeout = &timeout
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPICreatePutRequest) Version(version int32) DefaultAPICreatePutRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPICreatePutRequest) VersionType(versionType VersionType) DefaultAPICreatePutRequest {
	r.versionType = &versionType
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r DefaultAPICreatePutRequest) Pipeline(pipeline string) DefaultAPICreatePutRequest {
	r.pipeline = &pipeline
	return r
}

func (r DefaultAPICreatePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreatePutExecute(r)
}

/*
CreatePut Method for CreatePut

Creates a new document in the index.

Returns a 409 response when a document with a same ID already exists in the index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return DefaultAPICreatePutRequest
*/
func (a *DefaultAPIService) CreatePut(ctx context.Context, id string, index string) DefaultAPICreatePutRequest {
	return DefaultAPICreatePutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CreatePutExecute(r DefaultAPICreatePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreatePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_create/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPICreateRoleRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
	role2 *Role
}

func (r DefaultAPICreateRoleRequest) Role2(role2 Role) DefaultAPICreateRoleRequest {
	r.role2 = &role2
	return r
}

func (r DefaultAPICreateRoleRequest) Execute() (*CreateRoleResponseContent, *http.Response, error) {
	return r.ApiService.CreateRoleExecute(r)
}

/*
CreateRole Method for CreateRole

Creates or replaces the specified role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return DefaultAPICreateRoleRequest
*/
func (a *DefaultAPIService) CreateRole(ctx context.Context, role string) DefaultAPICreateRoleRequest {
	return DefaultAPICreateRoleRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return CreateRoleResponseContent
func (a *DefaultAPIService) CreateRoleExecute(r DefaultAPICreateRoleRequest) (*CreateRoleResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateRoleResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/roles/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.role2 == nil {
		return localVarReturnValue, nil, reportError("role2 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.role2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICreateRoleMappingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
	roleMapping *RoleMapping
}

func (r DefaultAPICreateRoleMappingRequest) RoleMapping(roleMapping RoleMapping) DefaultAPICreateRoleMappingRequest {
	r.roleMapping = &roleMapping
	return r
}

func (r DefaultAPICreateRoleMappingRequest) Execute() (*CreateRoleMappingResponseContent, *http.Response, error) {
	return r.ApiService.CreateRoleMappingExecute(r)
}

/*
CreateRoleMapping Method for CreateRoleMapping

Creates or replaces the specified role mapping.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return DefaultAPICreateRoleMappingRequest
*/
func (a *DefaultAPIService) CreateRoleMapping(ctx context.Context, role string) DefaultAPICreateRoleMappingRequest {
	return DefaultAPICreateRoleMappingRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return CreateRoleMappingResponseContent
func (a *DefaultAPIService) CreateRoleMappingExecute(r DefaultAPICreateRoleMappingRequest) (*CreateRoleMappingResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateRoleMappingResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateRoleMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/rolesmapping/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleMapping == nil {
		return localVarReturnValue, nil, reportError("roleMapping is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICreateTenantRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	tenant string
	createTenantParams *CreateTenantParams
}

func (r DefaultAPICreateTenantRequest) CreateTenantParams(createTenantParams CreateTenantParams) DefaultAPICreateTenantRequest {
	r.createTenantParams = &createTenantParams
	return r
}

func (r DefaultAPICreateTenantRequest) Execute() (*CreateTenantResponseContent, *http.Response, error) {
	return r.ApiService.CreateTenantExecute(r)
}

/*
CreateTenant Method for CreateTenant

Creates or replaces the specified tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @return DefaultAPICreateTenantRequest
*/
func (a *DefaultAPIService) CreateTenant(ctx context.Context, tenant string) DefaultAPICreateTenantRequest {
	return DefaultAPICreateTenantRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
	}
}

// Execute executes the request
//  @return CreateTenantResponseContent
func (a *DefaultAPIService) CreateTenantExecute(r DefaultAPICreateTenantRequest) (*CreateTenantResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTenantResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateTenant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/tenants/{tenant}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTenantParams == nil {
		return localVarReturnValue, nil, reportError("createTenantParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTenantParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICreateUserRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	username string
	user *User
}

func (r DefaultAPICreateUserRequest) User(user User) DefaultAPICreateUserRequest {
	r.user = &user
	return r
}

func (r DefaultAPICreateUserRequest) Execute() (*CreateUserResponseContent, *http.Response, error) {
	return r.ApiService.CreateUserExecute(r)
}

/*
CreateUser Method for CreateUser

Creates or replaces the specified user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username
 @return DefaultAPICreateUserRequest
*/
func (a *DefaultAPIService) CreateUser(ctx context.Context, username string) DefaultAPICreateUserRequest {
	return DefaultAPICreateUserRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return CreateUserResponseContent
func (a *DefaultAPIService) CreateUserExecute(r DefaultAPICreateUserRequest) (*CreateUserResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateUserResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/internalusers/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterValueToString(r.username, "username")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.user == nil {
		return localVarReturnValue, nil, reportError("user is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.user
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIDanglingIndicesDeleteDanglingIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	indexUuid string
	acceptDataLoss *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Must be set to true in order to delete the dangling index.
func (r DefaultAPIDanglingIndicesDeleteDanglingIndexRequest) AcceptDataLoss(acceptDataLoss bool) DefaultAPIDanglingIndicesDeleteDanglingIndexRequest {
	r.acceptDataLoss = &acceptDataLoss
	return r
}

// Operation timeout.
func (r DefaultAPIDanglingIndicesDeleteDanglingIndexRequest) Timeout(timeout string) DefaultAPIDanglingIndicesDeleteDanglingIndexRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIDanglingIndicesDeleteDanglingIndexRequest) MasterTimeout(masterTimeout string) DefaultAPIDanglingIndicesDeleteDanglingIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIDanglingIndicesDeleteDanglingIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIDanglingIndicesDeleteDanglingIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIDanglingIndicesDeleteDanglingIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.DanglingIndicesDeleteDanglingIndexExecute(r)
}

/*
DanglingIndicesDeleteDanglingIndex Method for DanglingIndicesDeleteDanglingIndex

Deletes the specified dangling index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexUuid The UUID of the dangling index.
 @return DefaultAPIDanglingIndicesDeleteDanglingIndexRequest
*/
func (a *DefaultAPIService) DanglingIndicesDeleteDanglingIndex(ctx context.Context, indexUuid string) DefaultAPIDanglingIndicesDeleteDanglingIndexRequest {
	return DefaultAPIDanglingIndicesDeleteDanglingIndexRequest{
		ApiService: a,
		ctx: ctx,
		indexUuid: indexUuid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DanglingIndicesDeleteDanglingIndexExecute(r DefaultAPIDanglingIndicesDeleteDanglingIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DanglingIndicesDeleteDanglingIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_dangling/{index_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"index_uuid"+"}", url.PathEscape(parameterValueToString(r.indexUuid, "indexUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.acceptDataLoss != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accept_data_loss", r.acceptDataLoss, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIDanglingIndicesImportDanglingIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	indexUuid string
	acceptDataLoss *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Must be set to true in order to import the dangling index.
func (r DefaultAPIDanglingIndicesImportDanglingIndexRequest) AcceptDataLoss(acceptDataLoss bool) DefaultAPIDanglingIndicesImportDanglingIndexRequest {
	r.acceptDataLoss = &acceptDataLoss
	return r
}

// Operation timeout.
func (r DefaultAPIDanglingIndicesImportDanglingIndexRequest) Timeout(timeout string) DefaultAPIDanglingIndicesImportDanglingIndexRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIDanglingIndicesImportDanglingIndexRequest) MasterTimeout(masterTimeout string) DefaultAPIDanglingIndicesImportDanglingIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIDanglingIndicesImportDanglingIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIDanglingIndicesImportDanglingIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIDanglingIndicesImportDanglingIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.DanglingIndicesImportDanglingIndexExecute(r)
}

/*
DanglingIndicesImportDanglingIndex Method for DanglingIndicesImportDanglingIndex

Imports the specified dangling index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexUuid The UUID of the dangling index.
 @return DefaultAPIDanglingIndicesImportDanglingIndexRequest
*/
func (a *DefaultAPIService) DanglingIndicesImportDanglingIndex(ctx context.Context, indexUuid string) DefaultAPIDanglingIndicesImportDanglingIndexRequest {
	return DefaultAPIDanglingIndicesImportDanglingIndexRequest{
		ApiService: a,
		ctx: ctx,
		indexUuid: indexUuid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DanglingIndicesImportDanglingIndexExecute(r DefaultAPIDanglingIndicesImportDanglingIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DanglingIndicesImportDanglingIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_dangling/{index_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"index_uuid"+"}", url.PathEscape(parameterValueToString(r.indexUuid, "indexUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.acceptDataLoss != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accept_data_loss", r.acceptDataLoss, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIDanglingIndicesListDanglingIndicesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIDanglingIndicesListDanglingIndicesRequest) Execute() (*http.Response, error) {
	return r.ApiService.DanglingIndicesListDanglingIndicesExecute(r)
}

/*
DanglingIndicesListDanglingIndices Method for DanglingIndicesListDanglingIndices

Returns all dangling indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIDanglingIndicesListDanglingIndicesRequest
*/
func (a *DefaultAPIService) DanglingIndicesListDanglingIndices(ctx context.Context) DefaultAPIDanglingIndicesListDanglingIndicesRequest {
	return DefaultAPIDanglingIndicesListDanglingIndicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DanglingIndicesListDanglingIndicesExecute(r DefaultAPIDanglingIndicesListDanglingIndicesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DanglingIndicesListDanglingIndices")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_dangling"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	waitForActiveShards *string
	refresh *RefreshEnum
	routing *string
	timeout *string
	ifSeqNo *int32
	ifPrimaryTerm *int32
	version *int32
	versionType *VersionType
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r DefaultAPIDeleteRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIDeleteRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r DefaultAPIDeleteRequest) Refresh(refresh RefreshEnum) DefaultAPIDeleteRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIDeleteRequest) Routing(routing string) DefaultAPIDeleteRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r DefaultAPIDeleteRequest) Timeout(timeout string) DefaultAPIDeleteRequest {
	r.timeout = &timeout
	return r
}

// only perform the operation if the last operation that has changed the document has the specified sequence number.
func (r DefaultAPIDeleteRequest) IfSeqNo(ifSeqNo int32) DefaultAPIDeleteRequest {
	r.ifSeqNo = &ifSeqNo
	return r
}

// only perform the operation if the last operation that has changed the document has the specified primary term.
func (r DefaultAPIDeleteRequest) IfPrimaryTerm(ifPrimaryTerm int32) DefaultAPIDeleteRequest {
	r.ifPrimaryTerm = &ifPrimaryTerm
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPIDeleteRequest) Version(version int32) DefaultAPIDeleteRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPIDeleteRequest) VersionType(versionType VersionType) DefaultAPIDeleteRequest {
	r.versionType = &versionType
	return r
}

func (r DefaultAPIDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteExecute(r)
}

/*
Delete Method for Delete

Removes a document from the index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return DefaultAPIDeleteRequest
*/
func (a *DefaultAPIService) Delete(ctx context.Context, id string, index string) DefaultAPIDeleteRequest {
	return DefaultAPIDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DeleteExecute(r DefaultAPIDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Delete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_doc/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.ifSeqNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_seq_no", r.ifSeqNo, "")
	}
	if r.ifPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_primary_term", r.ifPrimaryTerm, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIDeleteActionGroupRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	actionGroup string
}

func (r DefaultAPIDeleteActionGroupRequest) Execute() (*DeleteActionGroupResponseContent, *http.Response, error) {
	return r.ApiService.DeleteActionGroupExecute(r)
}

/*
DeleteActionGroup Method for DeleteActionGroup

Delete a specified action group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionGroup Action group to delete.
 @return DefaultAPIDeleteActionGroupRequest
*/
func (a *DefaultAPIService) DeleteActionGroup(ctx context.Context, actionGroup string) DefaultAPIDeleteActionGroupRequest {
	return DefaultAPIDeleteActionGroupRequest{
		ApiService: a,
		ctx: ctx,
		actionGroup: actionGroup,
	}
}

// Execute executes the request
//  @return DeleteActionGroupResponseContent
func (a *DefaultAPIService) DeleteActionGroupExecute(r DefaultAPIDeleteActionGroupRequest) (*DeleteActionGroupResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteActionGroupResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteActionGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/actiongroups/{action_group}"
	localVarPath = strings.Replace(localVarPath, "{"+"action_group"+"}", url.PathEscape(parameterValueToString(r.actionGroup, "actionGroup")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIDeleteAllPitsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIDeleteAllPitsRequest) Execute() (*DeleteAllPitsResponseContent, *http.Response, error) {
	return r.ApiService.DeleteAllPitsExecute(r)
}

/*
DeleteAllPits Method for DeleteAllPits

Deletes all active point in time searches.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIDeleteAllPitsRequest
*/
func (a *DefaultAPIService) DeleteAllPits(ctx context.Context) DefaultAPIDeleteAllPitsRequest {
	return DefaultAPIDeleteAllPitsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteAllPitsResponseContent
func (a *DefaultAPIService) DeleteAllPitsExecute(r DefaultAPIDeleteAllPitsRequest) (*DeleteAllPitsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteAllPitsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteAllPits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/point_in_time/_all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIDeleteByQueryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	from *int32
	ignoreUnavailable *bool
	allowNoIndices *bool
	conflicts *Conflicts
	expandWildcards *ExpandWildcards
	lenient *bool
	preference *string
	q *string
	routing *[]string
	scroll *string
	searchType *SearchType
	searchTimeout *string
	size *int32
	maxDocs *int32
	sort *[]string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	terminateAfter *int32
	stats *[]string
	version *bool
	requestCache *bool
	refresh *bool
	timeout *string
	waitForActiveShards *string
	scrollSize *int32
	waitForCompletion *bool
	requestsPerSecond *int32
	slices *string
}

func (r DefaultAPIDeleteByQueryRequest) Body(body map[string]interface{}) DefaultAPIDeleteByQueryRequest {
	r.body = &body
	return r
}

// The analyzer to use for the query string.
func (r DefaultAPIDeleteByQueryRequest) Analyzer(analyzer string) DefaultAPIDeleteByQueryRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r DefaultAPIDeleteByQueryRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPIDeleteByQueryRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPIDeleteByQueryRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPIDeleteByQueryRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r DefaultAPIDeleteByQueryRequest) Df(df string) DefaultAPIDeleteByQueryRequest {
	r.df = &df
	return r
}

// Starting offset.
func (r DefaultAPIDeleteByQueryRequest) From(from int32) DefaultAPIDeleteByQueryRequest {
	r.from = &from
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIDeleteByQueryRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIDeleteByQueryRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIDeleteByQueryRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIDeleteByQueryRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// What to do when the operation encounters version conflicts?.
func (r DefaultAPIDeleteByQueryRequest) Conflicts(conflicts Conflicts) DefaultAPIDeleteByQueryRequest {
	r.conflicts = &conflicts
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIDeleteByQueryRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIDeleteByQueryRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPIDeleteByQueryRequest) Lenient(lenient bool) DefaultAPIDeleteByQueryRequest {
	r.lenient = &lenient
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPIDeleteByQueryRequest) Preference(preference string) DefaultAPIDeleteByQueryRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPIDeleteByQueryRequest) Q(q string) DefaultAPIDeleteByQueryRequest {
	r.q = &q
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPIDeleteByQueryRequest) Routing(routing []string) DefaultAPIDeleteByQueryRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPIDeleteByQueryRequest) Scroll(scroll string) DefaultAPIDeleteByQueryRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r DefaultAPIDeleteByQueryRequest) SearchType(searchType SearchType) DefaultAPIDeleteByQueryRequest {
	r.searchType = &searchType
	return r
}

// Explicit timeout for each search request. Defaults to no timeout.
func (r DefaultAPIDeleteByQueryRequest) SearchTimeout(searchTimeout string) DefaultAPIDeleteByQueryRequest {
	r.searchTimeout = &searchTimeout
	return r
}

// Deprecated, please use &#x60;max_docs&#x60; instead.
func (r DefaultAPIDeleteByQueryRequest) Size(size int32) DefaultAPIDeleteByQueryRequest {
	r.size = &size
	return r
}

// Maximum number of documents to process (default: all documents).
func (r DefaultAPIDeleteByQueryRequest) MaxDocs(maxDocs int32) DefaultAPIDeleteByQueryRequest {
	r.maxDocs = &maxDocs
	return r
}

// Comma-separated list of &lt;field&gt;:&lt;direction&gt; pairs.
func (r DefaultAPIDeleteByQueryRequest) Sort(sort []string) DefaultAPIDeleteByQueryRequest {
	r.sort = &sort
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPIDeleteByQueryRequest) Source(source []string) DefaultAPIDeleteByQueryRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPIDeleteByQueryRequest) SourceExcludes(sourceExcludes []string) DefaultAPIDeleteByQueryRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPIDeleteByQueryRequest) SourceIncludes(sourceIncludes []string) DefaultAPIDeleteByQueryRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r DefaultAPIDeleteByQueryRequest) TerminateAfter(terminateAfter int32) DefaultAPIDeleteByQueryRequest {
	r.terminateAfter = &terminateAfter
	return r
}

// Specific &#39;tag&#39; of the request for logging and statistical purposes.
func (r DefaultAPIDeleteByQueryRequest) Stats(stats []string) DefaultAPIDeleteByQueryRequest {
	r.stats = &stats
	return r
}

// Whether to return document version as part of a hit.
func (r DefaultAPIDeleteByQueryRequest) Version(version bool) DefaultAPIDeleteByQueryRequest {
	r.version = &version
	return r
}

// Specify if request cache should be used for this request or not, defaults to index level setting.
func (r DefaultAPIDeleteByQueryRequest) RequestCache(requestCache bool) DefaultAPIDeleteByQueryRequest {
	r.requestCache = &requestCache
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r DefaultAPIDeleteByQueryRequest) Refresh(refresh bool) DefaultAPIDeleteByQueryRequest {
	r.refresh = &refresh
	return r
}

// Time each individual bulk request should wait for shards that are unavailable.
func (r DefaultAPIDeleteByQueryRequest) Timeout(timeout string) DefaultAPIDeleteByQueryRequest {
	r.timeout = &timeout
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r DefaultAPIDeleteByQueryRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIDeleteByQueryRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Size on the scroll request powering the operation.
func (r DefaultAPIDeleteByQueryRequest) ScrollSize(scrollSize int32) DefaultAPIDeleteByQueryRequest {
	r.scrollSize = &scrollSize
	return r
}

// Should this request wait until the operation has completed before returning.
func (r DefaultAPIDeleteByQueryRequest) WaitForCompletion(waitForCompletion bool) DefaultAPIDeleteByQueryRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

// The throttle for this request in sub-requests per second. -1 means no throttle.
func (r DefaultAPIDeleteByQueryRequest) RequestsPerSecond(requestsPerSecond int32) DefaultAPIDeleteByQueryRequest {
	r.requestsPerSecond = &requestsPerSecond
	return r
}

// The number of slices this task should be divided into. Defaults to 1, meaning the task isn&#39;t sliced into subtasks. Can be set to &#x60;auto&#x60;.
func (r DefaultAPIDeleteByQueryRequest) Slices(slices string) DefaultAPIDeleteByQueryRequest {
	r.slices = &slices
	return r
}

func (r DefaultAPIDeleteByQueryRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteByQueryExecute(r)
}

/*
DeleteByQuery Method for DeleteByQuery

Deletes documents matching the provided query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIDeleteByQueryRequest
*/
func (a *DefaultAPIService) DeleteByQuery(ctx context.Context, index string) DefaultAPIDeleteByQueryRequest {
	return DefaultAPIDeleteByQueryRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DeleteByQueryExecute(r DefaultAPIDeleteByQueryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteByQuery")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_delete_by_query"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	} else {
		var defaultValue int32 = 0
		r.from = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.searchTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_timeout", r.searchTimeout, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.maxDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_docs", r.maxDocs, "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	if r.stats != nil {
		t := *r.stats
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stats", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stats", t, "multi")
		}
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.requestCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_cache", r.requestCache, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	} else {
		var defaultValue string = "1m"
		r.timeout = &defaultValue
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.scrollSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll_size", r.scrollSize, "")
	} else {
		var defaultValue int32 = 100
		r.scrollSize = &defaultValue
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = true
		r.waitForCompletion = &defaultValue
	}
	if r.requestsPerSecond != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requests_per_second", r.requestsPerSecond, "")
	} else {
		var defaultValue int32 = 0
		r.requestsPerSecond = &defaultValue
	}
	if r.slices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slices", r.slices, "")
	} else {
		var defaultValue string = "1"
		r.slices = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIDeleteByQueryRethrottleRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	requestsPerSecond *int32
}

// The throttle for this request in sub-requests per second. -1 means no throttle.
func (r DefaultAPIDeleteByQueryRethrottleRequest) RequestsPerSecond(requestsPerSecond int32) DefaultAPIDeleteByQueryRethrottleRequest {
	r.requestsPerSecond = &requestsPerSecond
	return r
}

func (r DefaultAPIDeleteByQueryRethrottleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteByQueryRethrottleExecute(r)
}

/*
DeleteByQueryRethrottle Method for DeleteByQueryRethrottle

Changes the number of requests per second for a particular Delete By Query operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id to rethrottle.
 @return DefaultAPIDeleteByQueryRethrottleRequest
*/
func (a *DefaultAPIService) DeleteByQueryRethrottle(ctx context.Context, taskId string) DefaultAPIDeleteByQueryRethrottleRequest {
	return DefaultAPIDeleteByQueryRethrottleRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DeleteByQueryRethrottleExecute(r DefaultAPIDeleteByQueryRethrottleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteByQueryRethrottle")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_delete_by_query/{task_id}/_rethrottle"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestsPerSecond == nil {
		return nil, reportError("requestsPerSecond is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "requests_per_second", r.requestsPerSecond, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIDeleteDistinguishedNamesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	clusterName string
}

func (r DefaultAPIDeleteDistinguishedNamesRequest) Execute() (*DeleteDistinguishedNamesResponseContent, *http.Response, error) {
	return r.ApiService.DeleteDistinguishedNamesExecute(r)
}

/*
DeleteDistinguishedNames Method for DeleteDistinguishedNames

Deletes all distinguished names in the specified cluster’s or node’s allow list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName
 @return DefaultAPIDeleteDistinguishedNamesRequest
*/
func (a *DefaultAPIService) DeleteDistinguishedNames(ctx context.Context, clusterName string) DefaultAPIDeleteDistinguishedNamesRequest {
	return DefaultAPIDeleteDistinguishedNamesRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return DeleteDistinguishedNamesResponseContent
func (a *DefaultAPIService) DeleteDistinguishedNamesExecute(r DefaultAPIDeleteDistinguishedNamesRequest) (*DeleteDistinguishedNamesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteDistinguishedNamesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteDistinguishedNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/nodesdn/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIDeletePitRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	deletePitBodyParams *DeletePitBodyParams
}

func (r DefaultAPIDeletePitRequest) DeletePitBodyParams(deletePitBodyParams DeletePitBodyParams) DefaultAPIDeletePitRequest {
	r.deletePitBodyParams = &deletePitBodyParams
	return r
}

func (r DefaultAPIDeletePitRequest) Execute() (*DeletePitResponseContent, *http.Response, error) {
	return r.ApiService.DeletePitExecute(r)
}

/*
DeletePit Method for DeletePit

Deletes one or more point in time searches based on the IDs passed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIDeletePitRequest
*/
func (a *DefaultAPIService) DeletePit(ctx context.Context) DefaultAPIDeletePitRequest {
	return DefaultAPIDeletePitRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeletePitResponseContent
func (a *DefaultAPIService) DeletePitExecute(r DefaultAPIDeletePitRequest) (*DeletePitResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeletePitResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeletePit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/point_in_time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deletePitBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIDeleteRoleRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
}

func (r DefaultAPIDeleteRoleRequest) Execute() (*DeleteRoleResponseContent, *http.Response, error) {
	return r.ApiService.DeleteRoleExecute(r)
}

/*
DeleteRole Method for DeleteRole

Delete the specified role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return DefaultAPIDeleteRoleRequest
*/
func (a *DefaultAPIService) DeleteRole(ctx context.Context, role string) DefaultAPIDeleteRoleRequest {
	return DefaultAPIDeleteRoleRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return DeleteRoleResponseContent
func (a *DefaultAPIService) DeleteRoleExecute(r DefaultAPIDeleteRoleRequest) (*DeleteRoleResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteRoleResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/roles/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIDeleteRoleMappingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
}

func (r DefaultAPIDeleteRoleMappingRequest) Execute() (*DeleteRoleMappingResponseContent, *http.Response, error) {
	return r.ApiService.DeleteRoleMappingExecute(r)
}

/*
DeleteRoleMapping Method for DeleteRoleMapping

Deletes the specified role mapping.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return DefaultAPIDeleteRoleMappingRequest
*/
func (a *DefaultAPIService) DeleteRoleMapping(ctx context.Context, role string) DefaultAPIDeleteRoleMappingRequest {
	return DefaultAPIDeleteRoleMappingRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return DeleteRoleMappingResponseContent
func (a *DefaultAPIService) DeleteRoleMappingExecute(r DefaultAPIDeleteRoleMappingRequest) (*DeleteRoleMappingResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteRoleMappingResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteRoleMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/rolesmapping/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIDeleteScriptRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout.
func (r DefaultAPIDeleteScriptRequest) Timeout(timeout string) DefaultAPIDeleteScriptRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIDeleteScriptRequest) MasterTimeout(masterTimeout string) DefaultAPIDeleteScriptRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIDeleteScriptRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIDeleteScriptRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIDeleteScriptRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteScriptExecute(r)
}

/*
DeleteScript Method for DeleteScript

Deletes a script.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Script ID.
 @return DefaultAPIDeleteScriptRequest
*/
func (a *DefaultAPIService) DeleteScript(ctx context.Context, id string) DefaultAPIDeleteScriptRequest {
	return DefaultAPIDeleteScriptRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DeleteScriptExecute(r DefaultAPIDeleteScriptRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteScript")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIDeleteTenantRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	tenant string
}

func (r DefaultAPIDeleteTenantRequest) Execute() (*DeleteTenantResponseContent, *http.Response, error) {
	return r.ApiService.DeleteTenantExecute(r)
}

/*
DeleteTenant Method for DeleteTenant

Delete the specified tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @return DefaultAPIDeleteTenantRequest
*/
func (a *DefaultAPIService) DeleteTenant(ctx context.Context, tenant string) DefaultAPIDeleteTenantRequest {
	return DefaultAPIDeleteTenantRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
	}
}

// Execute executes the request
//  @return DeleteTenantResponseContent
func (a *DefaultAPIService) DeleteTenantExecute(r DefaultAPIDeleteTenantRequest) (*DeleteTenantResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteTenantResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteTenant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/tenants/{tenant}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIDeleteUserRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	username string
}

func (r DefaultAPIDeleteUserRequest) Execute() (*DeleteUserResponseContent, *http.Response, error) {
	return r.ApiService.DeleteUserExecute(r)
}

/*
DeleteUser Method for DeleteUser

Delete the specified user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username
 @return DefaultAPIDeleteUserRequest
*/
func (a *DefaultAPIService) DeleteUser(ctx context.Context, username string) DefaultAPIDeleteUserRequest {
	return DefaultAPIDeleteUserRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return DeleteUserResponseContent
func (a *DefaultAPIService) DeleteUserExecute(r DefaultAPIDeleteUserRequest) (*DeleteUserResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteUserResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/internalusers/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterValueToString(r.username, "username")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIExistsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	storedFields *[]string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	version *int32
	versionType *VersionType
}

// Comma-separated list of stored fields to return.
func (r DefaultAPIExistsRequest) StoredFields(storedFields []string) DefaultAPIExistsRequest {
	r.storedFields = &storedFields
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPIExistsRequest) Preference(preference string) DefaultAPIExistsRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r DefaultAPIExistsRequest) Realtime(realtime bool) DefaultAPIExistsRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r DefaultAPIExistsRequest) Refresh(refresh bool) DefaultAPIExistsRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIExistsRequest) Routing(routing string) DefaultAPIExistsRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPIExistsRequest) Source(source []string) DefaultAPIExistsRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPIExistsRequest) SourceExcludes(sourceExcludes []string) DefaultAPIExistsRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPIExistsRequest) SourceIncludes(sourceIncludes []string) DefaultAPIExistsRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPIExistsRequest) Version(version int32) DefaultAPIExistsRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPIExistsRequest) VersionType(versionType VersionType) DefaultAPIExistsRequest {
	r.versionType = &versionType
	return r
}

func (r DefaultAPIExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExistsExecute(r)
}

/*
Exists Method for Exists

Returns information about whether a document exists in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return DefaultAPIExistsRequest
*/
func (a *DefaultAPIService) Exists(ctx context.Context, id string, index string) DefaultAPIExistsRequest {
	return DefaultAPIExistsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ExistsExecute(r DefaultAPIExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Exists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_doc/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIExistsSourceRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	version *int32
	versionType *VersionType
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPIExistsSourceRequest) Preference(preference string) DefaultAPIExistsSourceRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r DefaultAPIExistsSourceRequest) Realtime(realtime bool) DefaultAPIExistsSourceRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r DefaultAPIExistsSourceRequest) Refresh(refresh bool) DefaultAPIExistsSourceRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIExistsSourceRequest) Routing(routing string) DefaultAPIExistsSourceRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPIExistsSourceRequest) Source(source []string) DefaultAPIExistsSourceRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPIExistsSourceRequest) SourceExcludes(sourceExcludes []string) DefaultAPIExistsSourceRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPIExistsSourceRequest) SourceIncludes(sourceIncludes []string) DefaultAPIExistsSourceRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPIExistsSourceRequest) Version(version int32) DefaultAPIExistsSourceRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPIExistsSourceRequest) VersionType(versionType VersionType) DefaultAPIExistsSourceRequest {
	r.versionType = &versionType
	return r
}

func (r DefaultAPIExistsSourceRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExistsSourceExecute(r)
}

/*
ExistsSource Method for ExistsSource

Returns information about whether a document source exists in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return DefaultAPIExistsSourceRequest
*/
func (a *DefaultAPIService) ExistsSource(ctx context.Context, id string, index string) DefaultAPIExistsSourceRequest {
	return DefaultAPIExistsSourceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ExistsSourceExecute(r DefaultAPIExistsSourceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ExistsSource")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_source/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIExplainGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	analyzeWildcard *bool
	analyzer *string
	defaultOperator *DefaultOperator
	df *string
	storedFields *[]string
	lenient *bool
	preference *string
	q *string
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
}

// Specify whether wildcards and prefix queries in the query string query should be analyzed.
func (r DefaultAPIExplainGetRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPIExplainGetRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The analyzer to use for the query string.
func (r DefaultAPIExplainGetRequest) Analyzer(analyzer string) DefaultAPIExplainGetRequest {
	r.analyzer = &analyzer
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPIExplainGetRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPIExplainGetRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The default field for query string query.
func (r DefaultAPIExplainGetRequest) Df(df string) DefaultAPIExplainGetRequest {
	r.df = &df
	return r
}

// Comma-separated list of stored fields to return.
func (r DefaultAPIExplainGetRequest) StoredFields(storedFields []string) DefaultAPIExplainGetRequest {
	r.storedFields = &storedFields
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPIExplainGetRequest) Lenient(lenient bool) DefaultAPIExplainGetRequest {
	r.lenient = &lenient
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPIExplainGetRequest) Preference(preference string) DefaultAPIExplainGetRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPIExplainGetRequest) Q(q string) DefaultAPIExplainGetRequest {
	r.q = &q
	return r
}

// Routing value.
func (r DefaultAPIExplainGetRequest) Routing(routing string) DefaultAPIExplainGetRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPIExplainGetRequest) Source(source []string) DefaultAPIExplainGetRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPIExplainGetRequest) SourceExcludes(sourceExcludes []string) DefaultAPIExplainGetRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPIExplainGetRequest) SourceIncludes(sourceIncludes []string) DefaultAPIExplainGetRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

func (r DefaultAPIExplainGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExplainGetExecute(r)
}

/*
ExplainGet Method for ExplainGet

Returns information about why a specific matches (or doesn't match) a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return DefaultAPIExplainGetRequest
*/
func (a *DefaultAPIService) ExplainGet(ctx context.Context, id string, index string) DefaultAPIExplainGetRequest {
	return DefaultAPIExplainGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ExplainGetExecute(r DefaultAPIExplainGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ExplainGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_explain/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	} else {
		var defaultValue string = "_all"
		r.df = &defaultValue
	}
	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIExplainPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	analyzeWildcard *bool
	analyzer *string
	defaultOperator *DefaultOperator
	df *string
	storedFields *[]string
	lenient *bool
	preference *string
	q *string
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	body *map[string]interface{}
}

// Specify whether wildcards and prefix queries in the query string query should be analyzed.
func (r DefaultAPIExplainPostRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPIExplainPostRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The analyzer to use for the query string.
func (r DefaultAPIExplainPostRequest) Analyzer(analyzer string) DefaultAPIExplainPostRequest {
	r.analyzer = &analyzer
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPIExplainPostRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPIExplainPostRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The default field for query string query.
func (r DefaultAPIExplainPostRequest) Df(df string) DefaultAPIExplainPostRequest {
	r.df = &df
	return r
}

// Comma-separated list of stored fields to return.
func (r DefaultAPIExplainPostRequest) StoredFields(storedFields []string) DefaultAPIExplainPostRequest {
	r.storedFields = &storedFields
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPIExplainPostRequest) Lenient(lenient bool) DefaultAPIExplainPostRequest {
	r.lenient = &lenient
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPIExplainPostRequest) Preference(preference string) DefaultAPIExplainPostRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPIExplainPostRequest) Q(q string) DefaultAPIExplainPostRequest {
	r.q = &q
	return r
}

// Routing value.
func (r DefaultAPIExplainPostRequest) Routing(routing string) DefaultAPIExplainPostRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPIExplainPostRequest) Source(source []string) DefaultAPIExplainPostRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPIExplainPostRequest) SourceExcludes(sourceExcludes []string) DefaultAPIExplainPostRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPIExplainPostRequest) SourceIncludes(sourceIncludes []string) DefaultAPIExplainPostRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

func (r DefaultAPIExplainPostRequest) Body(body map[string]interface{}) DefaultAPIExplainPostRequest {
	r.body = &body
	return r
}

func (r DefaultAPIExplainPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExplainPostExecute(r)
}

/*
ExplainPost Method for ExplainPost

Returns information about why a specific matches (or doesn't match) a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return DefaultAPIExplainPostRequest
*/
func (a *DefaultAPIService) ExplainPost(ctx context.Context, id string, index string) DefaultAPIExplainPostRequest {
	return DefaultAPIExplainPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ExplainPostExecute(r DefaultAPIExplainPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ExplainPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_explain/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	} else {
		var defaultValue string = "_all"
		r.df = &defaultValue
	}
	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIFieldCapsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	fields *[]string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	includeUnmapped *bool
}

// Comma-separated list of field names.
func (r DefaultAPIFieldCapsGetRequest) Fields(fields []string) DefaultAPIFieldCapsGetRequest {
	r.fields = &fields
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIFieldCapsGetRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIFieldCapsGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIFieldCapsGetRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIFieldCapsGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIFieldCapsGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIFieldCapsGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Indicates whether unmapped fields should be included in the response.
func (r DefaultAPIFieldCapsGetRequest) IncludeUnmapped(includeUnmapped bool) DefaultAPIFieldCapsGetRequest {
	r.includeUnmapped = &includeUnmapped
	return r
}

func (r DefaultAPIFieldCapsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.FieldCapsGetExecute(r)
}

/*
FieldCapsGet Method for FieldCapsGet

Returns the information about the capabilities of fields among multiple indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIFieldCapsGetRequest
*/
func (a *DefaultAPIService) FieldCapsGet(ctx context.Context) DefaultAPIFieldCapsGetRequest {
	return DefaultAPIFieldCapsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) FieldCapsGetExecute(r DefaultAPIFieldCapsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.FieldCapsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_field_caps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.includeUnmapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unmapped", r.includeUnmapped, "")
	} else {
		var defaultValue bool = false
		r.includeUnmapped = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIFieldCapsGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	fields *[]string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	includeUnmapped *bool
}

// Comma-separated list of field names.
func (r DefaultAPIFieldCapsGetWithIndexRequest) Fields(fields []string) DefaultAPIFieldCapsGetWithIndexRequest {
	r.fields = &fields
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIFieldCapsGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIFieldCapsGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIFieldCapsGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIFieldCapsGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIFieldCapsGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIFieldCapsGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Indicates whether unmapped fields should be included in the response.
func (r DefaultAPIFieldCapsGetWithIndexRequest) IncludeUnmapped(includeUnmapped bool) DefaultAPIFieldCapsGetWithIndexRequest {
	r.includeUnmapped = &includeUnmapped
	return r
}

func (r DefaultAPIFieldCapsGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.FieldCapsGetWithIndexExecute(r)
}

/*
FieldCapsGetWithIndex Method for FieldCapsGetWithIndex

Returns the information about the capabilities of fields among multiple indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIFieldCapsGetWithIndexRequest
*/
func (a *DefaultAPIService) FieldCapsGetWithIndex(ctx context.Context, index string) DefaultAPIFieldCapsGetWithIndexRequest {
	return DefaultAPIFieldCapsGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) FieldCapsGetWithIndexExecute(r DefaultAPIFieldCapsGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.FieldCapsGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_field_caps"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.includeUnmapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unmapped", r.includeUnmapped, "")
	} else {
		var defaultValue bool = false
		r.includeUnmapped = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIFieldCapsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	fields *[]string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	includeUnmapped *bool
	body *map[string]interface{}
}

// Comma-separated list of field names.
func (r DefaultAPIFieldCapsPostRequest) Fields(fields []string) DefaultAPIFieldCapsPostRequest {
	r.fields = &fields
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIFieldCapsPostRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIFieldCapsPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIFieldCapsPostRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIFieldCapsPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIFieldCapsPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIFieldCapsPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Indicates whether unmapped fields should be included in the response.
func (r DefaultAPIFieldCapsPostRequest) IncludeUnmapped(includeUnmapped bool) DefaultAPIFieldCapsPostRequest {
	r.includeUnmapped = &includeUnmapped
	return r
}

func (r DefaultAPIFieldCapsPostRequest) Body(body map[string]interface{}) DefaultAPIFieldCapsPostRequest {
	r.body = &body
	return r
}

func (r DefaultAPIFieldCapsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FieldCapsPostExecute(r)
}

/*
FieldCapsPost Method for FieldCapsPost

Returns the information about the capabilities of fields among multiple indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIFieldCapsPostRequest
*/
func (a *DefaultAPIService) FieldCapsPost(ctx context.Context) DefaultAPIFieldCapsPostRequest {
	return DefaultAPIFieldCapsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) FieldCapsPostExecute(r DefaultAPIFieldCapsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.FieldCapsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_field_caps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.includeUnmapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unmapped", r.includeUnmapped, "")
	} else {
		var defaultValue bool = false
		r.includeUnmapped = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIFieldCapsPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	fields *[]string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	includeUnmapped *bool
	body *map[string]interface{}
}

// Comma-separated list of field names.
func (r DefaultAPIFieldCapsPostWithIndexRequest) Fields(fields []string) DefaultAPIFieldCapsPostWithIndexRequest {
	r.fields = &fields
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIFieldCapsPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIFieldCapsPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIFieldCapsPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIFieldCapsPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIFieldCapsPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIFieldCapsPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Indicates whether unmapped fields should be included in the response.
func (r DefaultAPIFieldCapsPostWithIndexRequest) IncludeUnmapped(includeUnmapped bool) DefaultAPIFieldCapsPostWithIndexRequest {
	r.includeUnmapped = &includeUnmapped
	return r
}

func (r DefaultAPIFieldCapsPostWithIndexRequest) Body(body map[string]interface{}) DefaultAPIFieldCapsPostWithIndexRequest {
	r.body = &body
	return r
}

func (r DefaultAPIFieldCapsPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.FieldCapsPostWithIndexExecute(r)
}

/*
FieldCapsPostWithIndex Method for FieldCapsPostWithIndex

Returns the information about the capabilities of fields among multiple indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIFieldCapsPostWithIndexRequest
*/
func (a *DefaultAPIService) FieldCapsPostWithIndex(ctx context.Context, index string) DefaultAPIFieldCapsPostWithIndexRequest {
	return DefaultAPIFieldCapsPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) FieldCapsPostWithIndexExecute(r DefaultAPIFieldCapsPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.FieldCapsPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_field_caps"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.includeUnmapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unmapped", r.includeUnmapped, "")
	} else {
		var defaultValue bool = false
		r.includeUnmapped = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIFlushCacheRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIFlushCacheRequest) Execute() (*FlushCacheResponseContent, *http.Response, error) {
	return r.ApiService.FlushCacheExecute(r)
}

/*
FlushCache Method for FlushCache

Flushes the Security plugin user, authentication, and authorization cache.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIFlushCacheRequest
*/
func (a *DefaultAPIService) FlushCache(ctx context.Context) DefaultAPIFlushCacheRequest {
	return DefaultAPIFlushCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlushCacheResponseContent
func (a *DefaultAPIService) FlushCacheExecute(r DefaultAPIFlushCacheRequest) (*FlushCacheResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlushCacheResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.FlushCache")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	storedFields *[]string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	version *int32
	versionType *VersionType
}

// Comma-separated list of stored fields to return.
func (r DefaultAPIGetRequest) StoredFields(storedFields []string) DefaultAPIGetRequest {
	r.storedFields = &storedFields
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPIGetRequest) Preference(preference string) DefaultAPIGetRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r DefaultAPIGetRequest) Realtime(realtime bool) DefaultAPIGetRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r DefaultAPIGetRequest) Refresh(refresh bool) DefaultAPIGetRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIGetRequest) Routing(routing string) DefaultAPIGetRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPIGetRequest) Source(source []string) DefaultAPIGetRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPIGetRequest) SourceExcludes(sourceExcludes []string) DefaultAPIGetRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPIGetRequest) SourceIncludes(sourceIncludes []string) DefaultAPIGetRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPIGetRequest) Version(version int32) DefaultAPIGetRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPIGetRequest) VersionType(versionType VersionType) DefaultAPIGetRequest {
	r.versionType = &versionType
	return r
}

func (r DefaultAPIGetRequest) Execute() (*GetResponseContent, *http.Response, error) {
	return r.ApiService.GetExecute(r)
}

/*
Get Method for Get

Returns a document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return DefaultAPIGetRequest
*/
func (a *DefaultAPIService) Get(ctx context.Context, id string, index string) DefaultAPIGetRequest {
	return DefaultAPIGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
//  @return GetResponseContent
func (a *DefaultAPIService) GetExecute(r DefaultAPIGetRequest) (*GetResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Get")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_doc/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetAccountDetailsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIGetAccountDetailsRequest) Execute() (*AccountDetails, *http.Response, error) {
	return r.ApiService.GetAccountDetailsExecute(r)
}

/*
GetAccountDetails Method for GetAccountDetails

Returns account details for the current user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetAccountDetailsRequest
*/
func (a *DefaultAPIService) GetAccountDetails(ctx context.Context) DefaultAPIGetAccountDetailsRequest {
	return DefaultAPIGetAccountDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountDetails
func (a *DefaultAPIService) GetAccountDetailsExecute(r DefaultAPIGetAccountDetailsRequest) (*AccountDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetAccountDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetActionGroupRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	actionGroup string
}

func (r DefaultAPIGetActionGroupRequest) Execute() (*map[string]ActionGroup, *http.Response, error) {
	return r.ApiService.GetActionGroupExecute(r)
}

/*
GetActionGroup Method for GetActionGroup

Retrieves one action group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionGroup Action group to retrieve.
 @return DefaultAPIGetActionGroupRequest
*/
func (a *DefaultAPIService) GetActionGroup(ctx context.Context, actionGroup string) DefaultAPIGetActionGroupRequest {
	return DefaultAPIGetActionGroupRequest{
		ApiService: a,
		ctx: ctx,
		actionGroup: actionGroup,
	}
}

// Execute executes the request
//  @return map[string]ActionGroup
func (a *DefaultAPIService) GetActionGroupExecute(r DefaultAPIGetActionGroupRequest) (*map[string]ActionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]ActionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetActionGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/actiongroups/{action_group}"
	localVarPath = strings.Replace(localVarPath, "{"+"action_group"+"}", url.PathEscape(parameterValueToString(r.actionGroup, "actionGroup")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetActionGroupsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIGetActionGroupsRequest) Execute() (*map[string]ActionGroup, *http.Response, error) {
	return r.ApiService.GetActionGroupsExecute(r)
}

/*
GetActionGroups Method for GetActionGroups

Retrieves all action groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetActionGroupsRequest
*/
func (a *DefaultAPIService) GetActionGroups(ctx context.Context) DefaultAPIGetActionGroupsRequest {
	return DefaultAPIGetActionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]ActionGroup
func (a *DefaultAPIService) GetActionGroupsExecute(r DefaultAPIGetActionGroupsRequest) (*map[string]ActionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]ActionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetActionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/actiongroups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetAllPitsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIGetAllPitsRequest) Execute() (*GetAllPitsResponseContent, *http.Response, error) {
	return r.ApiService.GetAllPitsExecute(r)
}

/*
GetAllPits Method for GetAllPits

Lists all active point in time searches.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetAllPitsRequest
*/
func (a *DefaultAPIService) GetAllPits(ctx context.Context) DefaultAPIGetAllPitsRequest {
	return DefaultAPIGetAllPitsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAllPitsResponseContent
func (a *DefaultAPIService) GetAllPitsExecute(r DefaultAPIGetAllPitsRequest) (*GetAllPitsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllPitsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetAllPits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/point_in_time/_all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetAuditConfigurationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIGetAuditConfigurationRequest) Execute() (*AuditConfigWithReadOnly, *http.Response, error) {
	return r.ApiService.GetAuditConfigurationExecute(r)
}

/*
GetAuditConfiguration Method for GetAuditConfiguration

Retrieves the audit configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetAuditConfigurationRequest
*/
func (a *DefaultAPIService) GetAuditConfiguration(ctx context.Context) DefaultAPIGetAuditConfigurationRequest {
	return DefaultAPIGetAuditConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuditConfigWithReadOnly
func (a *DefaultAPIService) GetAuditConfigurationExecute(r DefaultAPIGetAuditConfigurationRequest) (*AuditConfigWithReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuditConfigWithReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetAuditConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/audit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetCertificatesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIGetCertificatesRequest) Execute() (*GetCertificatesResponseContent, *http.Response, error) {
	return r.ApiService.GetCertificatesExecute(r)
}

/*
GetCertificates Method for GetCertificates

Retrieves the cluster’s security certificates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetCertificatesRequest
*/
func (a *DefaultAPIService) GetCertificates(ctx context.Context) DefaultAPIGetCertificatesRequest {
	return DefaultAPIGetCertificatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCertificatesResponseContent
func (a *DefaultAPIService) GetCertificatesExecute(r DefaultAPIGetCertificatesRequest) (*GetCertificatesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCertificatesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetCertificates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/ssl/certs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetConfigurationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIGetConfigurationRequest) Execute() (*DynamicConfig, *http.Response, error) {
	return r.ApiService.GetConfigurationExecute(r)
}

/*
GetConfiguration Method for GetConfiguration

Returns the current Security plugin configuration in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetConfigurationRequest
*/
func (a *DefaultAPIService) GetConfiguration(ctx context.Context) DefaultAPIGetConfigurationRequest {
	return DefaultAPIGetConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DynamicConfig
func (a *DefaultAPIService) GetConfigurationExecute(r DefaultAPIGetConfigurationRequest) (*DynamicConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DynamicConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/securityconfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetDistinguishedNamesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIGetDistinguishedNamesRequest) Execute() (*map[string]DistinguishedNames, *http.Response, error) {
	return r.ApiService.GetDistinguishedNamesExecute(r)
}

/*
GetDistinguishedNames Method for GetDistinguishedNames

Retrieves all distinguished names in the allow list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetDistinguishedNamesRequest
*/
func (a *DefaultAPIService) GetDistinguishedNames(ctx context.Context) DefaultAPIGetDistinguishedNamesRequest {
	return DefaultAPIGetDistinguishedNamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]DistinguishedNames
func (a *DefaultAPIService) GetDistinguishedNamesExecute(r DefaultAPIGetDistinguishedNamesRequest) (*map[string]DistinguishedNames, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]DistinguishedNames
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetDistinguishedNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/nodesdn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetDistinguishedNamesWithClusterNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	clusterName string
}

func (r DefaultAPIGetDistinguishedNamesWithClusterNameRequest) Execute() (*map[string]DistinguishedNames, *http.Response, error) {
	return r.ApiService.GetDistinguishedNamesWithClusterNameExecute(r)
}

/*
GetDistinguishedNamesWithClusterName Method for GetDistinguishedNamesWithClusterName

Retrieve distinguished names of a specified cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName
 @return DefaultAPIGetDistinguishedNamesWithClusterNameRequest
*/
func (a *DefaultAPIService) GetDistinguishedNamesWithClusterName(ctx context.Context, clusterName string) DefaultAPIGetDistinguishedNamesWithClusterNameRequest {
	return DefaultAPIGetDistinguishedNamesWithClusterNameRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return map[string]DistinguishedNames
func (a *DefaultAPIService) GetDistinguishedNamesWithClusterNameExecute(r DefaultAPIGetDistinguishedNamesWithClusterNameRequest) (*map[string]DistinguishedNames, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]DistinguishedNames
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetDistinguishedNamesWithClusterName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/nodesdn/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetRoleRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
}

func (r DefaultAPIGetRoleRequest) Execute() (*map[string]Role, *http.Response, error) {
	return r.ApiService.GetRoleExecute(r)
}

/*
GetRole Method for GetRole

Retrieves one role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return DefaultAPIGetRoleRequest
*/
func (a *DefaultAPIService) GetRole(ctx context.Context, role string) DefaultAPIGetRoleRequest {
	return DefaultAPIGetRoleRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return map[string]Role
func (a *DefaultAPIService) GetRoleExecute(r DefaultAPIGetRoleRequest) (*map[string]Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/roles/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetRoleMappingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
}

func (r DefaultAPIGetRoleMappingRequest) Execute() (*map[string]RoleMapping, *http.Response, error) {
	return r.ApiService.GetRoleMappingExecute(r)
}

/*
GetRoleMapping Method for GetRoleMapping

Retrieves one role mapping.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return DefaultAPIGetRoleMappingRequest
*/
func (a *DefaultAPIService) GetRoleMapping(ctx context.Context, role string) DefaultAPIGetRoleMappingRequest {
	return DefaultAPIGetRoleMappingRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return map[string]RoleMapping
func (a *DefaultAPIService) GetRoleMappingExecute(r DefaultAPIGetRoleMappingRequest) (*map[string]RoleMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]RoleMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRoleMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/rolesmapping/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetRoleMappingsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIGetRoleMappingsRequest) Execute() (*map[string]RoleMapping, *http.Response, error) {
	return r.ApiService.GetRoleMappingsExecute(r)
}

/*
GetRoleMappings Method for GetRoleMappings

Retrieves all role mappings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetRoleMappingsRequest
*/
func (a *DefaultAPIService) GetRoleMappings(ctx context.Context) DefaultAPIGetRoleMappingsRequest {
	return DefaultAPIGetRoleMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]RoleMapping
func (a *DefaultAPIService) GetRoleMappingsExecute(r DefaultAPIGetRoleMappingsRequest) (*map[string]RoleMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]RoleMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRoleMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/rolesmapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetRolesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIGetRolesRequest) Execute() (*map[string]Role, *http.Response, error) {
	return r.ApiService.GetRolesExecute(r)
}

/*
GetRoles Method for GetRoles

Retrieves all roles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetRolesRequest
*/
func (a *DefaultAPIService) GetRoles(ctx context.Context) DefaultAPIGetRolesRequest {
	return DefaultAPIGetRolesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]Role
func (a *DefaultAPIService) GetRolesExecute(r DefaultAPIGetRolesRequest) (*map[string]Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetScriptRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout for connection to master node.
func (r DefaultAPIGetScriptRequest) MasterTimeout(masterTimeout string) DefaultAPIGetScriptRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIGetScriptRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIGetScriptRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIGetScriptRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetScriptExecute(r)
}

/*
GetScript Method for GetScript

Returns a script.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Script ID.
 @return DefaultAPIGetScriptRequest
*/
func (a *DefaultAPIService) GetScript(ctx context.Context, id string) DefaultAPIGetScriptRequest {
	return DefaultAPIGetScriptRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) GetScriptExecute(r DefaultAPIGetScriptRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetScript")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIGetScriptContextRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIGetScriptContextRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetScriptContextExecute(r)
}

/*
GetScriptContext Method for GetScriptContext

Returns all script contexts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetScriptContextRequest
*/
func (a *DefaultAPIService) GetScriptContext(ctx context.Context) DefaultAPIGetScriptContextRequest {
	return DefaultAPIGetScriptContextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) GetScriptContextExecute(r DefaultAPIGetScriptContextRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetScriptContext")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_script_context"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIGetScriptLanguagesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIGetScriptLanguagesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetScriptLanguagesExecute(r)
}

/*
GetScriptLanguages Method for GetScriptLanguages

Returns available script types, languages and contexts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetScriptLanguagesRequest
*/
func (a *DefaultAPIService) GetScriptLanguages(ctx context.Context) DefaultAPIGetScriptLanguagesRequest {
	return DefaultAPIGetScriptLanguagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) GetScriptLanguagesExecute(r DefaultAPIGetScriptLanguagesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetScriptLanguages")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_script_language"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIGetSourceRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	version *int32
	versionType *VersionType
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPIGetSourceRequest) Preference(preference string) DefaultAPIGetSourceRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r DefaultAPIGetSourceRequest) Realtime(realtime bool) DefaultAPIGetSourceRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r DefaultAPIGetSourceRequest) Refresh(refresh bool) DefaultAPIGetSourceRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIGetSourceRequest) Routing(routing string) DefaultAPIGetSourceRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPIGetSourceRequest) Source(source []string) DefaultAPIGetSourceRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPIGetSourceRequest) SourceExcludes(sourceExcludes []string) DefaultAPIGetSourceRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPIGetSourceRequest) SourceIncludes(sourceIncludes []string) DefaultAPIGetSourceRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPIGetSourceRequest) Version(version int32) DefaultAPIGetSourceRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPIGetSourceRequest) VersionType(versionType VersionType) DefaultAPIGetSourceRequest {
	r.versionType = &versionType
	return r
}

func (r DefaultAPIGetSourceRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSourceExecute(r)
}

/*
GetSource Method for GetSource

Returns the source of a document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return DefaultAPIGetSourceRequest
*/
func (a *DefaultAPIService) GetSource(ctx context.Context, id string, index string) DefaultAPIGetSourceRequest {
	return DefaultAPIGetSourceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) GetSourceExecute(r DefaultAPIGetSourceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetSource")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_source/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIGetTenantRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	tenant string
}

func (r DefaultAPIGetTenantRequest) Execute() (*map[string]Tenant, *http.Response, error) {
	return r.ApiService.GetTenantExecute(r)
}

/*
GetTenant Method for GetTenant

Retrieves one tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @return DefaultAPIGetTenantRequest
*/
func (a *DefaultAPIService) GetTenant(ctx context.Context, tenant string) DefaultAPIGetTenantRequest {
	return DefaultAPIGetTenantRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
	}
}

// Execute executes the request
//  @return map[string]Tenant
func (a *DefaultAPIService) GetTenantExecute(r DefaultAPIGetTenantRequest) (*map[string]Tenant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]Tenant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetTenant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/tenants/{tenant}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetTenantsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIGetTenantsRequest) Execute() (*map[string]Tenant, *http.Response, error) {
	return r.ApiService.GetTenantsExecute(r)
}

/*
GetTenants Method for GetTenants

Retrieves all tenants.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetTenantsRequest
*/
func (a *DefaultAPIService) GetTenants(ctx context.Context) DefaultAPIGetTenantsRequest {
	return DefaultAPIGetTenantsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]Tenant
func (a *DefaultAPIService) GetTenantsExecute(r DefaultAPIGetTenantsRequest) (*map[string]Tenant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]Tenant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetTenants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/tenants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetUserRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	username string
}

func (r DefaultAPIGetUserRequest) Execute() (*map[string]User, *http.Response, error) {
	return r.ApiService.GetUserExecute(r)
}

/*
GetUser Method for GetUser

Retrieve one internal user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username
 @return DefaultAPIGetUserRequest
*/
func (a *DefaultAPIService) GetUser(ctx context.Context, username string) DefaultAPIGetUserRequest {
	return DefaultAPIGetUserRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return map[string]User
func (a *DefaultAPIService) GetUserExecute(r DefaultAPIGetUserRequest) (*map[string]User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/internalusers/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterValueToString(r.username, "username")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetUsersRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIGetUsersRequest) Execute() (*map[string]User, *http.Response, error) {
	return r.ApiService.GetUsersExecute(r)
}

/*
GetUsers Method for GetUsers

Retrieve all internal users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetUsersRequest
*/
func (a *DefaultAPIService) GetUsers(ctx context.Context) DefaultAPIGetUsersRequest {
	return DefaultAPIGetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]User
func (a *DefaultAPIService) GetUsersExecute(r DefaultAPIGetUsersRequest) (*map[string]User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/internalusers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIIndexPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	opType *OpType
	refresh *RefreshEnum
	routing *string
	timeout *string
	version *int32
	versionType *VersionType
	ifSeqNo *int32
	ifPrimaryTerm *int32
	pipeline *string
	requireAlias *bool
}

func (r DefaultAPIIndexPostRequest) Body(body map[string]interface{}) DefaultAPIIndexPostRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r DefaultAPIIndexPostRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIIndexPostRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Explicit operation type. Defaults to &#x60;index&#x60; for requests with an explicit document ID, and to &#x60;create&#x60;for requests without an explicit document ID.
func (r DefaultAPIIndexPostRequest) OpType(opType OpType) DefaultAPIIndexPostRequest {
	r.opType = &opType
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r DefaultAPIIndexPostRequest) Refresh(refresh RefreshEnum) DefaultAPIIndexPostRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIIndexPostRequest) Routing(routing string) DefaultAPIIndexPostRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r DefaultAPIIndexPostRequest) Timeout(timeout string) DefaultAPIIndexPostRequest {
	r.timeout = &timeout
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPIIndexPostRequest) Version(version int32) DefaultAPIIndexPostRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPIIndexPostRequest) VersionType(versionType VersionType) DefaultAPIIndexPostRequest {
	r.versionType = &versionType
	return r
}

// only perform the operation if the last operation that has changed the document has the specified sequence number.
func (r DefaultAPIIndexPostRequest) IfSeqNo(ifSeqNo int32) DefaultAPIIndexPostRequest {
	r.ifSeqNo = &ifSeqNo
	return r
}

// only perform the operation if the last operation that has changed the document has the specified primary term.
func (r DefaultAPIIndexPostRequest) IfPrimaryTerm(ifPrimaryTerm int32) DefaultAPIIndexPostRequest {
	r.ifPrimaryTerm = &ifPrimaryTerm
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r DefaultAPIIndexPostRequest) Pipeline(pipeline string) DefaultAPIIndexPostRequest {
	r.pipeline = &pipeline
	return r
}

// When true, requires destination to be an alias.
func (r DefaultAPIIndexPostRequest) RequireAlias(requireAlias bool) DefaultAPIIndexPostRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r DefaultAPIIndexPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndexPostExecute(r)
}

/*
IndexPost Method for IndexPost

Creates or updates a document in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Index name.
 @return DefaultAPIIndexPostRequest
*/
func (a *DefaultAPIService) IndexPost(ctx context.Context, index string) DefaultAPIIndexPostRequest {
	return DefaultAPIIndexPostRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndexPostExecute(r DefaultAPIIndexPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndexPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_doc"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.opType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "op_type", r.opType, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	if r.ifSeqNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_seq_no", r.ifSeqNo, "")
	}
	if r.ifPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_primary_term", r.ifPrimaryTerm, "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndexPostWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	opType *OpType
	refresh *RefreshEnum
	routing *string
	timeout *string
	version *int32
	versionType *VersionType
	ifSeqNo *int32
	ifPrimaryTerm *int32
	pipeline *string
	requireAlias *bool
}

func (r DefaultAPIIndexPostWithIdRequest) Body(body map[string]interface{}) DefaultAPIIndexPostWithIdRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r DefaultAPIIndexPostWithIdRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIIndexPostWithIdRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Explicit operation type. Defaults to &#x60;index&#x60; for requests with an explicit document ID, and to &#x60;create&#x60;for requests without an explicit document ID.
func (r DefaultAPIIndexPostWithIdRequest) OpType(opType OpType) DefaultAPIIndexPostWithIdRequest {
	r.opType = &opType
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r DefaultAPIIndexPostWithIdRequest) Refresh(refresh RefreshEnum) DefaultAPIIndexPostWithIdRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIIndexPostWithIdRequest) Routing(routing string) DefaultAPIIndexPostWithIdRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r DefaultAPIIndexPostWithIdRequest) Timeout(timeout string) DefaultAPIIndexPostWithIdRequest {
	r.timeout = &timeout
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPIIndexPostWithIdRequest) Version(version int32) DefaultAPIIndexPostWithIdRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPIIndexPostWithIdRequest) VersionType(versionType VersionType) DefaultAPIIndexPostWithIdRequest {
	r.versionType = &versionType
	return r
}

// only perform the operation if the last operation that has changed the document has the specified sequence number.
func (r DefaultAPIIndexPostWithIdRequest) IfSeqNo(ifSeqNo int32) DefaultAPIIndexPostWithIdRequest {
	r.ifSeqNo = &ifSeqNo
	return r
}

// only perform the operation if the last operation that has changed the document has the specified primary term.
func (r DefaultAPIIndexPostWithIdRequest) IfPrimaryTerm(ifPrimaryTerm int32) DefaultAPIIndexPostWithIdRequest {
	r.ifPrimaryTerm = &ifPrimaryTerm
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r DefaultAPIIndexPostWithIdRequest) Pipeline(pipeline string) DefaultAPIIndexPostWithIdRequest {
	r.pipeline = &pipeline
	return r
}

// When true, requires destination to be an alias.
func (r DefaultAPIIndexPostWithIdRequest) RequireAlias(requireAlias bool) DefaultAPIIndexPostWithIdRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r DefaultAPIIndexPostWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndexPostWithIdExecute(r)
}

/*
IndexPostWithId Method for IndexPostWithId

Creates or updates a document in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return DefaultAPIIndexPostWithIdRequest
*/
func (a *DefaultAPIService) IndexPostWithId(ctx context.Context, id string, index string) DefaultAPIIndexPostWithIdRequest {
	return DefaultAPIIndexPostWithIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndexPostWithIdExecute(r DefaultAPIIndexPostWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndexPostWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_doc/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.opType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "op_type", r.opType, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	if r.ifSeqNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_seq_no", r.ifSeqNo, "")
	}
	if r.ifPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_primary_term", r.ifPrimaryTerm, "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndexPutWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	opType *OpType
	refresh *RefreshEnum
	routing *string
	timeout *string
	version *int32
	versionType *VersionType
	ifSeqNo *int32
	ifPrimaryTerm *int32
	pipeline *string
	requireAlias *bool
}

func (r DefaultAPIIndexPutWithIdRequest) Body(body map[string]interface{}) DefaultAPIIndexPutWithIdRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r DefaultAPIIndexPutWithIdRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIIndexPutWithIdRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Explicit operation type. Defaults to &#x60;index&#x60; for requests with an explicit document ID, and to &#x60;create&#x60;for requests without an explicit document ID.
func (r DefaultAPIIndexPutWithIdRequest) OpType(opType OpType) DefaultAPIIndexPutWithIdRequest {
	r.opType = &opType
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r DefaultAPIIndexPutWithIdRequest) Refresh(refresh RefreshEnum) DefaultAPIIndexPutWithIdRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIIndexPutWithIdRequest) Routing(routing string) DefaultAPIIndexPutWithIdRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r DefaultAPIIndexPutWithIdRequest) Timeout(timeout string) DefaultAPIIndexPutWithIdRequest {
	r.timeout = &timeout
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPIIndexPutWithIdRequest) Version(version int32) DefaultAPIIndexPutWithIdRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPIIndexPutWithIdRequest) VersionType(versionType VersionType) DefaultAPIIndexPutWithIdRequest {
	r.versionType = &versionType
	return r
}

// only perform the operation if the last operation that has changed the document has the specified sequence number.
func (r DefaultAPIIndexPutWithIdRequest) IfSeqNo(ifSeqNo int32) DefaultAPIIndexPutWithIdRequest {
	r.ifSeqNo = &ifSeqNo
	return r
}

// only perform the operation if the last operation that has changed the document has the specified primary term.
func (r DefaultAPIIndexPutWithIdRequest) IfPrimaryTerm(ifPrimaryTerm int32) DefaultAPIIndexPutWithIdRequest {
	r.ifPrimaryTerm = &ifPrimaryTerm
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r DefaultAPIIndexPutWithIdRequest) Pipeline(pipeline string) DefaultAPIIndexPutWithIdRequest {
	r.pipeline = &pipeline
	return r
}

// When true, requires destination to be an alias.
func (r DefaultAPIIndexPutWithIdRequest) RequireAlias(requireAlias bool) DefaultAPIIndexPutWithIdRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r DefaultAPIIndexPutWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndexPutWithIdExecute(r)
}

/*
IndexPutWithId Method for IndexPutWithId

Creates or updates a document in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return DefaultAPIIndexPutWithIdRequest
*/
func (a *DefaultAPIService) IndexPutWithId(ctx context.Context, id string, index string) DefaultAPIIndexPutWithIdRequest {
	return DefaultAPIIndexPutWithIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndexPutWithIdExecute(r DefaultAPIIndexPutWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndexPutWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_doc/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.opType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "op_type", r.opType, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	if r.ifSeqNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_seq_no", r.ifSeqNo, "")
	}
	if r.ifPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_primary_term", r.ifPrimaryTerm, "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesAddBlockRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	block string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Operation timeout.
func (r DefaultAPIIndicesAddBlockRequest) Timeout(timeout string) DefaultAPIIndicesAddBlockRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesAddBlockRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesAddBlockRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesAddBlockRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesAddBlockRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesAddBlockRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesAddBlockRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesAddBlockRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesAddBlockRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesAddBlockRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesAddBlockRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesAddBlockRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesAddBlockExecute(r)
}

/*
IndicesAddBlock Method for IndicesAddBlock

Adds a block to an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to add a block to.
 @param block The block to add (one of read, write, read_only or metadata).
 @return DefaultAPIIndicesAddBlockRequest
*/
func (a *DefaultAPIService) IndicesAddBlock(ctx context.Context, index string, block string) DefaultAPIIndicesAddBlockRequest {
	return DefaultAPIIndicesAddBlockRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		block: block,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesAddBlockExecute(r DefaultAPIIndicesAddBlockRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesAddBlock")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_block/{block}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesAnalyzeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index *string
}

// The name of the index to scope the operation.
func (r DefaultAPIIndicesAnalyzeGetRequest) Index(index string) DefaultAPIIndicesAnalyzeGetRequest {
	r.index = &index
	return r
}

func (r DefaultAPIIndicesAnalyzeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesAnalyzeGetExecute(r)
}

/*
IndicesAnalyzeGet Method for IndicesAnalyzeGet

Performs the analysis process on a text and return the tokens breakdown of the text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesAnalyzeGetRequest
*/
func (a *DefaultAPIService) IndicesAnalyzeGet(ctx context.Context) DefaultAPIIndicesAnalyzeGetRequest {
	return DefaultAPIIndicesAnalyzeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesAnalyzeGetExecute(r DefaultAPIIndicesAnalyzeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesAnalyzeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_analyze"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesAnalyzeGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	index2 *string
}

// The name of the index to scope the operation.
func (r DefaultAPIIndicesAnalyzeGetWithIndexRequest) Index2(index2 string) DefaultAPIIndicesAnalyzeGetWithIndexRequest {
	r.index2 = &index2
	return r
}

func (r DefaultAPIIndicesAnalyzeGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesAnalyzeGetWithIndexExecute(r)
}

/*
IndicesAnalyzeGetWithIndex Method for IndicesAnalyzeGetWithIndex

Performs the analysis process on a text and return the tokens breakdown of the text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the index to scope the operation.
 @return DefaultAPIIndicesAnalyzeGetWithIndexRequest
*/
func (a *DefaultAPIService) IndicesAnalyzeGetWithIndex(ctx context.Context, index string) DefaultAPIIndicesAnalyzeGetWithIndexRequest {
	return DefaultAPIIndicesAnalyzeGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesAnalyzeGetWithIndexExecute(r DefaultAPIIndicesAnalyzeGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesAnalyzeGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_analyze"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index2, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesAnalyzePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index *string
	body *map[string]interface{}
}

// The name of the index to scope the operation.
func (r DefaultAPIIndicesAnalyzePostRequest) Index(index string) DefaultAPIIndicesAnalyzePostRequest {
	r.index = &index
	return r
}

func (r DefaultAPIIndicesAnalyzePostRequest) Body(body map[string]interface{}) DefaultAPIIndicesAnalyzePostRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesAnalyzePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesAnalyzePostExecute(r)
}

/*
IndicesAnalyzePost Method for IndicesAnalyzePost

Performs the analysis process on a text and return the tokens breakdown of the text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesAnalyzePostRequest
*/
func (a *DefaultAPIService) IndicesAnalyzePost(ctx context.Context) DefaultAPIIndicesAnalyzePostRequest {
	return DefaultAPIIndicesAnalyzePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesAnalyzePostExecute(r DefaultAPIIndicesAnalyzePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesAnalyzePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_analyze"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesAnalyzePostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	index2 *string
	body *map[string]interface{}
}

// The name of the index to scope the operation.
func (r DefaultAPIIndicesAnalyzePostWithIndexRequest) Index2(index2 string) DefaultAPIIndicesAnalyzePostWithIndexRequest {
	r.index2 = &index2
	return r
}

func (r DefaultAPIIndicesAnalyzePostWithIndexRequest) Body(body map[string]interface{}) DefaultAPIIndicesAnalyzePostWithIndexRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesAnalyzePostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesAnalyzePostWithIndexExecute(r)
}

/*
IndicesAnalyzePostWithIndex Method for IndicesAnalyzePostWithIndex

Performs the analysis process on a text and return the tokens breakdown of the text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the index to scope the operation.
 @return DefaultAPIIndicesAnalyzePostWithIndexRequest
*/
func (a *DefaultAPIService) IndicesAnalyzePostWithIndex(ctx context.Context, index string) DefaultAPIIndicesAnalyzePostWithIndexRequest {
	return DefaultAPIIndicesAnalyzePostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesAnalyzePostWithIndexExecute(r DefaultAPIIndicesAnalyzePostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesAnalyzePostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_analyze"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index2, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesClearCacheRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	fielddata *bool
	fields *[]string
	query *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	index *[]string
	request *bool
}

// Clear field data.
func (r DefaultAPIIndicesClearCacheRequest) Fielddata(fielddata bool) DefaultAPIIndicesClearCacheRequest {
	r.fielddata = &fielddata
	return r
}

// Comma-separated list of fields to clear when using the &#x60;fielddata&#x60; parameter (default: all).
func (r DefaultAPIIndicesClearCacheRequest) Fields(fields []string) DefaultAPIIndicesClearCacheRequest {
	r.fields = &fields
	return r
}

// Clear query caches.
func (r DefaultAPIIndicesClearCacheRequest) Query(query bool) DefaultAPIIndicesClearCacheRequest {
	r.query = &query
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesClearCacheRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesClearCacheRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesClearCacheRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesClearCacheRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesClearCacheRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesClearCacheRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Comma-separated list of indices; use &#x60;_all&#x60; or empty string to perform the operation on all indices.
func (r DefaultAPIIndicesClearCacheRequest) Index(index []string) DefaultAPIIndicesClearCacheRequest {
	r.index = &index
	return r
}

// Clear request cache.
func (r DefaultAPIIndicesClearCacheRequest) Request(request bool) DefaultAPIIndicesClearCacheRequest {
	r.request = &request
	return r
}

func (r DefaultAPIIndicesClearCacheRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesClearCacheExecute(r)
}

/*
IndicesClearCache Method for IndicesClearCache

Clears all or specific caches for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesClearCacheRequest
*/
func (a *DefaultAPIService) IndicesClearCache(ctx context.Context) DefaultAPIIndicesClearCacheRequest {
	return DefaultAPIIndicesClearCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesClearCacheExecute(r DefaultAPIIndicesClearCacheRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesClearCache")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cache/clear"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fielddata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata", r.fielddata, "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.index != nil {
		t := *r.index
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "index", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "index", t, "multi")
		}
	}
	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesClearCacheWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	fielddata *bool
	fields *[]string
	query *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	index2 *[]string
	request *bool
}

// Clear field data.
func (r DefaultAPIIndicesClearCacheWithIndexRequest) Fielddata(fielddata bool) DefaultAPIIndicesClearCacheWithIndexRequest {
	r.fielddata = &fielddata
	return r
}

// Comma-separated list of fields to clear when using the &#x60;fielddata&#x60; parameter (default: all).
func (r DefaultAPIIndicesClearCacheWithIndexRequest) Fields(fields []string) DefaultAPIIndicesClearCacheWithIndexRequest {
	r.fields = &fields
	return r
}

// Clear query caches.
func (r DefaultAPIIndicesClearCacheWithIndexRequest) Query(query bool) DefaultAPIIndicesClearCacheWithIndexRequest {
	r.query = &query
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesClearCacheWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesClearCacheWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesClearCacheWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesClearCacheWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesClearCacheWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesClearCacheWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Comma-separated list of indices; use &#x60;_all&#x60; or empty string to perform the operation on all indices.
func (r DefaultAPIIndicesClearCacheWithIndexRequest) Index2(index2 []string) DefaultAPIIndicesClearCacheWithIndexRequest {
	r.index2 = &index2
	return r
}

// Clear request cache.
func (r DefaultAPIIndicesClearCacheWithIndexRequest) Request(request bool) DefaultAPIIndicesClearCacheWithIndexRequest {
	r.request = &request
	return r
}

func (r DefaultAPIIndicesClearCacheWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesClearCacheWithIndexExecute(r)
}

/*
IndicesClearCacheWithIndex Method for IndicesClearCacheWithIndex

Clears all or specific caches for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesClearCacheWithIndexRequest
*/
func (a *DefaultAPIService) IndicesClearCacheWithIndex(ctx context.Context, index string) DefaultAPIIndicesClearCacheWithIndexRequest {
	return DefaultAPIIndicesClearCacheWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesClearCacheWithIndexExecute(r DefaultAPIIndicesClearCacheWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesClearCacheWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_cache/clear"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fielddata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata", r.fielddata, "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.index2 != nil {
		t := *r.index2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "index", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "index", t, "multi")
		}
	}
	if r.request != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request", r.request, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesClonePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	target string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// Operation timeout.
func (r DefaultAPIIndicesClonePostRequest) Timeout(timeout string) DefaultAPIIndicesClonePostRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesClonePostRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesClonePostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesClonePostRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesClonePostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the cloned index before the operation returns.
func (r DefaultAPIIndicesClonePostRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIIndicesClonePostRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r DefaultAPIIndicesClonePostRequest) Body(body map[string]interface{}) DefaultAPIIndicesClonePostRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesClonePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesClonePostExecute(r)
}

/*
IndicesClonePost Method for IndicesClonePost

Clones an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the source index to clone.
 @param target The name of the target index.
 @return DefaultAPIIndicesClonePostRequest
*/
func (a *DefaultAPIService) IndicesClonePost(ctx context.Context, index string, target string) DefaultAPIIndicesClonePostRequest {
	return DefaultAPIIndicesClonePostRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		target: target,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesClonePostExecute(r DefaultAPIIndicesClonePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesClonePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_clone/{target}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", url.PathEscape(parameterValueToString(r.target, "target")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesClonePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	target string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// Operation timeout.
func (r DefaultAPIIndicesClonePutRequest) Timeout(timeout string) DefaultAPIIndicesClonePutRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesClonePutRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesClonePutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesClonePutRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesClonePutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the cloned index before the operation returns.
func (r DefaultAPIIndicesClonePutRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIIndicesClonePutRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r DefaultAPIIndicesClonePutRequest) Body(body map[string]interface{}) DefaultAPIIndicesClonePutRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesClonePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesClonePutExecute(r)
}

/*
IndicesClonePut Method for IndicesClonePut

Clones an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the source index to clone.
 @param target The name of the target index.
 @return DefaultAPIIndicesClonePutRequest
*/
func (a *DefaultAPIService) IndicesClonePut(ctx context.Context, index string, target string) DefaultAPIIndicesClonePutRequest {
	return DefaultAPIIndicesClonePutRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		target: target,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesClonePutExecute(r DefaultAPIIndicesClonePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesClonePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_clone/{target}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", url.PathEscape(parameterValueToString(r.target, "target")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesCloseRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	waitForActiveShards *string
}

// Operation timeout.
func (r DefaultAPIIndicesCloseRequest) Timeout(timeout string) DefaultAPIIndicesCloseRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesCloseRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesCloseRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesCloseRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesCloseRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesCloseRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesCloseRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesCloseRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesCloseRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesCloseRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesCloseRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Sets the number of active shards to wait for before the operation returns.
func (r DefaultAPIIndicesCloseRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIIndicesCloseRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r DefaultAPIIndicesCloseRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesCloseExecute(r)
}

/*
IndicesClose Method for IndicesClose

Closes an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to close.
 @return DefaultAPIIndicesCloseRequest
*/
func (a *DefaultAPIService) IndicesClose(ctx context.Context, index string) DefaultAPIIndicesCloseRequest {
	return DefaultAPIIndicesCloseRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesCloseExecute(r DefaultAPIIndicesCloseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesClose")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_close"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesCreateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	waitForActiveShards *string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	indicesCreateBodyParams *IndicesCreateBodyParams
}

// Set the number of active shards to wait for before the operation returns.
func (r DefaultAPIIndicesCreateRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIIndicesCreateRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Operation timeout.
func (r DefaultAPIIndicesCreateRequest) Timeout(timeout string) DefaultAPIIndicesCreateRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesCreateRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesCreateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesCreateRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesCreateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesCreateRequest) IndicesCreateBodyParams(indicesCreateBodyParams IndicesCreateBodyParams) DefaultAPIIndicesCreateRequest {
	r.indicesCreateBodyParams = &indicesCreateBodyParams
	return r
}

func (r DefaultAPIIndicesCreateRequest) Execute() (*IndicesCreateResponseContent, *http.Response, error) {
	return r.ApiService.IndicesCreateExecute(r)
}

/*
IndicesCreate Method for IndicesCreate

Creates an index with optional settings and mappings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Index name.
 @return DefaultAPIIndicesCreateRequest
*/
func (a *DefaultAPIService) IndicesCreate(ctx context.Context, index string) DefaultAPIIndicesCreateRequest {
	return DefaultAPIIndicesCreateRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
//  @return IndicesCreateResponseContent
func (a *DefaultAPIService) IndicesCreateExecute(r DefaultAPIIndicesCreateRequest) (*IndicesCreateResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesCreateResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.indicesCreateBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIIndicesCreateDataStreamRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	body *map[string]interface{}
}

func (r DefaultAPIIndicesCreateDataStreamRequest) Body(body map[string]interface{}) DefaultAPIIndicesCreateDataStreamRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesCreateDataStreamRequest) Execute() (*IndicesCreateDataStreamResponseContent, *http.Response, error) {
	return r.ApiService.IndicesCreateDataStreamExecute(r)
}

/*
IndicesCreateDataStream Method for IndicesCreateDataStream

Creates or updates a data stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the data stream.
 @return DefaultAPIIndicesCreateDataStreamRequest
*/
func (a *DefaultAPIService) IndicesCreateDataStream(ctx context.Context, name string) DefaultAPIIndicesCreateDataStreamRequest {
	return DefaultAPIIndicesCreateDataStreamRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return IndicesCreateDataStreamResponseContent
func (a *DefaultAPIService) IndicesCreateDataStreamExecute(r DefaultAPIIndicesCreateDataStreamRequest) (*IndicesCreateDataStreamResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesCreateDataStreamResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesCreateDataStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_data_stream/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIIndicesDataStreamsStatsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIIndicesDataStreamsStatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesDataStreamsStatsExecute(r)
}

/*
IndicesDataStreamsStats Method for IndicesDataStreamsStats

Provides statistics on operations happening in a data stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesDataStreamsStatsRequest
*/
func (a *DefaultAPIService) IndicesDataStreamsStats(ctx context.Context) DefaultAPIIndicesDataStreamsStatsRequest {
	return DefaultAPIIndicesDataStreamsStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesDataStreamsStatsExecute(r DefaultAPIIndicesDataStreamsStatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDataStreamsStats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_data_stream/_stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesDataStreamsStatsWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
}

func (r DefaultAPIIndicesDataStreamsStatsWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesDataStreamsStatsWithNameExecute(r)
}

/*
IndicesDataStreamsStatsWithName Method for IndicesDataStreamsStatsWithName

Provides statistics on operations happening in a data stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of data streams; use `_all` or empty string to perform the operation on all data streams.
 @return DefaultAPIIndicesDataStreamsStatsWithNameRequest
*/
func (a *DefaultAPIService) IndicesDataStreamsStatsWithName(ctx context.Context, name string) DefaultAPIIndicesDataStreamsStatsWithNameRequest {
	return DefaultAPIIndicesDataStreamsStatsWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesDataStreamsStatsWithNameExecute(r DefaultAPIIndicesDataStreamsStatsWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDataStreamsStatsWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_data_stream/{name}/_stats"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	timeout *string
	masterTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Operation timeout.
func (r DefaultAPIIndicesDeleteRequest) Timeout(timeout string) DefaultAPIIndicesDeleteRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesDeleteRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesDeleteRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesDeleteRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesDeleteRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesDeleteRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesDeleteRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesDeleteRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesDeleteRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesDeleteRequest) Execute() (*IndicesDeleteResponseContent, *http.Response, error) {
	return r.ApiService.IndicesDeleteExecute(r)
}

/*
IndicesDelete Method for IndicesDelete

Deletes an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to delete; use `_all` or `*` string to delete all indices.
 @return DefaultAPIIndicesDeleteRequest
*/
func (a *DefaultAPIService) IndicesDelete(ctx context.Context, index string) DefaultAPIIndicesDeleteRequest {
	return DefaultAPIIndicesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
//  @return IndicesDeleteResponseContent
func (a *DefaultAPIService) IndicesDeleteExecute(r DefaultAPIIndicesDeleteRequest) (*IndicesDeleteResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesDeleteResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	} else {
		var defaultValue bool = false
		r.allowNoIndices = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIIndicesDeleteAliasRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout.
func (r DefaultAPIIndicesDeleteAliasRequest) Timeout(timeout string) DefaultAPIIndicesDeleteAliasRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesDeleteAliasRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesDeleteAliasRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesDeleteAliasRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesDeleteAliasRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesDeleteAliasRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesDeleteAliasExecute(r)
}

/*
IndicesDeleteAlias Method for IndicesDeleteAlias

Deletes an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param name Comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
 @return DefaultAPIIndicesDeleteAliasRequest
*/
func (a *DefaultAPIService) IndicesDeleteAlias(ctx context.Context, index string, name string) DefaultAPIIndicesDeleteAliasRequest {
	return DefaultAPIIndicesDeleteAliasRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesDeleteAliasExecute(r DefaultAPIIndicesDeleteAliasRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDeleteAlias")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_alias/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesDeleteAliasPluralRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout.
func (r DefaultAPIIndicesDeleteAliasPluralRequest) Timeout(timeout string) DefaultAPIIndicesDeleteAliasPluralRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesDeleteAliasPluralRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesDeleteAliasPluralRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesDeleteAliasPluralRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesDeleteAliasPluralRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesDeleteAliasPluralRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesDeleteAliasPluralExecute(r)
}

/*
IndicesDeleteAliasPlural Method for IndicesDeleteAliasPlural

Deletes an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param name Comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
 @return DefaultAPIIndicesDeleteAliasPluralRequest
*/
func (a *DefaultAPIService) IndicesDeleteAliasPlural(ctx context.Context, index string, name string) DefaultAPIIndicesDeleteAliasPluralRequest {
	return DefaultAPIIndicesDeleteAliasPluralRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesDeleteAliasPluralExecute(r DefaultAPIIndicesDeleteAliasPluralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDeleteAliasPlural")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_aliases/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesDeleteDataStreamRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
}

func (r DefaultAPIIndicesDeleteDataStreamRequest) Execute() (*IndicesDeleteDataStreamResponseContent, *http.Response, error) {
	return r.ApiService.IndicesDeleteDataStreamExecute(r)
}

/*
IndicesDeleteDataStream Method for IndicesDeleteDataStream

Deletes a data stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of data streams; use `_all` or empty string to perform the operation on all data streams.
 @return DefaultAPIIndicesDeleteDataStreamRequest
*/
func (a *DefaultAPIService) IndicesDeleteDataStream(ctx context.Context, name string) DefaultAPIIndicesDeleteDataStreamRequest {
	return DefaultAPIIndicesDeleteDataStreamRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return IndicesDeleteDataStreamResponseContent
func (a *DefaultAPIService) IndicesDeleteDataStreamExecute(r DefaultAPIIndicesDeleteDataStreamRequest) (*IndicesDeleteDataStreamResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesDeleteDataStreamResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDeleteDataStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_data_stream/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIIndicesDeleteIndexTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout.
func (r DefaultAPIIndicesDeleteIndexTemplateRequest) Timeout(timeout string) DefaultAPIIndicesDeleteIndexTemplateRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesDeleteIndexTemplateRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesDeleteIndexTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesDeleteIndexTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesDeleteIndexTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesDeleteIndexTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesDeleteIndexTemplateExecute(r)
}

/*
IndicesDeleteIndexTemplate Method for IndicesDeleteIndexTemplate

Deletes an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return DefaultAPIIndicesDeleteIndexTemplateRequest
*/
func (a *DefaultAPIService) IndicesDeleteIndexTemplate(ctx context.Context, name string) DefaultAPIIndicesDeleteIndexTemplateRequest {
	return DefaultAPIIndicesDeleteIndexTemplateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesDeleteIndexTemplateExecute(r DefaultAPIIndicesDeleteIndexTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDeleteIndexTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesDeleteTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout.
func (r DefaultAPIIndicesDeleteTemplateRequest) Timeout(timeout string) DefaultAPIIndicesDeleteTemplateRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesDeleteTemplateRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesDeleteTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesDeleteTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesDeleteTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesDeleteTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesDeleteTemplateExecute(r)
}

/*
IndicesDeleteTemplate Method for IndicesDeleteTemplate

Deletes an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return DefaultAPIIndicesDeleteTemplateRequest
*/
func (a *DefaultAPIService) IndicesDeleteTemplate(ctx context.Context, name string) DefaultAPIIndicesDeleteTemplateRequest {
	return DefaultAPIIndicesDeleteTemplateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesDeleteTemplateExecute(r DefaultAPIIndicesDeleteTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesDeleteTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesExistsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	local *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
	includeDefaults *bool
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesExistsRequest) Local(local bool) DefaultAPIIndicesExistsRequest {
	r.local = &local
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesExistsRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesExistsRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesExistsRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesExistsRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesExistsRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesExistsRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r DefaultAPIIndicesExistsRequest) FlatSettings(flatSettings bool) DefaultAPIIndicesExistsRequest {
	r.flatSettings = &flatSettings
	return r
}

// Whether to return all default setting for each of the indices.
func (r DefaultAPIIndicesExistsRequest) IncludeDefaults(includeDefaults bool) DefaultAPIIndicesExistsRequest {
	r.includeDefaults = &includeDefaults
	return r
}

func (r DefaultAPIIndicesExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesExistsExecute(r)
}

/*
IndicesExists Method for IndicesExists

Returns information about whether a particular index exists.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices.
 @return DefaultAPIIndicesExistsRequest
*/
func (a *DefaultAPIService) IndicesExists(ctx context.Context, index string) DefaultAPIIndicesExistsRequest {
	return DefaultAPIIndicesExistsRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesExistsExecute(r DefaultAPIIndicesExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	} else {
		var defaultValue bool = false
		r.allowNoIndices = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	} else {
		var defaultValue bool = false
		r.includeDefaults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesExistsAliasRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesExistsAliasRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesExistsAliasRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesExistsAliasRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesExistsAliasRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesExistsAliasRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesExistsAliasRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesExistsAliasRequest) Local(local bool) DefaultAPIIndicesExistsAliasRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesExistsAliasRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesExistsAliasExecute(r)
}

/*
IndicesExistsAlias Method for IndicesExistsAlias

Returns information about whether a particular alias exists.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of alias names.
 @return DefaultAPIIndicesExistsAliasRequest
*/
func (a *DefaultAPIService) IndicesExistsAlias(ctx context.Context, name string) DefaultAPIIndicesExistsAliasRequest {
	return DefaultAPIIndicesExistsAliasRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesExistsAliasExecute(r DefaultAPIIndicesExistsAliasRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesExistsAlias")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_alias/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesExistsAliasWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesExistsAliasWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesExistsAliasWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesExistsAliasWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesExistsAliasWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesExistsAliasWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesExistsAliasWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesExistsAliasWithIndexRequest) Local(local bool) DefaultAPIIndicesExistsAliasWithIndexRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesExistsAliasWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesExistsAliasWithIndexExecute(r)
}

/*
IndicesExistsAliasWithIndex Method for IndicesExistsAliasWithIndex

Returns information about whether a particular alias exists.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to filter aliases.
 @param name Comma-separated list of alias names.
 @return DefaultAPIIndicesExistsAliasWithIndexRequest
*/
func (a *DefaultAPIService) IndicesExistsAliasWithIndex(ctx context.Context, index string, name string) DefaultAPIIndicesExistsAliasWithIndexRequest {
	return DefaultAPIIndicesExistsAliasWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesExistsAliasWithIndexExecute(r DefaultAPIIndicesExistsAliasWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesExistsAliasWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_alias/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesExistsIndexTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	flatSettings *bool
	masterTimeout *string
	local *bool
}

// Return settings in flat format.
func (r DefaultAPIIndicesExistsIndexTemplateRequest) FlatSettings(flatSettings bool) DefaultAPIIndicesExistsIndexTemplateRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesExistsIndexTemplateRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesExistsIndexTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesExistsIndexTemplateRequest) Local(local bool) DefaultAPIIndicesExistsIndexTemplateRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesExistsIndexTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesExistsIndexTemplateExecute(r)
}

/*
IndicesExistsIndexTemplate Method for IndicesExistsIndexTemplate

Returns information about whether a particular index template exists.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return DefaultAPIIndicesExistsIndexTemplateRequest
*/
func (a *DefaultAPIService) IndicesExistsIndexTemplate(ctx context.Context, name string) DefaultAPIIndicesExistsIndexTemplateRequest {
	return DefaultAPIIndicesExistsIndexTemplateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesExistsIndexTemplateExecute(r DefaultAPIIndicesExistsIndexTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesExistsIndexTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesExistsTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	flatSettings *bool
	masterTimeout *string
	local *bool
}

// Return settings in flat format.
func (r DefaultAPIIndicesExistsTemplateRequest) FlatSettings(flatSettings bool) DefaultAPIIndicesExistsTemplateRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesExistsTemplateRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesExistsTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesExistsTemplateRequest) Local(local bool) DefaultAPIIndicesExistsTemplateRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesExistsTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesExistsTemplateExecute(r)
}

/*
IndicesExistsTemplate Method for IndicesExistsTemplate

Returns information about whether a particular index template exists.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated names of the index templates.
 @return DefaultAPIIndicesExistsTemplateRequest
*/
func (a *DefaultAPIService) IndicesExistsTemplate(ctx context.Context, name string) DefaultAPIIndicesExistsTemplateRequest {
	return DefaultAPIIndicesExistsTemplateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesExistsTemplateExecute(r DefaultAPIIndicesExistsTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesExistsTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesFlushGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	force *bool
	waitIfOngoing *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
func (r DefaultAPIIndicesFlushGetRequest) Force(force bool) DefaultAPIIndicesFlushGetRequest {
	r.force = &force
	return r
}

// If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
func (r DefaultAPIIndicesFlushGetRequest) WaitIfOngoing(waitIfOngoing bool) DefaultAPIIndicesFlushGetRequest {
	r.waitIfOngoing = &waitIfOngoing
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesFlushGetRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesFlushGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesFlushGetRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesFlushGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesFlushGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesFlushGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesFlushGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesFlushGetExecute(r)
}

/*
IndicesFlushGet Method for IndicesFlushGet

Performs the flush operation on one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesFlushGetRequest
*/
func (a *DefaultAPIService) IndicesFlushGet(ctx context.Context) DefaultAPIIndicesFlushGetRequest {
	return DefaultAPIIndicesFlushGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesFlushGetExecute(r DefaultAPIIndicesFlushGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesFlushGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_flush"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.waitIfOngoing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_if_ongoing", r.waitIfOngoing, "")
	} else {
		var defaultValue bool = true
		r.waitIfOngoing = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesFlushGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	force *bool
	waitIfOngoing *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
func (r DefaultAPIIndicesFlushGetWithIndexRequest) Force(force bool) DefaultAPIIndicesFlushGetWithIndexRequest {
	r.force = &force
	return r
}

// If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
func (r DefaultAPIIndicesFlushGetWithIndexRequest) WaitIfOngoing(waitIfOngoing bool) DefaultAPIIndicesFlushGetWithIndexRequest {
	r.waitIfOngoing = &waitIfOngoing
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesFlushGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesFlushGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesFlushGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesFlushGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesFlushGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesFlushGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesFlushGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesFlushGetWithIndexExecute(r)
}

/*
IndicesFlushGetWithIndex Method for IndicesFlushGetWithIndex

Performs the flush operation on one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesFlushGetWithIndexRequest
*/
func (a *DefaultAPIService) IndicesFlushGetWithIndex(ctx context.Context, index string) DefaultAPIIndicesFlushGetWithIndexRequest {
	return DefaultAPIIndicesFlushGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesFlushGetWithIndexExecute(r DefaultAPIIndicesFlushGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesFlushGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_flush"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.waitIfOngoing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_if_ongoing", r.waitIfOngoing, "")
	} else {
		var defaultValue bool = true
		r.waitIfOngoing = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesFlushPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	force *bool
	waitIfOngoing *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
func (r DefaultAPIIndicesFlushPostRequest) Force(force bool) DefaultAPIIndicesFlushPostRequest {
	r.force = &force
	return r
}

// If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
func (r DefaultAPIIndicesFlushPostRequest) WaitIfOngoing(waitIfOngoing bool) DefaultAPIIndicesFlushPostRequest {
	r.waitIfOngoing = &waitIfOngoing
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesFlushPostRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesFlushPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesFlushPostRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesFlushPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesFlushPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesFlushPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesFlushPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesFlushPostExecute(r)
}

/*
IndicesFlushPost Method for IndicesFlushPost

Performs the flush operation on one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesFlushPostRequest
*/
func (a *DefaultAPIService) IndicesFlushPost(ctx context.Context) DefaultAPIIndicesFlushPostRequest {
	return DefaultAPIIndicesFlushPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesFlushPostExecute(r DefaultAPIIndicesFlushPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesFlushPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_flush"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.waitIfOngoing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_if_ongoing", r.waitIfOngoing, "")
	} else {
		var defaultValue bool = true
		r.waitIfOngoing = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesFlushPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	force *bool
	waitIfOngoing *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
func (r DefaultAPIIndicesFlushPostWithIndexRequest) Force(force bool) DefaultAPIIndicesFlushPostWithIndexRequest {
	r.force = &force
	return r
}

// If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
func (r DefaultAPIIndicesFlushPostWithIndexRequest) WaitIfOngoing(waitIfOngoing bool) DefaultAPIIndicesFlushPostWithIndexRequest {
	r.waitIfOngoing = &waitIfOngoing
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesFlushPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesFlushPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesFlushPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesFlushPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesFlushPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesFlushPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesFlushPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesFlushPostWithIndexExecute(r)
}

/*
IndicesFlushPostWithIndex Method for IndicesFlushPostWithIndex

Performs the flush operation on one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesFlushPostWithIndexRequest
*/
func (a *DefaultAPIService) IndicesFlushPostWithIndex(ctx context.Context, index string) DefaultAPIIndicesFlushPostWithIndexRequest {
	return DefaultAPIIndicesFlushPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesFlushPostWithIndexExecute(r DefaultAPIIndicesFlushPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesFlushPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_flush"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.waitIfOngoing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_if_ongoing", r.waitIfOngoing, "")
	} else {
		var defaultValue bool = true
		r.waitIfOngoing = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesForcemergeRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	flush *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	maxNumSegments *int32
	onlyExpungeDeletes *bool
}

// Specify whether the index should be flushed after performing the operation.
func (r DefaultAPIIndicesForcemergeRequest) Flush(flush bool) DefaultAPIIndicesForcemergeRequest {
	r.flush = &flush
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesForcemergeRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesForcemergeRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesForcemergeRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesForcemergeRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesForcemergeRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesForcemergeRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// The number of segments the index should be merged into (default: dynamic).
func (r DefaultAPIIndicesForcemergeRequest) MaxNumSegments(maxNumSegments int32) DefaultAPIIndicesForcemergeRequest {
	r.maxNumSegments = &maxNumSegments
	return r
}

// Specify whether the operation should only expunge deleted documents.
func (r DefaultAPIIndicesForcemergeRequest) OnlyExpungeDeletes(onlyExpungeDeletes bool) DefaultAPIIndicesForcemergeRequest {
	r.onlyExpungeDeletes = &onlyExpungeDeletes
	return r
}

func (r DefaultAPIIndicesForcemergeRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesForcemergeExecute(r)
}

/*
IndicesForcemerge Method for IndicesForcemerge

Performs the force merge operation on one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesForcemergeRequest
*/
func (a *DefaultAPIService) IndicesForcemerge(ctx context.Context) DefaultAPIIndicesForcemergeRequest {
	return DefaultAPIIndicesForcemergeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesForcemergeExecute(r DefaultAPIIndicesForcemergeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesForcemerge")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_forcemerge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flush != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flush", r.flush, "")
	} else {
		var defaultValue bool = true
		r.flush = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.maxNumSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_num_segments", r.maxNumSegments, "")
	}
	if r.onlyExpungeDeletes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_expunge_deletes", r.onlyExpungeDeletes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesForcemergeWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	flush *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	maxNumSegments *int32
	onlyExpungeDeletes *bool
}

// Specify whether the index should be flushed after performing the operation.
func (r DefaultAPIIndicesForcemergeWithIndexRequest) Flush(flush bool) DefaultAPIIndicesForcemergeWithIndexRequest {
	r.flush = &flush
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesForcemergeWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesForcemergeWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesForcemergeWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesForcemergeWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesForcemergeWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesForcemergeWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// The number of segments the index should be merged into (default: dynamic).
func (r DefaultAPIIndicesForcemergeWithIndexRequest) MaxNumSegments(maxNumSegments int32) DefaultAPIIndicesForcemergeWithIndexRequest {
	r.maxNumSegments = &maxNumSegments
	return r
}

// Specify whether the operation should only expunge deleted documents.
func (r DefaultAPIIndicesForcemergeWithIndexRequest) OnlyExpungeDeletes(onlyExpungeDeletes bool) DefaultAPIIndicesForcemergeWithIndexRequest {
	r.onlyExpungeDeletes = &onlyExpungeDeletes
	return r
}

func (r DefaultAPIIndicesForcemergeWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesForcemergeWithIndexExecute(r)
}

/*
IndicesForcemergeWithIndex Method for IndicesForcemergeWithIndex

Performs the force merge operation on one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesForcemergeWithIndexRequest
*/
func (a *DefaultAPIService) IndicesForcemergeWithIndex(ctx context.Context, index string) DefaultAPIIndicesForcemergeWithIndexRequest {
	return DefaultAPIIndicesForcemergeWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesForcemergeWithIndexExecute(r DefaultAPIIndicesForcemergeWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesForcemergeWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_forcemerge"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flush != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flush", r.flush, "")
	} else {
		var defaultValue bool = true
		r.flush = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.maxNumSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_num_segments", r.maxNumSegments, "")
	}
	if r.onlyExpungeDeletes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_expunge_deletes", r.onlyExpungeDeletes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	local *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
	includeDefaults *bool
	masterTimeout *string
	clusterManagerTimeout *string
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetRequest) Local(local bool) DefaultAPIIndicesGetRequest {
	r.local = &local
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r DefaultAPIIndicesGetRequest) FlatSettings(flatSettings bool) DefaultAPIIndicesGetRequest {
	r.flatSettings = &flatSettings
	return r
}

// Whether to return all default setting for each of the indices.
func (r DefaultAPIIndicesGetRequest) IncludeDefaults(includeDefaults bool) DefaultAPIIndicesGetRequest {
	r.includeDefaults = &includeDefaults
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesGetRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesGetRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesGetRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesGetRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetExecute(r)
}

/*
IndicesGet Method for IndicesGet

Returns information about one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices.
 @return DefaultAPIIndicesGetRequest
*/
func (a *DefaultAPIService) IndicesGet(ctx context.Context, index string) DefaultAPIIndicesGetRequest {
	return DefaultAPIIndicesGetRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetExecute(r DefaultAPIIndicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	} else {
		var defaultValue bool = false
		r.allowNoIndices = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	} else {
		var defaultValue bool = false
		r.includeDefaults = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetAliasRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetAliasRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetAliasRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetAliasRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetAliasRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetAliasRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetAliasRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetAliasRequest) Local(local bool) DefaultAPIIndicesGetAliasRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesGetAliasRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetAliasExecute(r)
}

/*
IndicesGetAlias Method for IndicesGetAlias

Returns an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesGetAliasRequest
*/
func (a *DefaultAPIService) IndicesGetAlias(ctx context.Context) DefaultAPIIndicesGetAliasRequest {
	return DefaultAPIIndicesGetAliasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetAliasExecute(r DefaultAPIIndicesGetAliasRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetAlias")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_alias"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetAliasWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetAliasWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetAliasWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetAliasWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetAliasWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetAliasWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetAliasWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetAliasWithIndexRequest) Local(local bool) DefaultAPIIndicesGetAliasWithIndexRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesGetAliasWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetAliasWithIndexExecute(r)
}

/*
IndicesGetAliasWithIndex Method for IndicesGetAliasWithIndex

Returns an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to filter aliases.
 @return DefaultAPIIndicesGetAliasWithIndexRequest
*/
func (a *DefaultAPIService) IndicesGetAliasWithIndex(ctx context.Context, index string) DefaultAPIIndicesGetAliasWithIndexRequest {
	return DefaultAPIIndicesGetAliasWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetAliasWithIndexExecute(r DefaultAPIIndicesGetAliasWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetAliasWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_alias"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetAliasWithIndexNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetAliasWithIndexNameRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetAliasWithIndexNameRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetAliasWithIndexNameRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetAliasWithIndexNameRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetAliasWithIndexNameRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetAliasWithIndexNameRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetAliasWithIndexNameRequest) Local(local bool) DefaultAPIIndicesGetAliasWithIndexNameRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesGetAliasWithIndexNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetAliasWithIndexNameExecute(r)
}

/*
IndicesGetAliasWithIndexName Method for IndicesGetAliasWithIndexName

Returns an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to filter aliases.
 @param name Comma-separated list of alias names.
 @return DefaultAPIIndicesGetAliasWithIndexNameRequest
*/
func (a *DefaultAPIService) IndicesGetAliasWithIndexName(ctx context.Context, index string, name string) DefaultAPIIndicesGetAliasWithIndexNameRequest {
	return DefaultAPIIndicesGetAliasWithIndexNameRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetAliasWithIndexNameExecute(r DefaultAPIIndicesGetAliasWithIndexNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetAliasWithIndexName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_alias/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetAliasWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetAliasWithNameRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetAliasWithNameRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetAliasWithNameRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetAliasWithNameRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetAliasWithNameRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetAliasWithNameRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetAliasWithNameRequest) Local(local bool) DefaultAPIIndicesGetAliasWithNameRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesGetAliasWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetAliasWithNameExecute(r)
}

/*
IndicesGetAliasWithName Method for IndicesGetAliasWithName

Returns an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of alias names.
 @return DefaultAPIIndicesGetAliasWithNameRequest
*/
func (a *DefaultAPIService) IndicesGetAliasWithName(ctx context.Context, name string) DefaultAPIIndicesGetAliasWithNameRequest {
	return DefaultAPIIndicesGetAliasWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetAliasWithNameExecute(r DefaultAPIIndicesGetAliasWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetAliasWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_alias/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetDataStreamRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIIndicesGetDataStreamRequest) Execute() (*IndicesGetDataStreamResponseContent, *http.Response, error) {
	return r.ApiService.IndicesGetDataStreamExecute(r)
}

/*
IndicesGetDataStream Method for IndicesGetDataStream

Returns data streams.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesGetDataStreamRequest
*/
func (a *DefaultAPIService) IndicesGetDataStream(ctx context.Context) DefaultAPIIndicesGetDataStreamRequest {
	return DefaultAPIIndicesGetDataStreamRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IndicesGetDataStreamResponseContent
func (a *DefaultAPIService) IndicesGetDataStreamExecute(r DefaultAPIIndicesGetDataStreamRequest) (*IndicesGetDataStreamResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesGetDataStreamResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetDataStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_data_stream"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetDataStreamWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
}

func (r DefaultAPIIndicesGetDataStreamWithNameRequest) Execute() (*IndicesGetDataStreamWithNameResponseContent, *http.Response, error) {
	return r.ApiService.IndicesGetDataStreamWithNameExecute(r)
}

/*
IndicesGetDataStreamWithName Method for IndicesGetDataStreamWithName

Returns data streams.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of data streams; use `_all` or empty string to perform the operation on all data streams.
 @return DefaultAPIIndicesGetDataStreamWithNameRequest
*/
func (a *DefaultAPIService) IndicesGetDataStreamWithName(ctx context.Context, name string) DefaultAPIIndicesGetDataStreamWithNameRequest {
	return DefaultAPIIndicesGetDataStreamWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return IndicesGetDataStreamWithNameResponseContent
func (a *DefaultAPIService) IndicesGetDataStreamWithNameExecute(r DefaultAPIIndicesGetDataStreamWithNameRequest) (*IndicesGetDataStreamWithNameResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesGetDataStreamWithNameResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetDataStreamWithName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_data_stream/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetFieldMappingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	fields string
	includeDefaults *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether the default mapping values should be returned as well.
func (r DefaultAPIIndicesGetFieldMappingRequest) IncludeDefaults(includeDefaults bool) DefaultAPIIndicesGetFieldMappingRequest {
	r.includeDefaults = &includeDefaults
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetFieldMappingRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetFieldMappingRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetFieldMappingRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetFieldMappingRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetFieldMappingRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetFieldMappingRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetFieldMappingRequest) Local(local bool) DefaultAPIIndicesGetFieldMappingRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesGetFieldMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetFieldMappingExecute(r)
}

/*
IndicesGetFieldMapping Method for IndicesGetFieldMapping

Returns mapping for one or more fields.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fields Comma-separated list of fields.
 @return DefaultAPIIndicesGetFieldMappingRequest
*/
func (a *DefaultAPIService) IndicesGetFieldMapping(ctx context.Context, fields string) DefaultAPIIndicesGetFieldMappingRequest {
	return DefaultAPIIndicesGetFieldMappingRequest{
		ApiService: a,
		ctx: ctx,
		fields: fields,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetFieldMappingExecute(r DefaultAPIIndicesGetFieldMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetFieldMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_mapping/field/{fields}"
	localVarPath = strings.Replace(localVarPath, "{"+"fields"+"}", url.PathEscape(parameterValueToString(r.fields, "fields")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetFieldMappingWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	fields string
	includeDefaults *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	local *bool
}

// Whether the default mapping values should be returned as well.
func (r DefaultAPIIndicesGetFieldMappingWithIndexRequest) IncludeDefaults(includeDefaults bool) DefaultAPIIndicesGetFieldMappingWithIndexRequest {
	r.includeDefaults = &includeDefaults
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetFieldMappingWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetFieldMappingWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetFieldMappingWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetFieldMappingWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetFieldMappingWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetFieldMappingWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetFieldMappingWithIndexRequest) Local(local bool) DefaultAPIIndicesGetFieldMappingWithIndexRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesGetFieldMappingWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetFieldMappingWithIndexExecute(r)
}

/*
IndicesGetFieldMappingWithIndex Method for IndicesGetFieldMappingWithIndex

Returns mapping for one or more fields.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices.
 @param fields Comma-separated list of fields.
 @return DefaultAPIIndicesGetFieldMappingWithIndexRequest
*/
func (a *DefaultAPIService) IndicesGetFieldMappingWithIndex(ctx context.Context, index string, fields string) DefaultAPIIndicesGetFieldMappingWithIndexRequest {
	return DefaultAPIIndicesGetFieldMappingWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		fields: fields,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetFieldMappingWithIndexExecute(r DefaultAPIIndicesGetFieldMappingWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetFieldMappingWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mapping/field/{fields}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fields"+"}", url.PathEscape(parameterValueToString(r.fields, "fields")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetIndexTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	flatSettings *bool
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Return settings in flat format.
func (r DefaultAPIIndicesGetIndexTemplateRequest) FlatSettings(flatSettings bool) DefaultAPIIndicesGetIndexTemplateRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesGetIndexTemplateRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesGetIndexTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesGetIndexTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesGetIndexTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetIndexTemplateRequest) Local(local bool) DefaultAPIIndicesGetIndexTemplateRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesGetIndexTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetIndexTemplateExecute(r)
}

/*
IndicesGetIndexTemplate Method for IndicesGetIndexTemplate

Returns an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesGetIndexTemplateRequest
*/
func (a *DefaultAPIService) IndicesGetIndexTemplate(ctx context.Context) DefaultAPIIndicesGetIndexTemplateRequest {
	return DefaultAPIIndicesGetIndexTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetIndexTemplateExecute(r DefaultAPIIndicesGetIndexTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetIndexTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetIndexTemplateWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	flatSettings *bool
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Return settings in flat format.
func (r DefaultAPIIndicesGetIndexTemplateWithNameRequest) FlatSettings(flatSettings bool) DefaultAPIIndicesGetIndexTemplateWithNameRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesGetIndexTemplateWithNameRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesGetIndexTemplateWithNameRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesGetIndexTemplateWithNameRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesGetIndexTemplateWithNameRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetIndexTemplateWithNameRequest) Local(local bool) DefaultAPIIndicesGetIndexTemplateWithNameRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesGetIndexTemplateWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetIndexTemplateWithNameExecute(r)
}

/*
IndicesGetIndexTemplateWithName Method for IndicesGetIndexTemplateWithName

Returns an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated names of the index templates.
 @return DefaultAPIIndicesGetIndexTemplateWithNameRequest
*/
func (a *DefaultAPIService) IndicesGetIndexTemplateWithName(ctx context.Context, name string) DefaultAPIIndicesGetIndexTemplateWithNameRequest {
	return DefaultAPIIndicesGetIndexTemplateWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetIndexTemplateWithNameExecute(r DefaultAPIIndicesGetIndexTemplateWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetIndexTemplateWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetMappingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetMappingRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetMappingRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetMappingRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetMappingRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetMappingRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetMappingRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesGetMappingRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesGetMappingRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesGetMappingRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesGetMappingRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetMappingRequest) Local(local bool) DefaultAPIIndicesGetMappingRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesGetMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetMappingExecute(r)
}

/*
IndicesGetMapping Method for IndicesGetMapping

Returns mappings for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesGetMappingRequest
*/
func (a *DefaultAPIService) IndicesGetMapping(ctx context.Context) DefaultAPIIndicesGetMappingRequest {
	return DefaultAPIIndicesGetMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetMappingExecute(r DefaultAPIIndicesGetMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetMappingWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetMappingWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetMappingWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetMappingWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetMappingWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetMappingWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetMappingWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesGetMappingWithIndexRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesGetMappingWithIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesGetMappingWithIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesGetMappingWithIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetMappingWithIndexRequest) Local(local bool) DefaultAPIIndicesGetMappingWithIndexRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesGetMappingWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetMappingWithIndexExecute(r)
}

/*
IndicesGetMappingWithIndex Method for IndicesGetMappingWithIndex

Returns mappings for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices.
 @return DefaultAPIIndicesGetMappingWithIndexRequest
*/
func (a *DefaultAPIService) IndicesGetMappingWithIndex(ctx context.Context, index string) DefaultAPIIndicesGetMappingWithIndexRequest {
	return DefaultAPIIndicesGetMappingWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetMappingWithIndexExecute(r DefaultAPIIndicesGetMappingWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetMappingWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mapping"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetSettingsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
	local *bool
	includeDefaults *bool
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesGetSettingsRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesGetSettingsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesGetSettingsRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesGetSettingsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetSettingsRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetSettingsRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetSettingsRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetSettingsRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetSettingsRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetSettingsRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r DefaultAPIIndicesGetSettingsRequest) FlatSettings(flatSettings bool) DefaultAPIIndicesGetSettingsRequest {
	r.flatSettings = &flatSettings
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetSettingsRequest) Local(local bool) DefaultAPIIndicesGetSettingsRequest {
	r.local = &local
	return r
}

// Whether to return all default setting for each of the indices.
func (r DefaultAPIIndicesGetSettingsRequest) IncludeDefaults(includeDefaults bool) DefaultAPIIndicesGetSettingsRequest {
	r.includeDefaults = &includeDefaults
	return r
}

func (r DefaultAPIIndicesGetSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetSettingsExecute(r)
}

/*
IndicesGetSettings Method for IndicesGetSettings

Returns settings for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesGetSettingsRequest
*/
func (a *DefaultAPIService) IndicesGetSettings(ctx context.Context) DefaultAPIIndicesGetSettingsRequest {
	return DefaultAPIIndicesGetSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetSettingsExecute(r DefaultAPIIndicesGetSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	} else {
		var defaultValue bool = false
		r.includeDefaults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetSettingsWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
	local *bool
	includeDefaults *bool
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesGetSettingsWithIndexRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesGetSettingsWithIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesGetSettingsWithIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesGetSettingsWithIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetSettingsWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetSettingsWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetSettingsWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetSettingsWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetSettingsWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetSettingsWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r DefaultAPIIndicesGetSettingsWithIndexRequest) FlatSettings(flatSettings bool) DefaultAPIIndicesGetSettingsWithIndexRequest {
	r.flatSettings = &flatSettings
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetSettingsWithIndexRequest) Local(local bool) DefaultAPIIndicesGetSettingsWithIndexRequest {
	r.local = &local
	return r
}

// Whether to return all default setting for each of the indices.
func (r DefaultAPIIndicesGetSettingsWithIndexRequest) IncludeDefaults(includeDefaults bool) DefaultAPIIndicesGetSettingsWithIndexRequest {
	r.includeDefaults = &includeDefaults
	return r
}

func (r DefaultAPIIndicesGetSettingsWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetSettingsWithIndexExecute(r)
}

/*
IndicesGetSettingsWithIndex Method for IndicesGetSettingsWithIndex

Returns settings for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesGetSettingsWithIndexRequest
*/
func (a *DefaultAPIService) IndicesGetSettingsWithIndex(ctx context.Context, index string) DefaultAPIIndicesGetSettingsWithIndexRequest {
	return DefaultAPIIndicesGetSettingsWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetSettingsWithIndexExecute(r DefaultAPIIndicesGetSettingsWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetSettingsWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_settings"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	} else {
		var defaultValue bool = false
		r.includeDefaults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetSettingsWithIndexNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
	local *bool
	includeDefaults *bool
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesGetSettingsWithIndexNameRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesGetSettingsWithIndexNameRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesGetSettingsWithIndexNameRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesGetSettingsWithIndexNameRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetSettingsWithIndexNameRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetSettingsWithIndexNameRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetSettingsWithIndexNameRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetSettingsWithIndexNameRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetSettingsWithIndexNameRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetSettingsWithIndexNameRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r DefaultAPIIndicesGetSettingsWithIndexNameRequest) FlatSettings(flatSettings bool) DefaultAPIIndicesGetSettingsWithIndexNameRequest {
	r.flatSettings = &flatSettings
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetSettingsWithIndexNameRequest) Local(local bool) DefaultAPIIndicesGetSettingsWithIndexNameRequest {
	r.local = &local
	return r
}

// Whether to return all default setting for each of the indices.
func (r DefaultAPIIndicesGetSettingsWithIndexNameRequest) IncludeDefaults(includeDefaults bool) DefaultAPIIndicesGetSettingsWithIndexNameRequest {
	r.includeDefaults = &includeDefaults
	return r
}

func (r DefaultAPIIndicesGetSettingsWithIndexNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetSettingsWithIndexNameExecute(r)
}

/*
IndicesGetSettingsWithIndexName Method for IndicesGetSettingsWithIndexName

Returns settings for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param name Comma-separated list of settings.
 @return DefaultAPIIndicesGetSettingsWithIndexNameRequest
*/
func (a *DefaultAPIService) IndicesGetSettingsWithIndexName(ctx context.Context, index string, name string) DefaultAPIIndicesGetSettingsWithIndexNameRequest {
	return DefaultAPIIndicesGetSettingsWithIndexNameRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetSettingsWithIndexNameExecute(r DefaultAPIIndicesGetSettingsWithIndexNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetSettingsWithIndexName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_settings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	} else {
		var defaultValue bool = false
		r.includeDefaults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetSettingsWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
	local *bool
	includeDefaults *bool
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesGetSettingsWithNameRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesGetSettingsWithNameRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesGetSettingsWithNameRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesGetSettingsWithNameRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetSettingsWithNameRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetSettingsWithNameRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetSettingsWithNameRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetSettingsWithNameRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetSettingsWithNameRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetSettingsWithNameRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r DefaultAPIIndicesGetSettingsWithNameRequest) FlatSettings(flatSettings bool) DefaultAPIIndicesGetSettingsWithNameRequest {
	r.flatSettings = &flatSettings
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetSettingsWithNameRequest) Local(local bool) DefaultAPIIndicesGetSettingsWithNameRequest {
	r.local = &local
	return r
}

// Whether to return all default setting for each of the indices.
func (r DefaultAPIIndicesGetSettingsWithNameRequest) IncludeDefaults(includeDefaults bool) DefaultAPIIndicesGetSettingsWithNameRequest {
	r.includeDefaults = &includeDefaults
	return r
}

func (r DefaultAPIIndicesGetSettingsWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetSettingsWithNameExecute(r)
}

/*
IndicesGetSettingsWithName Method for IndicesGetSettingsWithName

Returns settings for one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of settings.
 @return DefaultAPIIndicesGetSettingsWithNameRequest
*/
func (a *DefaultAPIService) IndicesGetSettingsWithName(ctx context.Context, name string) DefaultAPIIndicesGetSettingsWithNameRequest {
	return DefaultAPIIndicesGetSettingsWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetSettingsWithNameExecute(r DefaultAPIIndicesGetSettingsWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetSettingsWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_settings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.includeDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_defaults", r.includeDefaults, "")
	} else {
		var defaultValue bool = false
		r.includeDefaults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	flatSettings *bool
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Return settings in flat format.
func (r DefaultAPIIndicesGetTemplateRequest) FlatSettings(flatSettings bool) DefaultAPIIndicesGetTemplateRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesGetTemplateRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesGetTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesGetTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesGetTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetTemplateRequest) Local(local bool) DefaultAPIIndicesGetTemplateRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesGetTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetTemplateExecute(r)
}

/*
IndicesGetTemplate Method for IndicesGetTemplate

Returns an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesGetTemplateRequest
*/
func (a *DefaultAPIService) IndicesGetTemplate(ctx context.Context) DefaultAPIIndicesGetTemplateRequest {
	return DefaultAPIIndicesGetTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetTemplateExecute(r DefaultAPIIndicesGetTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetTemplateWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	flatSettings *bool
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Return settings in flat format.
func (r DefaultAPIIndicesGetTemplateWithNameRequest) FlatSettings(flatSettings bool) DefaultAPIIndicesGetTemplateWithNameRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesGetTemplateWithNameRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesGetTemplateWithNameRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesGetTemplateWithNameRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesGetTemplateWithNameRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPIIndicesGetTemplateWithNameRequest) Local(local bool) DefaultAPIIndicesGetTemplateWithNameRequest {
	r.local = &local
	return r
}

func (r DefaultAPIIndicesGetTemplateWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetTemplateWithNameExecute(r)
}

/*
IndicesGetTemplateWithName Method for IndicesGetTemplateWithName

Returns an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated names of the index templates.
 @return DefaultAPIIndicesGetTemplateWithNameRequest
*/
func (a *DefaultAPIService) IndicesGetTemplateWithName(ctx context.Context, name string) DefaultAPIIndicesGetTemplateWithNameRequest {
	return DefaultAPIIndicesGetTemplateWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetTemplateWithNameExecute(r DefaultAPIIndicesGetTemplateWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetTemplateWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetUpgradeRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetUpgradeRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetUpgradeRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetUpgradeRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetUpgradeRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetUpgradeRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetUpgradeRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesGetUpgradeRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetUpgradeExecute(r)
}

/*
IndicesGetUpgrade Method for IndicesGetUpgrade

The _upgrade API is no longer useful and will be removed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesGetUpgradeRequest
*/
func (a *DefaultAPIService) IndicesGetUpgrade(ctx context.Context) DefaultAPIIndicesGetUpgradeRequest {
	return DefaultAPIIndicesGetUpgradeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetUpgradeExecute(r DefaultAPIIndicesGetUpgradeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetUpgrade")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_upgrade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesGetUpgradeWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesGetUpgradeWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesGetUpgradeWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesGetUpgradeWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesGetUpgradeWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesGetUpgradeWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesGetUpgradeWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesGetUpgradeWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesGetUpgradeWithIndexExecute(r)
}

/*
IndicesGetUpgradeWithIndex Method for IndicesGetUpgradeWithIndex

The _upgrade API is no longer useful and will be removed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesGetUpgradeWithIndexRequest
*/
func (a *DefaultAPIService) IndicesGetUpgradeWithIndex(ctx context.Context, index string) DefaultAPIIndicesGetUpgradeWithIndexRequest {
	return DefaultAPIIndicesGetUpgradeWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesGetUpgradeWithIndexExecute(r DefaultAPIIndicesGetUpgradeWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesGetUpgradeWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_upgrade"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesOpenRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	timeout *string
	masterTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	waitForActiveShards *string
}

// Operation timeout.
func (r DefaultAPIIndicesOpenRequest) Timeout(timeout string) DefaultAPIIndicesOpenRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesOpenRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesOpenRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesOpenRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesOpenRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesOpenRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesOpenRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesOpenRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesOpenRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Sets the number of active shards to wait for before the operation returns.
func (r DefaultAPIIndicesOpenRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIIndicesOpenRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r DefaultAPIIndicesOpenRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesOpenExecute(r)
}

/*
IndicesOpen Method for IndicesOpen

Opens an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to open.
 @return DefaultAPIIndicesOpenRequest
*/
func (a *DefaultAPIService) IndicesOpen(ctx context.Context, index string) DefaultAPIIndicesOpenRequest {
	return DefaultAPIIndicesOpenRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesOpenExecute(r DefaultAPIIndicesOpenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesOpen")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_open"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesPutAliasPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	body *map[string]interface{}
}

// Operation timeout.
func (r DefaultAPIIndicesPutAliasPostRequest) Timeout(timeout string) DefaultAPIIndicesPutAliasPostRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesPutAliasPostRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesPutAliasPostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesPutAliasPostRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesPutAliasPostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesPutAliasPostRequest) Body(body map[string]interface{}) DefaultAPIIndicesPutAliasPostRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesPutAliasPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutAliasPostExecute(r)
}

/*
IndicesPutAliasPost Method for IndicesPutAliasPost

Creates or updates an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param name The name of the alias to be created or updated.
 @return DefaultAPIIndicesPutAliasPostRequest
*/
func (a *DefaultAPIService) IndicesPutAliasPost(ctx context.Context, index string, name string) DefaultAPIIndicesPutAliasPostRequest {
	return DefaultAPIIndicesPutAliasPostRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutAliasPostExecute(r DefaultAPIIndicesPutAliasPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutAliasPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_alias/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesPutAliasPostPluralRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	body *map[string]interface{}
}

// Operation timeout.
func (r DefaultAPIIndicesPutAliasPostPluralRequest) Timeout(timeout string) DefaultAPIIndicesPutAliasPostPluralRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesPutAliasPostPluralRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesPutAliasPostPluralRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesPutAliasPostPluralRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesPutAliasPostPluralRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesPutAliasPostPluralRequest) Body(body map[string]interface{}) DefaultAPIIndicesPutAliasPostPluralRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesPutAliasPostPluralRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutAliasPostPluralExecute(r)
}

/*
IndicesPutAliasPostPlural Method for IndicesPutAliasPostPlural

Creates or updates an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param name The name of the alias to be created or updated.
 @return DefaultAPIIndicesPutAliasPostPluralRequest
*/
func (a *DefaultAPIService) IndicesPutAliasPostPlural(ctx context.Context, index string, name string) DefaultAPIIndicesPutAliasPostPluralRequest {
	return DefaultAPIIndicesPutAliasPostPluralRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutAliasPostPluralExecute(r DefaultAPIIndicesPutAliasPostPluralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutAliasPostPlural")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_aliases/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesPutAliasPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	body *map[string]interface{}
}

// Operation timeout.
func (r DefaultAPIIndicesPutAliasPutRequest) Timeout(timeout string) DefaultAPIIndicesPutAliasPutRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesPutAliasPutRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesPutAliasPutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesPutAliasPutRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesPutAliasPutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesPutAliasPutRequest) Body(body map[string]interface{}) DefaultAPIIndicesPutAliasPutRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesPutAliasPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutAliasPutExecute(r)
}

/*
IndicesPutAliasPut Method for IndicesPutAliasPut

Creates or updates an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param name The name of the alias to be created or updated.
 @return DefaultAPIIndicesPutAliasPutRequest
*/
func (a *DefaultAPIService) IndicesPutAliasPut(ctx context.Context, index string, name string) DefaultAPIIndicesPutAliasPutRequest {
	return DefaultAPIIndicesPutAliasPutRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutAliasPutExecute(r DefaultAPIIndicesPutAliasPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutAliasPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_alias/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesPutAliasPutPluralRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	name string
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	body *map[string]interface{}
}

// Operation timeout.
func (r DefaultAPIIndicesPutAliasPutPluralRequest) Timeout(timeout string) DefaultAPIIndicesPutAliasPutPluralRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesPutAliasPutPluralRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesPutAliasPutPluralRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesPutAliasPutPluralRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesPutAliasPutPluralRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesPutAliasPutPluralRequest) Body(body map[string]interface{}) DefaultAPIIndicesPutAliasPutPluralRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesPutAliasPutPluralRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutAliasPutPluralExecute(r)
}

/*
IndicesPutAliasPutPlural Method for IndicesPutAliasPutPlural

Creates or updates an alias.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param name The name of the alias to be created or updated.
 @return DefaultAPIIndicesPutAliasPutPluralRequest
*/
func (a *DefaultAPIService) IndicesPutAliasPutPlural(ctx context.Context, index string, name string) DefaultAPIIndicesPutAliasPutPluralRequest {
	return DefaultAPIIndicesPutAliasPutPluralRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutAliasPutPluralExecute(r DefaultAPIIndicesPutAliasPutPluralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutAliasPutPlural")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_aliases/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesPutIndexTemplatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	body *map[string]interface{}
	create *bool
	cause *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r DefaultAPIIndicesPutIndexTemplatePostRequest) Body(body map[string]interface{}) DefaultAPIIndicesPutIndexTemplatePostRequest {
	r.body = &body
	return r
}

// Whether the index template should only be added if new or can also replace an existing one.
func (r DefaultAPIIndicesPutIndexTemplatePostRequest) Create(create bool) DefaultAPIIndicesPutIndexTemplatePostRequest {
	r.create = &create
	return r
}

// User defined reason for creating/updating the index template.
func (r DefaultAPIIndicesPutIndexTemplatePostRequest) Cause(cause string) DefaultAPIIndicesPutIndexTemplatePostRequest {
	r.cause = &cause
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesPutIndexTemplatePostRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesPutIndexTemplatePostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesPutIndexTemplatePostRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesPutIndexTemplatePostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesPutIndexTemplatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutIndexTemplatePostExecute(r)
}

/*
IndicesPutIndexTemplatePost Method for IndicesPutIndexTemplatePost

Creates or updates an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return DefaultAPIIndicesPutIndexTemplatePostRequest
*/
func (a *DefaultAPIService) IndicesPutIndexTemplatePost(ctx context.Context, name string) DefaultAPIIndicesPutIndexTemplatePostRequest {
	return DefaultAPIIndicesPutIndexTemplatePostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutIndexTemplatePostExecute(r DefaultAPIIndicesPutIndexTemplatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutIndexTemplatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.cause != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cause", r.cause, "")
	} else {
		var defaultValue string = "false"
		r.cause = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesPutIndexTemplatePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	body *map[string]interface{}
	create *bool
	cause *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r DefaultAPIIndicesPutIndexTemplatePutRequest) Body(body map[string]interface{}) DefaultAPIIndicesPutIndexTemplatePutRequest {
	r.body = &body
	return r
}

// Whether the index template should only be added if new or can also replace an existing one.
func (r DefaultAPIIndicesPutIndexTemplatePutRequest) Create(create bool) DefaultAPIIndicesPutIndexTemplatePutRequest {
	r.create = &create
	return r
}

// User defined reason for creating/updating the index template.
func (r DefaultAPIIndicesPutIndexTemplatePutRequest) Cause(cause string) DefaultAPIIndicesPutIndexTemplatePutRequest {
	r.cause = &cause
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesPutIndexTemplatePutRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesPutIndexTemplatePutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesPutIndexTemplatePutRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesPutIndexTemplatePutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesPutIndexTemplatePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutIndexTemplatePutExecute(r)
}

/*
IndicesPutIndexTemplatePut Method for IndicesPutIndexTemplatePut

Creates or updates an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return DefaultAPIIndicesPutIndexTemplatePutRequest
*/
func (a *DefaultAPIService) IndicesPutIndexTemplatePut(ctx context.Context, name string) DefaultAPIIndicesPutIndexTemplatePutRequest {
	return DefaultAPIIndicesPutIndexTemplatePutRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutIndexTemplatePutExecute(r DefaultAPIIndicesPutIndexTemplatePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutIndexTemplatePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.cause != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cause", r.cause, "")
	} else {
		var defaultValue string = "false"
		r.cause = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesPutMappingPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	writeIndexOnly *bool
}

func (r DefaultAPIIndicesPutMappingPostRequest) Body(body map[string]interface{}) DefaultAPIIndicesPutMappingPostRequest {
	r.body = &body
	return r
}

// Operation timeout.
func (r DefaultAPIIndicesPutMappingPostRequest) Timeout(timeout string) DefaultAPIIndicesPutMappingPostRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesPutMappingPostRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesPutMappingPostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesPutMappingPostRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesPutMappingPostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesPutMappingPostRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesPutMappingPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesPutMappingPostRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesPutMappingPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesPutMappingPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesPutMappingPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// When true, applies mappings only to the write index of an alias or data stream.
func (r DefaultAPIIndicesPutMappingPostRequest) WriteIndexOnly(writeIndexOnly bool) DefaultAPIIndicesPutMappingPostRequest {
	r.writeIndexOnly = &writeIndexOnly
	return r
}

func (r DefaultAPIIndicesPutMappingPostRequest) Execute() (*IndicesPutMappingPostResponseContent, *http.Response, error) {
	return r.ApiService.IndicesPutMappingPostExecute(r)
}

/*
IndicesPutMappingPost Method for IndicesPutMappingPost

Updates the index mappings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesPutMappingPostRequest
*/
func (a *DefaultAPIService) IndicesPutMappingPost(ctx context.Context, index string) DefaultAPIIndicesPutMappingPostRequest {
	return DefaultAPIIndicesPutMappingPostRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
//  @return IndicesPutMappingPostResponseContent
func (a *DefaultAPIService) IndicesPutMappingPostExecute(r DefaultAPIIndicesPutMappingPostRequest) (*IndicesPutMappingPostResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesPutMappingPostResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutMappingPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mapping"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.writeIndexOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "write_index_only", r.writeIndexOnly, "")
	} else {
		var defaultValue bool = false
		r.writeIndexOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIIndicesPutMappingPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	writeIndexOnly *bool
}

func (r DefaultAPIIndicesPutMappingPutRequest) Body(body map[string]interface{}) DefaultAPIIndicesPutMappingPutRequest {
	r.body = &body
	return r
}

// Operation timeout.
func (r DefaultAPIIndicesPutMappingPutRequest) Timeout(timeout string) DefaultAPIIndicesPutMappingPutRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesPutMappingPutRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesPutMappingPutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesPutMappingPutRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesPutMappingPutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesPutMappingPutRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesPutMappingPutRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesPutMappingPutRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesPutMappingPutRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesPutMappingPutRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesPutMappingPutRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// When true, applies mappings only to the write index of an alias or data stream.
func (r DefaultAPIIndicesPutMappingPutRequest) WriteIndexOnly(writeIndexOnly bool) DefaultAPIIndicesPutMappingPutRequest {
	r.writeIndexOnly = &writeIndexOnly
	return r
}

func (r DefaultAPIIndicesPutMappingPutRequest) Execute() (*IndicesPutMappingPutResponseContent, *http.Response, error) {
	return r.ApiService.IndicesPutMappingPutExecute(r)
}

/*
IndicesPutMappingPut Method for IndicesPutMappingPut

Updates the index mappings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesPutMappingPutRequest
*/
func (a *DefaultAPIService) IndicesPutMappingPut(ctx context.Context, index string) DefaultAPIIndicesPutMappingPutRequest {
	return DefaultAPIIndicesPutMappingPutRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
//  @return IndicesPutMappingPutResponseContent
func (a *DefaultAPIService) IndicesPutMappingPutExecute(r DefaultAPIIndicesPutMappingPutRequest) (*IndicesPutMappingPutResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesPutMappingPutResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutMappingPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mapping"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.writeIndexOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "write_index_only", r.writeIndexOnly, "")
	} else {
		var defaultValue bool = false
		r.writeIndexOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIIndicesPutSettingsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	preserveExisting *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
}

func (r DefaultAPIIndicesPutSettingsRequest) Body(body map[string]interface{}) DefaultAPIIndicesPutSettingsRequest {
	r.body = &body
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesPutSettingsRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesPutSettingsRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesPutSettingsRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesPutSettingsRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r DefaultAPIIndicesPutSettingsRequest) Timeout(timeout string) DefaultAPIIndicesPutSettingsRequest {
	r.timeout = &timeout
	return r
}

// Whether to update existing settings. If set to &#x60;true&#x60; existing settings on an index remain unchanged.
func (r DefaultAPIIndicesPutSettingsRequest) PreserveExisting(preserveExisting bool) DefaultAPIIndicesPutSettingsRequest {
	r.preserveExisting = &preserveExisting
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesPutSettingsRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesPutSettingsRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesPutSettingsRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesPutSettingsRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesPutSettingsRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesPutSettingsRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r DefaultAPIIndicesPutSettingsRequest) FlatSettings(flatSettings bool) DefaultAPIIndicesPutSettingsRequest {
	r.flatSettings = &flatSettings
	return r
}

func (r DefaultAPIIndicesPutSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutSettingsExecute(r)
}

/*
IndicesPutSettings Method for IndicesPutSettings

Updates the index settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesPutSettingsRequest
*/
func (a *DefaultAPIService) IndicesPutSettings(ctx context.Context) DefaultAPIIndicesPutSettingsRequest {
	return DefaultAPIIndicesPutSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutSettingsExecute(r DefaultAPIIndicesPutSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.preserveExisting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preserve_existing", r.preserveExisting, "")
	} else {
		var defaultValue bool = false
		r.preserveExisting = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesPutSettingsWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	preserveExisting *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	flatSettings *bool
}

func (r DefaultAPIIndicesPutSettingsWithIndexRequest) Body(body map[string]interface{}) DefaultAPIIndicesPutSettingsWithIndexRequest {
	r.body = &body
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesPutSettingsWithIndexRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesPutSettingsWithIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesPutSettingsWithIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesPutSettingsWithIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r DefaultAPIIndicesPutSettingsWithIndexRequest) Timeout(timeout string) DefaultAPIIndicesPutSettingsWithIndexRequest {
	r.timeout = &timeout
	return r
}

// Whether to update existing settings. If set to &#x60;true&#x60; existing settings on an index remain unchanged.
func (r DefaultAPIIndicesPutSettingsWithIndexRequest) PreserveExisting(preserveExisting bool) DefaultAPIIndicesPutSettingsWithIndexRequest {
	r.preserveExisting = &preserveExisting
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesPutSettingsWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesPutSettingsWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesPutSettingsWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesPutSettingsWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesPutSettingsWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesPutSettingsWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Return settings in flat format.
func (r DefaultAPIIndicesPutSettingsWithIndexRequest) FlatSettings(flatSettings bool) DefaultAPIIndicesPutSettingsWithIndexRequest {
	r.flatSettings = &flatSettings
	return r
}

func (r DefaultAPIIndicesPutSettingsWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutSettingsWithIndexExecute(r)
}

/*
IndicesPutSettingsWithIndex Method for IndicesPutSettingsWithIndex

Updates the index settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesPutSettingsWithIndexRequest
*/
func (a *DefaultAPIService) IndicesPutSettingsWithIndex(ctx context.Context, index string) DefaultAPIIndicesPutSettingsWithIndexRequest {
	return DefaultAPIIndicesPutSettingsWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutSettingsWithIndexExecute(r DefaultAPIIndicesPutSettingsWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutSettingsWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_settings"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.preserveExisting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preserve_existing", r.preserveExisting, "")
	} else {
		var defaultValue bool = false
		r.preserveExisting = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesPutTemplatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	body *map[string]interface{}
	order *int32
	create *bool
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r DefaultAPIIndicesPutTemplatePostRequest) Body(body map[string]interface{}) DefaultAPIIndicesPutTemplatePostRequest {
	r.body = &body
	return r
}

// The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers).
func (r DefaultAPIIndicesPutTemplatePostRequest) Order(order int32) DefaultAPIIndicesPutTemplatePostRequest {
	r.order = &order
	return r
}

// Whether the index template should only be added if new or can also replace an existing one.
func (r DefaultAPIIndicesPutTemplatePostRequest) Create(create bool) DefaultAPIIndicesPutTemplatePostRequest {
	r.create = &create
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesPutTemplatePostRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesPutTemplatePostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesPutTemplatePostRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesPutTemplatePostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesPutTemplatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutTemplatePostExecute(r)
}

/*
IndicesPutTemplatePost Method for IndicesPutTemplatePost

Creates or updates an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return DefaultAPIIndicesPutTemplatePostRequest
*/
func (a *DefaultAPIService) IndicesPutTemplatePost(ctx context.Context, name string) DefaultAPIIndicesPutTemplatePostRequest {
	return DefaultAPIIndicesPutTemplatePostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutTemplatePostExecute(r DefaultAPIIndicesPutTemplatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutTemplatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesPutTemplatePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	body *map[string]interface{}
	order *int32
	create *bool
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r DefaultAPIIndicesPutTemplatePutRequest) Body(body map[string]interface{}) DefaultAPIIndicesPutTemplatePutRequest {
	r.body = &body
	return r
}

// The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers).
func (r DefaultAPIIndicesPutTemplatePutRequest) Order(order int32) DefaultAPIIndicesPutTemplatePutRequest {
	r.order = &order
	return r
}

// Whether the index template should only be added if new or can also replace an existing one.
func (r DefaultAPIIndicesPutTemplatePutRequest) Create(create bool) DefaultAPIIndicesPutTemplatePutRequest {
	r.create = &create
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesPutTemplatePutRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesPutTemplatePutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesPutTemplatePutRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesPutTemplatePutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesPutTemplatePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesPutTemplatePutExecute(r)
}

/*
IndicesPutTemplatePut Method for IndicesPutTemplatePut

Creates or updates an index template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return DefaultAPIIndicesPutTemplatePutRequest
*/
func (a *DefaultAPIService) IndicesPutTemplatePut(ctx context.Context, name string) DefaultAPIIndicesPutTemplatePutRequest {
	return DefaultAPIIndicesPutTemplatePutRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesPutTemplatePutExecute(r DefaultAPIIndicesPutTemplatePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesPutTemplatePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_template/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesRecoveryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	detailed *bool
	activeOnly *bool
}

// Whether to display detailed information about shard recovery.
func (r DefaultAPIIndicesRecoveryRequest) Detailed(detailed bool) DefaultAPIIndicesRecoveryRequest {
	r.detailed = &detailed
	return r
}

// Display only those recoveries that are currently on-going.
func (r DefaultAPIIndicesRecoveryRequest) ActiveOnly(activeOnly bool) DefaultAPIIndicesRecoveryRequest {
	r.activeOnly = &activeOnly
	return r
}

func (r DefaultAPIIndicesRecoveryRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRecoveryExecute(r)
}

/*
IndicesRecovery Method for IndicesRecovery

Returns information about ongoing index shard recoveries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesRecoveryRequest
*/
func (a *DefaultAPIService) IndicesRecovery(ctx context.Context) DefaultAPIIndicesRecoveryRequest {
	return DefaultAPIIndicesRecoveryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRecoveryExecute(r DefaultAPIIndicesRecoveryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRecovery")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_recovery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_only", r.activeOnly, "")
	} else {
		var defaultValue bool = false
		r.activeOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesRecoveryWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	detailed *bool
	activeOnly *bool
}

// Whether to display detailed information about shard recovery.
func (r DefaultAPIIndicesRecoveryWithIndexRequest) Detailed(detailed bool) DefaultAPIIndicesRecoveryWithIndexRequest {
	r.detailed = &detailed
	return r
}

// Display only those recoveries that are currently on-going.
func (r DefaultAPIIndicesRecoveryWithIndexRequest) ActiveOnly(activeOnly bool) DefaultAPIIndicesRecoveryWithIndexRequest {
	r.activeOnly = &activeOnly
	return r
}

func (r DefaultAPIIndicesRecoveryWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRecoveryWithIndexExecute(r)
}

/*
IndicesRecoveryWithIndex Method for IndicesRecoveryWithIndex

Returns information about ongoing index shard recoveries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesRecoveryWithIndexRequest
*/
func (a *DefaultAPIService) IndicesRecoveryWithIndex(ctx context.Context, index string) DefaultAPIIndicesRecoveryWithIndexRequest {
	return DefaultAPIIndicesRecoveryWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRecoveryWithIndexExecute(r DefaultAPIIndicesRecoveryWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRecoveryWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_recovery"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_only", r.activeOnly, "")
	} else {
		var defaultValue bool = false
		r.activeOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesRefreshGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesRefreshGetRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesRefreshGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesRefreshGetRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesRefreshGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesRefreshGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesRefreshGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesRefreshGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRefreshGetExecute(r)
}

/*
IndicesRefreshGet Method for IndicesRefreshGet

Performs the refresh operation in one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesRefreshGetRequest
*/
func (a *DefaultAPIService) IndicesRefreshGet(ctx context.Context) DefaultAPIIndicesRefreshGetRequest {
	return DefaultAPIIndicesRefreshGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRefreshGetExecute(r DefaultAPIIndicesRefreshGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRefreshGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesRefreshGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesRefreshGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesRefreshGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesRefreshGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesRefreshGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesRefreshGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesRefreshGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesRefreshGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRefreshGetWithIndexExecute(r)
}

/*
IndicesRefreshGetWithIndex Method for IndicesRefreshGetWithIndex

Performs the refresh operation in one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesRefreshGetWithIndexRequest
*/
func (a *DefaultAPIService) IndicesRefreshGetWithIndex(ctx context.Context, index string) DefaultAPIIndicesRefreshGetWithIndexRequest {
	return DefaultAPIIndicesRefreshGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRefreshGetWithIndexExecute(r DefaultAPIIndicesRefreshGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRefreshGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_refresh"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesRefreshPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesRefreshPostRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesRefreshPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesRefreshPostRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesRefreshPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesRefreshPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesRefreshPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesRefreshPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRefreshPostExecute(r)
}

/*
IndicesRefreshPost Method for IndicesRefreshPost

Performs the refresh operation in one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesRefreshPostRequest
*/
func (a *DefaultAPIService) IndicesRefreshPost(ctx context.Context) DefaultAPIIndicesRefreshPostRequest {
	return DefaultAPIIndicesRefreshPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRefreshPostExecute(r DefaultAPIIndicesRefreshPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRefreshPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesRefreshPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesRefreshPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesRefreshPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesRefreshPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesRefreshPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesRefreshPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesRefreshPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesRefreshPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRefreshPostWithIndexExecute(r)
}

/*
IndicesRefreshPostWithIndex Method for IndicesRefreshPostWithIndex

Performs the refresh operation in one or more indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesRefreshPostWithIndexRequest
*/
func (a *DefaultAPIService) IndicesRefreshPostWithIndex(ctx context.Context, index string) DefaultAPIIndicesRefreshPostWithIndexRequest {
	return DefaultAPIIndicesRefreshPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRefreshPostWithIndexExecute(r DefaultAPIIndicesRefreshPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRefreshPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_refresh"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesResolveIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	expandWildcards *ExpandWildcards
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesResolveIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesResolveIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesResolveIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesResolveIndexExecute(r)
}

/*
IndicesResolveIndex Method for IndicesResolveIndex

Returns information about any matching indices, aliases, and data streams.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Comma-separated list of names or wildcard expressions.
 @return DefaultAPIIndicesResolveIndexRequest
*/
func (a *DefaultAPIService) IndicesResolveIndex(ctx context.Context, name string) DefaultAPIIndicesResolveIndexRequest {
	return DefaultAPIIndicesResolveIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesResolveIndexExecute(r DefaultAPIIndicesResolveIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesResolveIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_resolve/index/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesRolloverRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	alias string
	timeout *string
	dryRun *bool
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// Operation timeout.
func (r DefaultAPIIndicesRolloverRequest) Timeout(timeout string) DefaultAPIIndicesRolloverRequest {
	r.timeout = &timeout
	return r
}

// If set to true the rollover action will only be validated but not actually performed even if a condition matches.
func (r DefaultAPIIndicesRolloverRequest) DryRun(dryRun bool) DefaultAPIIndicesRolloverRequest {
	r.dryRun = &dryRun
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesRolloverRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesRolloverRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesRolloverRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesRolloverRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the newly created rollover index before the operation returns.
func (r DefaultAPIIndicesRolloverRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIIndicesRolloverRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r DefaultAPIIndicesRolloverRequest) Body(body map[string]interface{}) DefaultAPIIndicesRolloverRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesRolloverRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRolloverExecute(r)
}

/*
IndicesRollover Method for IndicesRollover

Updates an alias to point to a new index when the existing index
is considered to be too large or too old.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alias The name of the alias to rollover.
 @return DefaultAPIIndicesRolloverRequest
*/
func (a *DefaultAPIService) IndicesRollover(ctx context.Context, alias string) DefaultAPIIndicesRolloverRequest {
	return DefaultAPIIndicesRolloverRequest{
		ApiService: a,
		ctx: ctx,
		alias: alias,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRolloverExecute(r DefaultAPIIndicesRolloverRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRollover")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{alias}/_rollover"
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dry_run", r.dryRun, "")
	} else {
		var defaultValue bool = false
		r.dryRun = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesRolloverWithNewIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	alias string
	newIndex string
	timeout *string
	dryRun *bool
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// Operation timeout.
func (r DefaultAPIIndicesRolloverWithNewIndexRequest) Timeout(timeout string) DefaultAPIIndicesRolloverWithNewIndexRequest {
	r.timeout = &timeout
	return r
}

// If set to true the rollover action will only be validated but not actually performed even if a condition matches.
func (r DefaultAPIIndicesRolloverWithNewIndexRequest) DryRun(dryRun bool) DefaultAPIIndicesRolloverWithNewIndexRequest {
	r.dryRun = &dryRun
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesRolloverWithNewIndexRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesRolloverWithNewIndexRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesRolloverWithNewIndexRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesRolloverWithNewIndexRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the newly created rollover index before the operation returns.
func (r DefaultAPIIndicesRolloverWithNewIndexRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIIndicesRolloverWithNewIndexRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r DefaultAPIIndicesRolloverWithNewIndexRequest) Body(body map[string]interface{}) DefaultAPIIndicesRolloverWithNewIndexRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesRolloverWithNewIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesRolloverWithNewIndexExecute(r)
}

/*
IndicesRolloverWithNewIndex Method for IndicesRolloverWithNewIndex

Updates an alias to point to a new index when the existing index
is considered to be too large or too old.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alias The name of the alias to rollover.
 @param newIndex The name of the rollover index.
 @return DefaultAPIIndicesRolloverWithNewIndexRequest
*/
func (a *DefaultAPIService) IndicesRolloverWithNewIndex(ctx context.Context, alias string, newIndex string) DefaultAPIIndicesRolloverWithNewIndexRequest {
	return DefaultAPIIndicesRolloverWithNewIndexRequest{
		ApiService: a,
		ctx: ctx,
		alias: alias,
		newIndex: newIndex,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesRolloverWithNewIndexExecute(r DefaultAPIIndicesRolloverWithNewIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesRolloverWithNewIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{alias}/_rollover/{new_index}"
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"new_index"+"}", url.PathEscape(parameterValueToString(r.newIndex, "newIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dry_run", r.dryRun, "")
	} else {
		var defaultValue bool = false
		r.dryRun = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesSegmentsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	verbose *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesSegmentsRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesSegmentsRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesSegmentsRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesSegmentsRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesSegmentsRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesSegmentsRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Includes detailed memory usage by Lucene.
func (r DefaultAPIIndicesSegmentsRequest) Verbose(verbose bool) DefaultAPIIndicesSegmentsRequest {
	r.verbose = &verbose
	return r
}

func (r DefaultAPIIndicesSegmentsRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesSegmentsExecute(r)
}

/*
IndicesSegments Method for IndicesSegments

Provides low-level information about segments in a Lucene index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesSegmentsRequest
*/
func (a *DefaultAPIService) IndicesSegments(ctx context.Context) DefaultAPIIndicesSegmentsRequest {
	return DefaultAPIIndicesSegmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesSegmentsExecute(r DefaultAPIIndicesSegmentsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesSegments")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesSegmentsWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	verbose *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesSegmentsWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesSegmentsWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesSegmentsWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesSegmentsWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesSegmentsWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesSegmentsWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Includes detailed memory usage by Lucene.
func (r DefaultAPIIndicesSegmentsWithIndexRequest) Verbose(verbose bool) DefaultAPIIndicesSegmentsWithIndexRequest {
	r.verbose = &verbose
	return r
}

func (r DefaultAPIIndicesSegmentsWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesSegmentsWithIndexExecute(r)
}

/*
IndicesSegmentsWithIndex Method for IndicesSegmentsWithIndex

Provides low-level information about segments in a Lucene index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesSegmentsWithIndexRequest
*/
func (a *DefaultAPIService) IndicesSegmentsWithIndex(ctx context.Context, index string) DefaultAPIIndicesSegmentsWithIndexRequest {
	return DefaultAPIIndicesSegmentsWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesSegmentsWithIndexExecute(r DefaultAPIIndicesSegmentsWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesSegmentsWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_segments"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesShardStoresRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	status *[]StatusMember
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Comma-separated list of statuses used to filter on shards to get store information for.
func (r DefaultAPIIndicesShardStoresRequest) Status(status []StatusMember) DefaultAPIIndicesShardStoresRequest {
	r.status = &status
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesShardStoresRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesShardStoresRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesShardStoresRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesShardStoresRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesShardStoresRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesShardStoresRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesShardStoresRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesShardStoresExecute(r)
}

/*
IndicesShardStores Method for IndicesShardStores

Provides store information for shard copies of indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesShardStoresRequest
*/
func (a *DefaultAPIService) IndicesShardStores(ctx context.Context) DefaultAPIIndicesShardStoresRequest {
	return DefaultAPIIndicesShardStoresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesShardStoresExecute(r DefaultAPIIndicesShardStoresRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesShardStores")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_shard_stores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesShardStoresWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	status *[]StatusMember
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Comma-separated list of statuses used to filter on shards to get store information for.
func (r DefaultAPIIndicesShardStoresWithIndexRequest) Status(status []StatusMember) DefaultAPIIndicesShardStoresWithIndexRequest {
	r.status = &status
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesShardStoresWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesShardStoresWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesShardStoresWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesShardStoresWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesShardStoresWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesShardStoresWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPIIndicesShardStoresWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesShardStoresWithIndexExecute(r)
}

/*
IndicesShardStoresWithIndex Method for IndicesShardStoresWithIndex

Provides store information for shard copies of indices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesShardStoresWithIndexRequest
*/
func (a *DefaultAPIService) IndicesShardStoresWithIndex(ctx context.Context, index string) DefaultAPIIndicesShardStoresWithIndexRequest {
	return DefaultAPIIndicesShardStoresWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesShardStoresWithIndexExecute(r DefaultAPIIndicesShardStoresWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesShardStoresWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_shard_stores"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesShrinkPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	target string
	copySettings *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// whether or not to copy settings from the source index.
func (r DefaultAPIIndicesShrinkPostRequest) CopySettings(copySettings bool) DefaultAPIIndicesShrinkPostRequest {
	r.copySettings = &copySettings
	return r
}

// Operation timeout.
func (r DefaultAPIIndicesShrinkPostRequest) Timeout(timeout string) DefaultAPIIndicesShrinkPostRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesShrinkPostRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesShrinkPostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesShrinkPostRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesShrinkPostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the shrunken index before the operation returns.
func (r DefaultAPIIndicesShrinkPostRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIIndicesShrinkPostRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r DefaultAPIIndicesShrinkPostRequest) Body(body map[string]interface{}) DefaultAPIIndicesShrinkPostRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesShrinkPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesShrinkPostExecute(r)
}

/*
IndicesShrinkPost Method for IndicesShrinkPost

Allow to shrink an existing index into a new index with fewer primary shards.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the source index to shrink.
 @param target The name of the target index.
 @return DefaultAPIIndicesShrinkPostRequest
*/
func (a *DefaultAPIService) IndicesShrinkPost(ctx context.Context, index string, target string) DefaultAPIIndicesShrinkPostRequest {
	return DefaultAPIIndicesShrinkPostRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		target: target,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesShrinkPostExecute(r DefaultAPIIndicesShrinkPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesShrinkPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_shrink/{target}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", url.PathEscape(parameterValueToString(r.target, "target")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.copySettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copy_settings", r.copySettings, "")
	} else {
		var defaultValue bool = false
		r.copySettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesShrinkPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	target string
	copySettings *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// whether or not to copy settings from the source index.
func (r DefaultAPIIndicesShrinkPutRequest) CopySettings(copySettings bool) DefaultAPIIndicesShrinkPutRequest {
	r.copySettings = &copySettings
	return r
}

// Operation timeout.
func (r DefaultAPIIndicesShrinkPutRequest) Timeout(timeout string) DefaultAPIIndicesShrinkPutRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesShrinkPutRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesShrinkPutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesShrinkPutRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesShrinkPutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the shrunken index before the operation returns.
func (r DefaultAPIIndicesShrinkPutRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIIndicesShrinkPutRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r DefaultAPIIndicesShrinkPutRequest) Body(body map[string]interface{}) DefaultAPIIndicesShrinkPutRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesShrinkPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesShrinkPutExecute(r)
}

/*
IndicesShrinkPut Method for IndicesShrinkPut

Allow to shrink an existing index into a new index with fewer primary shards.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the source index to shrink.
 @param target The name of the target index.
 @return DefaultAPIIndicesShrinkPutRequest
*/
func (a *DefaultAPIService) IndicesShrinkPut(ctx context.Context, index string, target string) DefaultAPIIndicesShrinkPutRequest {
	return DefaultAPIIndicesShrinkPutRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		target: target,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesShrinkPutExecute(r DefaultAPIIndicesShrinkPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesShrinkPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_shrink/{target}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", url.PathEscape(parameterValueToString(r.target, "target")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.copySettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copy_settings", r.copySettings, "")
	} else {
		var defaultValue bool = false
		r.copySettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesSimulateIndexTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	create *bool
	cause *string
	masterTimeout *string
	clusterManagerTimeout *string
	body *map[string]interface{}
}

// Whether the index template we optionally defined in the body should only be dry-run added if new or can also replace an existing one.
func (r DefaultAPIIndicesSimulateIndexTemplateRequest) Create(create bool) DefaultAPIIndicesSimulateIndexTemplateRequest {
	r.create = &create
	return r
}

// User defined reason for dry-run creating the new template for simulation purposes.
func (r DefaultAPIIndicesSimulateIndexTemplateRequest) Cause(cause string) DefaultAPIIndicesSimulateIndexTemplateRequest {
	r.cause = &cause
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesSimulateIndexTemplateRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesSimulateIndexTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesSimulateIndexTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesSimulateIndexTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesSimulateIndexTemplateRequest) Body(body map[string]interface{}) DefaultAPIIndicesSimulateIndexTemplateRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesSimulateIndexTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesSimulateIndexTemplateExecute(r)
}

/*
IndicesSimulateIndexTemplate Method for IndicesSimulateIndexTemplate

Simulate matching the given index name against the index templates in the system.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the index (it must be a concrete index name).
 @return DefaultAPIIndicesSimulateIndexTemplateRequest
*/
func (a *DefaultAPIService) IndicesSimulateIndexTemplate(ctx context.Context, name string) DefaultAPIIndicesSimulateIndexTemplateRequest {
	return DefaultAPIIndicesSimulateIndexTemplateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesSimulateIndexTemplateExecute(r DefaultAPIIndicesSimulateIndexTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesSimulateIndexTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/_simulate_index/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.cause != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cause", r.cause, "")
	} else {
		var defaultValue string = "false"
		r.cause = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesSimulateTemplateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	create *bool
	cause *string
	masterTimeout *string
	clusterManagerTimeout *string
	body *map[string]interface{}
}

// Whether the index template we optionally defined in the body should only be dry-run added if new or can also replace an existing one.
func (r DefaultAPIIndicesSimulateTemplateRequest) Create(create bool) DefaultAPIIndicesSimulateTemplateRequest {
	r.create = &create
	return r
}

// User defined reason for dry-run creating the new template for simulation purposes.
func (r DefaultAPIIndicesSimulateTemplateRequest) Cause(cause string) DefaultAPIIndicesSimulateTemplateRequest {
	r.cause = &cause
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesSimulateTemplateRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesSimulateTemplateRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesSimulateTemplateRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesSimulateTemplateRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesSimulateTemplateRequest) Body(body map[string]interface{}) DefaultAPIIndicesSimulateTemplateRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesSimulateTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesSimulateTemplateExecute(r)
}

/*
IndicesSimulateTemplate Method for IndicesSimulateTemplate

Simulate resolving the given template name or body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesSimulateTemplateRequest
*/
func (a *DefaultAPIService) IndicesSimulateTemplate(ctx context.Context) DefaultAPIIndicesSimulateTemplateRequest {
	return DefaultAPIIndicesSimulateTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesSimulateTemplateExecute(r DefaultAPIIndicesSimulateTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesSimulateTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/_simulate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.cause != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cause", r.cause, "")
	} else {
		var defaultValue string = "false"
		r.cause = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesSimulateTemplateWithNameRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	create *bool
	cause *string
	masterTimeout *string
	clusterManagerTimeout *string
	body *map[string]interface{}
}

// Whether the index template we optionally defined in the body should only be dry-run added if new or can also replace an existing one.
func (r DefaultAPIIndicesSimulateTemplateWithNameRequest) Create(create bool) DefaultAPIIndicesSimulateTemplateWithNameRequest {
	r.create = &create
	return r
}

// User defined reason for dry-run creating the new template for simulation purposes.
func (r DefaultAPIIndicesSimulateTemplateWithNameRequest) Cause(cause string) DefaultAPIIndicesSimulateTemplateWithNameRequest {
	r.cause = &cause
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesSimulateTemplateWithNameRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesSimulateTemplateWithNameRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesSimulateTemplateWithNameRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesSimulateTemplateWithNameRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesSimulateTemplateWithNameRequest) Body(body map[string]interface{}) DefaultAPIIndicesSimulateTemplateWithNameRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesSimulateTemplateWithNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesSimulateTemplateWithNameExecute(r)
}

/*
IndicesSimulateTemplateWithName Method for IndicesSimulateTemplateWithName

Simulate resolving the given template name or body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the template.
 @return DefaultAPIIndicesSimulateTemplateWithNameRequest
*/
func (a *DefaultAPIService) IndicesSimulateTemplateWithName(ctx context.Context, name string) DefaultAPIIndicesSimulateTemplateWithNameRequest {
	return DefaultAPIIndicesSimulateTemplateWithNameRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesSimulateTemplateWithNameExecute(r DefaultAPIIndicesSimulateTemplateWithNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesSimulateTemplateWithName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_index_template/_simulate/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.create != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create", r.create, "")
	} else {
		var defaultValue bool = false
		r.create = &defaultValue
	}
	if r.cause != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cause", r.cause, "")
	} else {
		var defaultValue string = "false"
		r.cause = &defaultValue
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesSplitPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	target string
	copySettings *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// whether or not to copy settings from the source index.
func (r DefaultAPIIndicesSplitPostRequest) CopySettings(copySettings bool) DefaultAPIIndicesSplitPostRequest {
	r.copySettings = &copySettings
	return r
}

// Operation timeout.
func (r DefaultAPIIndicesSplitPostRequest) Timeout(timeout string) DefaultAPIIndicesSplitPostRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesSplitPostRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesSplitPostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesSplitPostRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesSplitPostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the shrunken index before the operation returns.
func (r DefaultAPIIndicesSplitPostRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIIndicesSplitPostRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r DefaultAPIIndicesSplitPostRequest) Body(body map[string]interface{}) DefaultAPIIndicesSplitPostRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesSplitPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesSplitPostExecute(r)
}

/*
IndicesSplitPost Method for IndicesSplitPost

Allows you to split an existing index into a new index with more primary shards.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the source index to split.
 @param target The name of the target index.
 @return DefaultAPIIndicesSplitPostRequest
*/
func (a *DefaultAPIService) IndicesSplitPost(ctx context.Context, index string, target string) DefaultAPIIndicesSplitPostRequest {
	return DefaultAPIIndicesSplitPostRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		target: target,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesSplitPostExecute(r DefaultAPIIndicesSplitPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesSplitPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_split/{target}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", url.PathEscape(parameterValueToString(r.target, "target")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.copySettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copy_settings", r.copySettings, "")
	} else {
		var defaultValue bool = false
		r.copySettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesSplitPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	target string
	copySettings *bool
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForActiveShards *string
	body *map[string]interface{}
}

// whether or not to copy settings from the source index.
func (r DefaultAPIIndicesSplitPutRequest) CopySettings(copySettings bool) DefaultAPIIndicesSplitPutRequest {
	r.copySettings = &copySettings
	return r
}

// Operation timeout.
func (r DefaultAPIIndicesSplitPutRequest) Timeout(timeout string) DefaultAPIIndicesSplitPutRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesSplitPutRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesSplitPutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesSplitPutRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesSplitPutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Set the number of active shards to wait for on the shrunken index before the operation returns.
func (r DefaultAPIIndicesSplitPutRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIIndicesSplitPutRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

func (r DefaultAPIIndicesSplitPutRequest) Body(body map[string]interface{}) DefaultAPIIndicesSplitPutRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesSplitPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesSplitPutExecute(r)
}

/*
IndicesSplitPut Method for IndicesSplitPut

Allows you to split an existing index into a new index with more primary shards.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The name of the source index to split.
 @param target The name of the target index.
 @return DefaultAPIIndicesSplitPutRequest
*/
func (a *DefaultAPIService) IndicesSplitPut(ctx context.Context, index string, target string) DefaultAPIIndicesSplitPutRequest {
	return DefaultAPIIndicesSplitPutRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		target: target,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesSplitPutExecute(r DefaultAPIIndicesSplitPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesSplitPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_split/{target}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", url.PathEscape(parameterValueToString(r.target, "target")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.copySettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copy_settings", r.copySettings, "")
	} else {
		var defaultValue bool = false
		r.copySettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesStatsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *IndiciesStatLevel
	includeSegmentFileSizes *bool
	includeUnloadedSegments *bool
	expandWildcards *ExpandWildcards
	forbidClosedIndices *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r DefaultAPIIndicesStatsRequest) CompletionFields(completionFields []string) DefaultAPIIndicesStatsRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r DefaultAPIIndicesStatsRequest) FielddataFields(fielddataFields []string) DefaultAPIIndicesStatsRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r DefaultAPIIndicesStatsRequest) Fields(fields []string) DefaultAPIIndicesStatsRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r DefaultAPIIndicesStatsRequest) Groups(groups []string) DefaultAPIIndicesStatsRequest {
	r.groups = &groups
	return r
}

// Return stats aggregated at cluster, index or shard level.
func (r DefaultAPIIndicesStatsRequest) Level(level IndiciesStatLevel) DefaultAPIIndicesStatsRequest {
	r.level = &level
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r DefaultAPIIndicesStatsRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) DefaultAPIIndicesStatsRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

// If set to true segment stats will include stats for segments that are not currently loaded into memory.
func (r DefaultAPIIndicesStatsRequest) IncludeUnloadedSegments(includeUnloadedSegments bool) DefaultAPIIndicesStatsRequest {
	r.includeUnloadedSegments = &includeUnloadedSegments
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesStatsRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesStatsRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
func (r DefaultAPIIndicesStatsRequest) ForbidClosedIndices(forbidClosedIndices bool) DefaultAPIIndicesStatsRequest {
	r.forbidClosedIndices = &forbidClosedIndices
	return r
}

func (r DefaultAPIIndicesStatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesStatsExecute(r)
}

/*
IndicesStats Method for IndicesStats

Provides statistics on operations happening in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesStatsRequest
*/
func (a *DefaultAPIService) IndicesStats(ctx context.Context) DefaultAPIIndicesStatsRequest {
	return DefaultAPIIndicesStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesStatsExecute(r DefaultAPIIndicesStatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesStats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	if r.includeUnloadedSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unloaded_segments", r.includeUnloadedSegments, "")
	} else {
		var defaultValue bool = false
		r.includeUnloadedSegments = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.forbidClosedIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forbid_closed_indices", r.forbidClosedIndices, "")
	} else {
		var defaultValue bool = true
		r.forbidClosedIndices = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesStatsWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *IndiciesStatLevel
	includeSegmentFileSizes *bool
	includeUnloadedSegments *bool
	expandWildcards *ExpandWildcards
	forbidClosedIndices *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r DefaultAPIIndicesStatsWithIndexRequest) CompletionFields(completionFields []string) DefaultAPIIndicesStatsWithIndexRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r DefaultAPIIndicesStatsWithIndexRequest) FielddataFields(fielddataFields []string) DefaultAPIIndicesStatsWithIndexRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r DefaultAPIIndicesStatsWithIndexRequest) Fields(fields []string) DefaultAPIIndicesStatsWithIndexRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r DefaultAPIIndicesStatsWithIndexRequest) Groups(groups []string) DefaultAPIIndicesStatsWithIndexRequest {
	r.groups = &groups
	return r
}

// Return stats aggregated at cluster, index or shard level.
func (r DefaultAPIIndicesStatsWithIndexRequest) Level(level IndiciesStatLevel) DefaultAPIIndicesStatsWithIndexRequest {
	r.level = &level
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r DefaultAPIIndicesStatsWithIndexRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) DefaultAPIIndicesStatsWithIndexRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

// If set to true segment stats will include stats for segments that are not currently loaded into memory.
func (r DefaultAPIIndicesStatsWithIndexRequest) IncludeUnloadedSegments(includeUnloadedSegments bool) DefaultAPIIndicesStatsWithIndexRequest {
	r.includeUnloadedSegments = &includeUnloadedSegments
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesStatsWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesStatsWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
func (r DefaultAPIIndicesStatsWithIndexRequest) ForbidClosedIndices(forbidClosedIndices bool) DefaultAPIIndicesStatsWithIndexRequest {
	r.forbidClosedIndices = &forbidClosedIndices
	return r
}

func (r DefaultAPIIndicesStatsWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesStatsWithIndexExecute(r)
}

/*
IndicesStatsWithIndex Method for IndicesStatsWithIndex

Provides statistics on operations happening in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesStatsWithIndexRequest
*/
func (a *DefaultAPIService) IndicesStatsWithIndex(ctx context.Context, index string) DefaultAPIIndicesStatsWithIndexRequest {
	return DefaultAPIIndicesStatsWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesStatsWithIndexExecute(r DefaultAPIIndicesStatsWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesStatsWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_stats"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	if r.includeUnloadedSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unloaded_segments", r.includeUnloadedSegments, "")
	} else {
		var defaultValue bool = false
		r.includeUnloadedSegments = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.forbidClosedIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forbid_closed_indices", r.forbidClosedIndices, "")
	} else {
		var defaultValue bool = true
		r.forbidClosedIndices = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesStatsWithIndexMetricRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	metric string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *IndiciesStatLevel
	includeSegmentFileSizes *bool
	includeUnloadedSegments *bool
	expandWildcards *ExpandWildcards
	forbidClosedIndices *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r DefaultAPIIndicesStatsWithIndexMetricRequest) CompletionFields(completionFields []string) DefaultAPIIndicesStatsWithIndexMetricRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r DefaultAPIIndicesStatsWithIndexMetricRequest) FielddataFields(fielddataFields []string) DefaultAPIIndicesStatsWithIndexMetricRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r DefaultAPIIndicesStatsWithIndexMetricRequest) Fields(fields []string) DefaultAPIIndicesStatsWithIndexMetricRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r DefaultAPIIndicesStatsWithIndexMetricRequest) Groups(groups []string) DefaultAPIIndicesStatsWithIndexMetricRequest {
	r.groups = &groups
	return r
}

// Return stats aggregated at cluster, index or shard level.
func (r DefaultAPIIndicesStatsWithIndexMetricRequest) Level(level IndiciesStatLevel) DefaultAPIIndicesStatsWithIndexMetricRequest {
	r.level = &level
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r DefaultAPIIndicesStatsWithIndexMetricRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) DefaultAPIIndicesStatsWithIndexMetricRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

// If set to true segment stats will include stats for segments that are not currently loaded into memory.
func (r DefaultAPIIndicesStatsWithIndexMetricRequest) IncludeUnloadedSegments(includeUnloadedSegments bool) DefaultAPIIndicesStatsWithIndexMetricRequest {
	r.includeUnloadedSegments = &includeUnloadedSegments
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesStatsWithIndexMetricRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesStatsWithIndexMetricRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
func (r DefaultAPIIndicesStatsWithIndexMetricRequest) ForbidClosedIndices(forbidClosedIndices bool) DefaultAPIIndicesStatsWithIndexMetricRequest {
	r.forbidClosedIndices = &forbidClosedIndices
	return r
}

func (r DefaultAPIIndicesStatsWithIndexMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesStatsWithIndexMetricExecute(r)
}

/*
IndicesStatsWithIndexMetric Method for IndicesStatsWithIndexMetric

Provides statistics on operations happening in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @param metric Limit the information returned the specific metrics.
 @return DefaultAPIIndicesStatsWithIndexMetricRequest
*/
func (a *DefaultAPIService) IndicesStatsWithIndexMetric(ctx context.Context, index string, metric string) DefaultAPIIndicesStatsWithIndexMetricRequest {
	return DefaultAPIIndicesStatsWithIndexMetricRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		metric: metric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesStatsWithIndexMetricExecute(r DefaultAPIIndicesStatsWithIndexMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesStatsWithIndexMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_stats/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	if r.includeUnloadedSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unloaded_segments", r.includeUnloadedSegments, "")
	} else {
		var defaultValue bool = false
		r.includeUnloadedSegments = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.forbidClosedIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forbid_closed_indices", r.forbidClosedIndices, "")
	} else {
		var defaultValue bool = true
		r.forbidClosedIndices = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesStatsWithMetricRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *IndiciesStatLevel
	includeSegmentFileSizes *bool
	includeUnloadedSegments *bool
	expandWildcards *ExpandWildcards
	forbidClosedIndices *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r DefaultAPIIndicesStatsWithMetricRequest) CompletionFields(completionFields []string) DefaultAPIIndicesStatsWithMetricRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r DefaultAPIIndicesStatsWithMetricRequest) FielddataFields(fielddataFields []string) DefaultAPIIndicesStatsWithMetricRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r DefaultAPIIndicesStatsWithMetricRequest) Fields(fields []string) DefaultAPIIndicesStatsWithMetricRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r DefaultAPIIndicesStatsWithMetricRequest) Groups(groups []string) DefaultAPIIndicesStatsWithMetricRequest {
	r.groups = &groups
	return r
}

// Return stats aggregated at cluster, index or shard level.
func (r DefaultAPIIndicesStatsWithMetricRequest) Level(level IndiciesStatLevel) DefaultAPIIndicesStatsWithMetricRequest {
	r.level = &level
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r DefaultAPIIndicesStatsWithMetricRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) DefaultAPIIndicesStatsWithMetricRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

// If set to true segment stats will include stats for segments that are not currently loaded into memory.
func (r DefaultAPIIndicesStatsWithMetricRequest) IncludeUnloadedSegments(includeUnloadedSegments bool) DefaultAPIIndicesStatsWithMetricRequest {
	r.includeUnloadedSegments = &includeUnloadedSegments
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesStatsWithMetricRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesStatsWithMetricRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
func (r DefaultAPIIndicesStatsWithMetricRequest) ForbidClosedIndices(forbidClosedIndices bool) DefaultAPIIndicesStatsWithMetricRequest {
	r.forbidClosedIndices = &forbidClosedIndices
	return r
}

func (r DefaultAPIIndicesStatsWithMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesStatsWithMetricExecute(r)
}

/*
IndicesStatsWithMetric Method for IndicesStatsWithMetric

Provides statistics on operations happening in an index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned the specific metrics.
 @return DefaultAPIIndicesStatsWithMetricRequest
*/
func (a *DefaultAPIService) IndicesStatsWithMetric(ctx context.Context, metric string) DefaultAPIIndicesStatsWithMetricRequest {
	return DefaultAPIIndicesStatsWithMetricRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesStatsWithMetricExecute(r DefaultAPIIndicesStatsWithMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesStatsWithMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_stats/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	if r.includeUnloadedSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unloaded_segments", r.includeUnloadedSegments, "")
	} else {
		var defaultValue bool = false
		r.includeUnloadedSegments = &defaultValue
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.forbidClosedIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forbid_closed_indices", r.forbidClosedIndices, "")
	} else {
		var defaultValue bool = true
		r.forbidClosedIndices = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesUpdateAliasesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	indicesUpdateAliasesBodyParams *IndicesUpdateAliasesBodyParams
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r DefaultAPIIndicesUpdateAliasesRequest) IndicesUpdateAliasesBodyParams(indicesUpdateAliasesBodyParams IndicesUpdateAliasesBodyParams) DefaultAPIIndicesUpdateAliasesRequest {
	r.indicesUpdateAliasesBodyParams = &indicesUpdateAliasesBodyParams
	return r
}

// Operation timeout.
func (r DefaultAPIIndicesUpdateAliasesRequest) Timeout(timeout string) DefaultAPIIndicesUpdateAliasesRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIndicesUpdateAliasesRequest) MasterTimeout(masterTimeout string) DefaultAPIIndicesUpdateAliasesRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIndicesUpdateAliasesRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIndicesUpdateAliasesRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIndicesUpdateAliasesRequest) Execute() (*IndicesUpdateAliasesResponseContent, *http.Response, error) {
	return r.ApiService.IndicesUpdateAliasesExecute(r)
}

/*
IndicesUpdateAliases Method for IndicesUpdateAliases

Updates index aliases.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesUpdateAliasesRequest
*/
func (a *DefaultAPIService) IndicesUpdateAliases(ctx context.Context) DefaultAPIIndicesUpdateAliasesRequest {
	return DefaultAPIIndicesUpdateAliasesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IndicesUpdateAliasesResponseContent
func (a *DefaultAPIService) IndicesUpdateAliasesExecute(r DefaultAPIIndicesUpdateAliasesRequest) (*IndicesUpdateAliasesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndicesUpdateAliasesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesUpdateAliases")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_aliases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.indicesUpdateAliasesBodyParams == nil {
		return localVarReturnValue, nil, reportError("indicesUpdateAliasesBodyParams is required and must be specified")
	}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.indicesUpdateAliasesBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIIndicesUpgradeRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	ignoreUnavailable *bool
	waitForCompletion *bool
	onlyAncientSegments *bool
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesUpgradeRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesUpgradeRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesUpgradeRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesUpgradeRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesUpgradeRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesUpgradeRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Should this request wait until the operation has completed before returning.
func (r DefaultAPIIndicesUpgradeRequest) WaitForCompletion(waitForCompletion bool) DefaultAPIIndicesUpgradeRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

// If true, only ancient (an older Lucene major release) segments will be upgraded.
func (r DefaultAPIIndicesUpgradeRequest) OnlyAncientSegments(onlyAncientSegments bool) DefaultAPIIndicesUpgradeRequest {
	r.onlyAncientSegments = &onlyAncientSegments
	return r
}

func (r DefaultAPIIndicesUpgradeRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesUpgradeExecute(r)
}

/*
IndicesUpgrade Method for IndicesUpgrade

The _upgrade API is no longer useful and will be removed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesUpgradeRequest
*/
func (a *DefaultAPIService) IndicesUpgrade(ctx context.Context) DefaultAPIIndicesUpgradeRequest {
	return DefaultAPIIndicesUpgradeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesUpgradeExecute(r DefaultAPIIndicesUpgradeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesUpgrade")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_upgrade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	if r.onlyAncientSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_ancient_segments", r.onlyAncientSegments, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesUpgradeWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	ignoreUnavailable *bool
	waitForCompletion *bool
	onlyAncientSegments *bool
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesUpgradeWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesUpgradeWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesUpgradeWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesUpgradeWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesUpgradeWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesUpgradeWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Should this request wait until the operation has completed before returning.
func (r DefaultAPIIndicesUpgradeWithIndexRequest) WaitForCompletion(waitForCompletion bool) DefaultAPIIndicesUpgradeWithIndexRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

// If true, only ancient (an older Lucene major release) segments will be upgraded.
func (r DefaultAPIIndicesUpgradeWithIndexRequest) OnlyAncientSegments(onlyAncientSegments bool) DefaultAPIIndicesUpgradeWithIndexRequest {
	r.onlyAncientSegments = &onlyAncientSegments
	return r
}

func (r DefaultAPIIndicesUpgradeWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesUpgradeWithIndexExecute(r)
}

/*
IndicesUpgradeWithIndex Method for IndicesUpgradeWithIndex

The _upgrade API is no longer useful and will be removed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesUpgradeWithIndexRequest
*/
func (a *DefaultAPIService) IndicesUpgradeWithIndex(ctx context.Context, index string) DefaultAPIIndicesUpgradeWithIndexRequest {
	return DefaultAPIIndicesUpgradeWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesUpgradeWithIndexExecute(r DefaultAPIIndicesUpgradeWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesUpgradeWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_upgrade"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	if r.onlyAncientSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_ancient_segments", r.onlyAncientSegments, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesValidateQueryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	explain *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	rewrite *bool
	allShards *bool
}

// Return detailed information about the error.
func (r DefaultAPIIndicesValidateQueryGetRequest) Explain(explain bool) DefaultAPIIndicesValidateQueryGetRequest {
	r.explain = &explain
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesValidateQueryGetRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesValidateQueryGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesValidateQueryGetRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesValidateQueryGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesValidateQueryGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesValidateQueryGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPIIndicesValidateQueryGetRequest) Q(q string) DefaultAPIIndicesValidateQueryGetRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r DefaultAPIIndicesValidateQueryGetRequest) Analyzer(analyzer string) DefaultAPIIndicesValidateQueryGetRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r DefaultAPIIndicesValidateQueryGetRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPIIndicesValidateQueryGetRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPIIndicesValidateQueryGetRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPIIndicesValidateQueryGetRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r DefaultAPIIndicesValidateQueryGetRequest) Df(df string) DefaultAPIIndicesValidateQueryGetRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPIIndicesValidateQueryGetRequest) Lenient(lenient bool) DefaultAPIIndicesValidateQueryGetRequest {
	r.lenient = &lenient
	return r
}

// Provide a more detailed explanation showing the actual Lucene query that will be executed.
func (r DefaultAPIIndicesValidateQueryGetRequest) Rewrite(rewrite bool) DefaultAPIIndicesValidateQueryGetRequest {
	r.rewrite = &rewrite
	return r
}

// Execute validation on all shards instead of one random shard per index.
func (r DefaultAPIIndicesValidateQueryGetRequest) AllShards(allShards bool) DefaultAPIIndicesValidateQueryGetRequest {
	r.allShards = &allShards
	return r
}

func (r DefaultAPIIndicesValidateQueryGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesValidateQueryGetExecute(r)
}

/*
IndicesValidateQueryGet Method for IndicesValidateQueryGet

Allows a user to validate a potentially expensive query without executing it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesValidateQueryGetRequest
*/
func (a *DefaultAPIService) IndicesValidateQueryGet(ctx context.Context) DefaultAPIIndicesValidateQueryGetRequest {
	return DefaultAPIIndicesValidateQueryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesValidateQueryGetExecute(r DefaultAPIIndicesValidateQueryGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesValidateQueryGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_validate/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.rewrite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rewrite", r.rewrite, "")
	}
	if r.allShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "all_shards", r.allShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesValidateQueryGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	explain *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	rewrite *bool
	allShards *bool
}

// Return detailed information about the error.
func (r DefaultAPIIndicesValidateQueryGetWithIndexRequest) Explain(explain bool) DefaultAPIIndicesValidateQueryGetWithIndexRequest {
	r.explain = &explain
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesValidateQueryGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesValidateQueryGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesValidateQueryGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesValidateQueryGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesValidateQueryGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesValidateQueryGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPIIndicesValidateQueryGetWithIndexRequest) Q(q string) DefaultAPIIndicesValidateQueryGetWithIndexRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r DefaultAPIIndicesValidateQueryGetWithIndexRequest) Analyzer(analyzer string) DefaultAPIIndicesValidateQueryGetWithIndexRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r DefaultAPIIndicesValidateQueryGetWithIndexRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPIIndicesValidateQueryGetWithIndexRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPIIndicesValidateQueryGetWithIndexRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPIIndicesValidateQueryGetWithIndexRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r DefaultAPIIndicesValidateQueryGetWithIndexRequest) Df(df string) DefaultAPIIndicesValidateQueryGetWithIndexRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPIIndicesValidateQueryGetWithIndexRequest) Lenient(lenient bool) DefaultAPIIndicesValidateQueryGetWithIndexRequest {
	r.lenient = &lenient
	return r
}

// Provide a more detailed explanation showing the actual Lucene query that will be executed.
func (r DefaultAPIIndicesValidateQueryGetWithIndexRequest) Rewrite(rewrite bool) DefaultAPIIndicesValidateQueryGetWithIndexRequest {
	r.rewrite = &rewrite
	return r
}

// Execute validation on all shards instead of one random shard per index.
func (r DefaultAPIIndicesValidateQueryGetWithIndexRequest) AllShards(allShards bool) DefaultAPIIndicesValidateQueryGetWithIndexRequest {
	r.allShards = &allShards
	return r
}

func (r DefaultAPIIndicesValidateQueryGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesValidateQueryGetWithIndexExecute(r)
}

/*
IndicesValidateQueryGetWithIndex Method for IndicesValidateQueryGetWithIndex

Allows a user to validate a potentially expensive query without executing it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesValidateQueryGetWithIndexRequest
*/
func (a *DefaultAPIService) IndicesValidateQueryGetWithIndex(ctx context.Context, index string) DefaultAPIIndicesValidateQueryGetWithIndexRequest {
	return DefaultAPIIndicesValidateQueryGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesValidateQueryGetWithIndexExecute(r DefaultAPIIndicesValidateQueryGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesValidateQueryGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_validate/query"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.rewrite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rewrite", r.rewrite, "")
	}
	if r.allShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "all_shards", r.allShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesValidateQueryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	explain *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	rewrite *bool
	allShards *bool
	body *map[string]interface{}
}

// Return detailed information about the error.
func (r DefaultAPIIndicesValidateQueryPostRequest) Explain(explain bool) DefaultAPIIndicesValidateQueryPostRequest {
	r.explain = &explain
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesValidateQueryPostRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesValidateQueryPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesValidateQueryPostRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesValidateQueryPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesValidateQueryPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesValidateQueryPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPIIndicesValidateQueryPostRequest) Q(q string) DefaultAPIIndicesValidateQueryPostRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r DefaultAPIIndicesValidateQueryPostRequest) Analyzer(analyzer string) DefaultAPIIndicesValidateQueryPostRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r DefaultAPIIndicesValidateQueryPostRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPIIndicesValidateQueryPostRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPIIndicesValidateQueryPostRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPIIndicesValidateQueryPostRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r DefaultAPIIndicesValidateQueryPostRequest) Df(df string) DefaultAPIIndicesValidateQueryPostRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPIIndicesValidateQueryPostRequest) Lenient(lenient bool) DefaultAPIIndicesValidateQueryPostRequest {
	r.lenient = &lenient
	return r
}

// Provide a more detailed explanation showing the actual Lucene query that will be executed.
func (r DefaultAPIIndicesValidateQueryPostRequest) Rewrite(rewrite bool) DefaultAPIIndicesValidateQueryPostRequest {
	r.rewrite = &rewrite
	return r
}

// Execute validation on all shards instead of one random shard per index.
func (r DefaultAPIIndicesValidateQueryPostRequest) AllShards(allShards bool) DefaultAPIIndicesValidateQueryPostRequest {
	r.allShards = &allShards
	return r
}

func (r DefaultAPIIndicesValidateQueryPostRequest) Body(body map[string]interface{}) DefaultAPIIndicesValidateQueryPostRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesValidateQueryPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesValidateQueryPostExecute(r)
}

/*
IndicesValidateQueryPost Method for IndicesValidateQueryPost

Allows a user to validate a potentially expensive query without executing it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIndicesValidateQueryPostRequest
*/
func (a *DefaultAPIService) IndicesValidateQueryPost(ctx context.Context) DefaultAPIIndicesValidateQueryPostRequest {
	return DefaultAPIIndicesValidateQueryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesValidateQueryPostExecute(r DefaultAPIIndicesValidateQueryPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesValidateQueryPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_validate/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.rewrite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rewrite", r.rewrite, "")
	}
	if r.allShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "all_shards", r.allShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIndicesValidateQueryPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	explain *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	q *string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	lenient *bool
	rewrite *bool
	allShards *bool
	body *map[string]interface{}
}

// Return detailed information about the error.
func (r DefaultAPIIndicesValidateQueryPostWithIndexRequest) Explain(explain bool) DefaultAPIIndicesValidateQueryPostWithIndexRequest {
	r.explain = &explain
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIIndicesValidateQueryPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIIndicesValidateQueryPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIIndicesValidateQueryPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIIndicesValidateQueryPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIIndicesValidateQueryPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIIndicesValidateQueryPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPIIndicesValidateQueryPostWithIndexRequest) Q(q string) DefaultAPIIndicesValidateQueryPostWithIndexRequest {
	r.q = &q
	return r
}

// The analyzer to use for the query string.
func (r DefaultAPIIndicesValidateQueryPostWithIndexRequest) Analyzer(analyzer string) DefaultAPIIndicesValidateQueryPostWithIndexRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r DefaultAPIIndicesValidateQueryPostWithIndexRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPIIndicesValidateQueryPostWithIndexRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPIIndicesValidateQueryPostWithIndexRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPIIndicesValidateQueryPostWithIndexRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r DefaultAPIIndicesValidateQueryPostWithIndexRequest) Df(df string) DefaultAPIIndicesValidateQueryPostWithIndexRequest {
	r.df = &df
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPIIndicesValidateQueryPostWithIndexRequest) Lenient(lenient bool) DefaultAPIIndicesValidateQueryPostWithIndexRequest {
	r.lenient = &lenient
	return r
}

// Provide a more detailed explanation showing the actual Lucene query that will be executed.
func (r DefaultAPIIndicesValidateQueryPostWithIndexRequest) Rewrite(rewrite bool) DefaultAPIIndicesValidateQueryPostWithIndexRequest {
	r.rewrite = &rewrite
	return r
}

// Execute validation on all shards instead of one random shard per index.
func (r DefaultAPIIndicesValidateQueryPostWithIndexRequest) AllShards(allShards bool) DefaultAPIIndicesValidateQueryPostWithIndexRequest {
	r.allShards = &allShards
	return r
}

func (r DefaultAPIIndicesValidateQueryPostWithIndexRequest) Body(body map[string]interface{}) DefaultAPIIndicesValidateQueryPostWithIndexRequest {
	r.body = &body
	return r
}

func (r DefaultAPIIndicesValidateQueryPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.IndicesValidateQueryPostWithIndexExecute(r)
}

/*
IndicesValidateQueryPostWithIndex Method for IndicesValidateQueryPostWithIndex

Allows a user to validate a potentially expensive query without executing it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIIndicesValidateQueryPostWithIndexRequest
*/
func (a *DefaultAPIService) IndicesValidateQueryPostWithIndex(ctx context.Context, index string) DefaultAPIIndicesValidateQueryPostWithIndexRequest {
	return DefaultAPIIndicesValidateQueryPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IndicesValidateQueryPostWithIndexExecute(r DefaultAPIIndicesValidateQueryPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IndicesValidateQueryPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_validate/query"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.rewrite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rewrite", r.rewrite, "")
	}
	if r.allShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "all_shards", r.allShards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIInfoRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIInfoRequest) Execute() (*InfoResponseContent, *http.Response, error) {
	return r.ApiService.InfoExecute(r)
}

/*
Info Method for Info

Returns basic information about the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIInfoRequest
*/
func (a *DefaultAPIService) Info(ctx context.Context) DefaultAPIInfoRequest {
	return DefaultAPIInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InfoResponseContent
func (a *DefaultAPIService) InfoExecute(r DefaultAPIInfoRequest) (*InfoResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InfoResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Info")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIIngestDeletePipelineRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
}

// Operation timeout for connection to master node.
func (r DefaultAPIIngestDeletePipelineRequest) MasterTimeout(masterTimeout string) DefaultAPIIngestDeletePipelineRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIngestDeletePipelineRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIngestDeletePipelineRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r DefaultAPIIngestDeletePipelineRequest) Timeout(timeout string) DefaultAPIIngestDeletePipelineRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPIIngestDeletePipelineRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestDeletePipelineExecute(r)
}

/*
IngestDeletePipeline Method for IngestDeletePipeline

Deletes a pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Pipeline ID.
 @return DefaultAPIIngestDeletePipelineRequest
*/
func (a *DefaultAPIService) IngestDeletePipeline(ctx context.Context, id string) DefaultAPIIngestDeletePipelineRequest {
	return DefaultAPIIngestDeletePipelineRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestDeletePipelineExecute(r DefaultAPIIngestDeletePipelineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestDeletePipeline")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIngestGetPipelineRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout for connection to master node.
func (r DefaultAPIIngestGetPipelineRequest) MasterTimeout(masterTimeout string) DefaultAPIIngestGetPipelineRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIngestGetPipelineRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIngestGetPipelineRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIngestGetPipelineRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestGetPipelineExecute(r)
}

/*
IngestGetPipeline Method for IngestGetPipeline

Returns a pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIngestGetPipelineRequest
*/
func (a *DefaultAPIService) IngestGetPipeline(ctx context.Context) DefaultAPIIngestGetPipelineRequest {
	return DefaultAPIIngestGetPipelineRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestGetPipelineExecute(r DefaultAPIIngestGetPipelineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestGetPipeline")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIngestGetPipelineWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout for connection to master node.
func (r DefaultAPIIngestGetPipelineWithIdRequest) MasterTimeout(masterTimeout string) DefaultAPIIngestGetPipelineWithIdRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIngestGetPipelineWithIdRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIngestGetPipelineWithIdRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIIngestGetPipelineWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestGetPipelineWithIdExecute(r)
}

/*
IngestGetPipelineWithId Method for IngestGetPipelineWithId

Returns a pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Comma-separated list of pipeline ids. Wildcards supported.
 @return DefaultAPIIngestGetPipelineWithIdRequest
*/
func (a *DefaultAPIService) IngestGetPipelineWithId(ctx context.Context, id string) DefaultAPIIngestGetPipelineWithIdRequest {
	return DefaultAPIIngestGetPipelineWithIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestGetPipelineWithIdExecute(r DefaultAPIIngestGetPipelineWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestGetPipelineWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIngestProcessorGrokRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIIngestProcessorGrokRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestProcessorGrokExecute(r)
}

/*
IngestProcessorGrok Method for IngestProcessorGrok

Returns a list of the built-in patterns.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIngestProcessorGrokRequest
*/
func (a *DefaultAPIService) IngestProcessorGrok(ctx context.Context) DefaultAPIIngestProcessorGrokRequest {
	return DefaultAPIIngestProcessorGrokRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestProcessorGrokExecute(r DefaultAPIIngestProcessorGrokRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestProcessorGrok")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/processor/grok"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIngestPutPipelineRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	body *map[string]interface{}
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
}

func (r DefaultAPIIngestPutPipelineRequest) Body(body map[string]interface{}) DefaultAPIIngestPutPipelineRequest {
	r.body = &body
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIIngestPutPipelineRequest) MasterTimeout(masterTimeout string) DefaultAPIIngestPutPipelineRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIIngestPutPipelineRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIIngestPutPipelineRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r DefaultAPIIngestPutPipelineRequest) Timeout(timeout string) DefaultAPIIngestPutPipelineRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPIIngestPutPipelineRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestPutPipelineExecute(r)
}

/*
IngestPutPipeline Method for IngestPutPipeline

Creates or updates a pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Pipeline ID.
 @return DefaultAPIIngestPutPipelineRequest
*/
func (a *DefaultAPIService) IngestPutPipeline(ctx context.Context, id string) DefaultAPIIngestPutPipelineRequest {
	return DefaultAPIIngestPutPipelineRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestPutPipelineExecute(r DefaultAPIIngestPutPipelineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestPutPipeline")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIngestSimulateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	verbose *bool
}

// Verbose mode. Display data output for each processor in executed pipeline.
func (r DefaultAPIIngestSimulateGetRequest) Verbose(verbose bool) DefaultAPIIngestSimulateGetRequest {
	r.verbose = &verbose
	return r
}

func (r DefaultAPIIngestSimulateGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestSimulateGetExecute(r)
}

/*
IngestSimulateGet Method for IngestSimulateGet

Allows to simulate a pipeline with example documents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIngestSimulateGetRequest
*/
func (a *DefaultAPIService) IngestSimulateGet(ctx context.Context) DefaultAPIIngestSimulateGetRequest {
	return DefaultAPIIngestSimulateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestSimulateGetExecute(r DefaultAPIIngestSimulateGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestSimulateGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline/_simulate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIngestSimulateGetWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	verbose *bool
}

// Verbose mode. Display data output for each processor in executed pipeline.
func (r DefaultAPIIngestSimulateGetWithIdRequest) Verbose(verbose bool) DefaultAPIIngestSimulateGetWithIdRequest {
	r.verbose = &verbose
	return r
}

func (r DefaultAPIIngestSimulateGetWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestSimulateGetWithIdExecute(r)
}

/*
IngestSimulateGetWithId Method for IngestSimulateGetWithId

Allows to simulate a pipeline with example documents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Pipeline ID.
 @return DefaultAPIIngestSimulateGetWithIdRequest
*/
func (a *DefaultAPIService) IngestSimulateGetWithId(ctx context.Context, id string) DefaultAPIIngestSimulateGetWithIdRequest {
	return DefaultAPIIngestSimulateGetWithIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestSimulateGetWithIdExecute(r DefaultAPIIngestSimulateGetWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestSimulateGetWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline/{id}/_simulate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIngestSimulatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	verbose *bool
}

func (r DefaultAPIIngestSimulatePostRequest) Body(body map[string]interface{}) DefaultAPIIngestSimulatePostRequest {
	r.body = &body
	return r
}

// Verbose mode. Display data output for each processor in executed pipeline.
func (r DefaultAPIIngestSimulatePostRequest) Verbose(verbose bool) DefaultAPIIngestSimulatePostRequest {
	r.verbose = &verbose
	return r
}

func (r DefaultAPIIngestSimulatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestSimulatePostExecute(r)
}

/*
IngestSimulatePost Method for IngestSimulatePost

Allows to simulate a pipeline with example documents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIIngestSimulatePostRequest
*/
func (a *DefaultAPIService) IngestSimulatePost(ctx context.Context) DefaultAPIIngestSimulatePostRequest {
	return DefaultAPIIngestSimulatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestSimulatePostExecute(r DefaultAPIIngestSimulatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestSimulatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline/_simulate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIIngestSimulatePostWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	body *map[string]interface{}
	verbose *bool
}

func (r DefaultAPIIngestSimulatePostWithIdRequest) Body(body map[string]interface{}) DefaultAPIIngestSimulatePostWithIdRequest {
	r.body = &body
	return r
}

// Verbose mode. Display data output for each processor in executed pipeline.
func (r DefaultAPIIngestSimulatePostWithIdRequest) Verbose(verbose bool) DefaultAPIIngestSimulatePostWithIdRequest {
	r.verbose = &verbose
	return r
}

func (r DefaultAPIIngestSimulatePostWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.IngestSimulatePostWithIdExecute(r)
}

/*
IngestSimulatePostWithId Method for IngestSimulatePostWithId

Allows to simulate a pipeline with example documents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Pipeline ID.
 @return DefaultAPIIngestSimulatePostWithIdRequest
*/
func (a *DefaultAPIService) IngestSimulatePostWithId(ctx context.Context, id string) DefaultAPIIngestSimulatePostWithIdRequest {
	return DefaultAPIIngestSimulatePostWithIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) IngestSimulatePostWithIdExecute(r DefaultAPIIngestSimulatePostWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.IngestSimulatePostWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_ingest/pipeline/{id}/_simulate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMgetGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	storedFields *[]string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
}

// Comma-separated list of stored fields to return.
func (r DefaultAPIMgetGetRequest) StoredFields(storedFields []string) DefaultAPIMgetGetRequest {
	r.storedFields = &storedFields
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPIMgetGetRequest) Preference(preference string) DefaultAPIMgetGetRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r DefaultAPIMgetGetRequest) Realtime(realtime bool) DefaultAPIMgetGetRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r DefaultAPIMgetGetRequest) Refresh(refresh bool) DefaultAPIMgetGetRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIMgetGetRequest) Routing(routing string) DefaultAPIMgetGetRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPIMgetGetRequest) Source(source []string) DefaultAPIMgetGetRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPIMgetGetRequest) SourceExcludes(sourceExcludes []string) DefaultAPIMgetGetRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPIMgetGetRequest) SourceIncludes(sourceIncludes []string) DefaultAPIMgetGetRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

func (r DefaultAPIMgetGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MgetGetExecute(r)
}

/*
MgetGet Method for MgetGet

Allows to get multiple documents in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIMgetGetRequest
*/
func (a *DefaultAPIService) MgetGet(ctx context.Context) DefaultAPIMgetGetRequest {
	return DefaultAPIMgetGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MgetGetExecute(r DefaultAPIMgetGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MgetGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_mget"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMgetGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	storedFields *[]string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
}

// Comma-separated list of stored fields to return.
func (r DefaultAPIMgetGetWithIndexRequest) StoredFields(storedFields []string) DefaultAPIMgetGetWithIndexRequest {
	r.storedFields = &storedFields
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPIMgetGetWithIndexRequest) Preference(preference string) DefaultAPIMgetGetWithIndexRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r DefaultAPIMgetGetWithIndexRequest) Realtime(realtime bool) DefaultAPIMgetGetWithIndexRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r DefaultAPIMgetGetWithIndexRequest) Refresh(refresh bool) DefaultAPIMgetGetWithIndexRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIMgetGetWithIndexRequest) Routing(routing string) DefaultAPIMgetGetWithIndexRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPIMgetGetWithIndexRequest) Source(source []string) DefaultAPIMgetGetWithIndexRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPIMgetGetWithIndexRequest) SourceExcludes(sourceExcludes []string) DefaultAPIMgetGetWithIndexRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPIMgetGetWithIndexRequest) SourceIncludes(sourceIncludes []string) DefaultAPIMgetGetWithIndexRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

func (r DefaultAPIMgetGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MgetGetWithIndexExecute(r)
}

/*
MgetGetWithIndex Method for MgetGetWithIndex

Allows to get multiple documents in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Index name.
 @return DefaultAPIMgetGetWithIndexRequest
*/
func (a *DefaultAPIService) MgetGetWithIndex(ctx context.Context, index string) DefaultAPIMgetGetWithIndexRequest {
	return DefaultAPIMgetGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MgetGetWithIndexExecute(r DefaultAPIMgetGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MgetGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mget"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMgetPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	storedFields *[]string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
}

func (r DefaultAPIMgetPostRequest) Body(body map[string]interface{}) DefaultAPIMgetPostRequest {
	r.body = &body
	return r
}

// Comma-separated list of stored fields to return.
func (r DefaultAPIMgetPostRequest) StoredFields(storedFields []string) DefaultAPIMgetPostRequest {
	r.storedFields = &storedFields
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPIMgetPostRequest) Preference(preference string) DefaultAPIMgetPostRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r DefaultAPIMgetPostRequest) Realtime(realtime bool) DefaultAPIMgetPostRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r DefaultAPIMgetPostRequest) Refresh(refresh bool) DefaultAPIMgetPostRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIMgetPostRequest) Routing(routing string) DefaultAPIMgetPostRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPIMgetPostRequest) Source(source []string) DefaultAPIMgetPostRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPIMgetPostRequest) SourceExcludes(sourceExcludes []string) DefaultAPIMgetPostRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPIMgetPostRequest) SourceIncludes(sourceIncludes []string) DefaultAPIMgetPostRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

func (r DefaultAPIMgetPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.MgetPostExecute(r)
}

/*
MgetPost Method for MgetPost

Allows to get multiple documents in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIMgetPostRequest
*/
func (a *DefaultAPIService) MgetPost(ctx context.Context) DefaultAPIMgetPostRequest {
	return DefaultAPIMgetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MgetPostExecute(r DefaultAPIMgetPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MgetPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_mget"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMgetPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	storedFields *[]string
	preference *string
	realtime *bool
	refresh *bool
	routing *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
}

func (r DefaultAPIMgetPostWithIndexRequest) Body(body map[string]interface{}) DefaultAPIMgetPostWithIndexRequest {
	r.body = &body
	return r
}

// Comma-separated list of stored fields to return.
func (r DefaultAPIMgetPostWithIndexRequest) StoredFields(storedFields []string) DefaultAPIMgetPostWithIndexRequest {
	r.storedFields = &storedFields
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPIMgetPostWithIndexRequest) Preference(preference string) DefaultAPIMgetPostWithIndexRequest {
	r.preference = &preference
	return r
}

// Specify whether to perform the operation in realtime or search mode.
func (r DefaultAPIMgetPostWithIndexRequest) Realtime(realtime bool) DefaultAPIMgetPostWithIndexRequest {
	r.realtime = &realtime
	return r
}

// Refresh the shard containing the document before performing the operation.
func (r DefaultAPIMgetPostWithIndexRequest) Refresh(refresh bool) DefaultAPIMgetPostWithIndexRequest {
	r.refresh = &refresh
	return r
}

// Routing value.
func (r DefaultAPIMgetPostWithIndexRequest) Routing(routing string) DefaultAPIMgetPostWithIndexRequest {
	r.routing = &routing
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPIMgetPostWithIndexRequest) Source(source []string) DefaultAPIMgetPostWithIndexRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPIMgetPostWithIndexRequest) SourceExcludes(sourceExcludes []string) DefaultAPIMgetPostWithIndexRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPIMgetPostWithIndexRequest) SourceIncludes(sourceIncludes []string) DefaultAPIMgetPostWithIndexRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

func (r DefaultAPIMgetPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MgetPostWithIndexExecute(r)
}

/*
MgetPostWithIndex Method for MgetPostWithIndex

Allows to get multiple documents in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Index name.
 @return DefaultAPIMgetPostWithIndexRequest
*/
func (a *DefaultAPIService) MgetPostWithIndex(ctx context.Context, index string) DefaultAPIMgetPostWithIndexRequest {
	return DefaultAPIMgetPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MgetPostWithIndexExecute(r DefaultAPIMgetPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MgetPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mget"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMsearchGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	searchType *SearchTypeMulti
	maxConcurrentSearches *int32
	typedKeys *bool
	preFilterShardSize *int32
	maxConcurrentShardRequests *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

// Search operation type.
func (r DefaultAPIMsearchGetRequest) SearchType(searchType SearchTypeMulti) DefaultAPIMsearchGetRequest {
	r.searchType = &searchType
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r DefaultAPIMsearchGetRequest) MaxConcurrentSearches(maxConcurrentSearches int32) DefaultAPIMsearchGetRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPIMsearchGetRequest) TypedKeys(typedKeys bool) DefaultAPIMsearchGetRequest {
	r.typedKeys = &typedKeys
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r DefaultAPIMsearchGetRequest) PreFilterShardSize(preFilterShardSize int32) DefaultAPIMsearchGetRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r DefaultAPIMsearchGetRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) DefaultAPIMsearchGetRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPIMsearchGetRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPIMsearchGetRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPIMsearchGetRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPIMsearchGetRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r DefaultAPIMsearchGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchGetExecute(r)
}

/*
MsearchGet Method for MsearchGet

Allows to execute several search operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIMsearchGetRequest
*/
func (a *DefaultAPIService) MsearchGet(ctx context.Context) DefaultAPIMsearchGetRequest {
	return DefaultAPIMsearchGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchGetExecute(r DefaultAPIMsearchGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_msearch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMsearchGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	searchType *SearchTypeMulti
	maxConcurrentSearches *int32
	typedKeys *bool
	preFilterShardSize *int32
	maxConcurrentShardRequests *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

// Search operation type.
func (r DefaultAPIMsearchGetWithIndexRequest) SearchType(searchType SearchTypeMulti) DefaultAPIMsearchGetWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r DefaultAPIMsearchGetWithIndexRequest) MaxConcurrentSearches(maxConcurrentSearches int32) DefaultAPIMsearchGetWithIndexRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPIMsearchGetWithIndexRequest) TypedKeys(typedKeys bool) DefaultAPIMsearchGetWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r DefaultAPIMsearchGetWithIndexRequest) PreFilterShardSize(preFilterShardSize int32) DefaultAPIMsearchGetWithIndexRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r DefaultAPIMsearchGetWithIndexRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) DefaultAPIMsearchGetWithIndexRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPIMsearchGetWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPIMsearchGetWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPIMsearchGetWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPIMsearchGetWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r DefaultAPIMsearchGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchGetWithIndexExecute(r)
}

/*
MsearchGetWithIndex Method for MsearchGetWithIndex

Allows to execute several search operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to use as default.
 @return DefaultAPIMsearchGetWithIndexRequest
*/
func (a *DefaultAPIService) MsearchGetWithIndex(ctx context.Context, index string) DefaultAPIMsearchGetWithIndexRequest {
	return DefaultAPIMsearchGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchGetWithIndexExecute(r DefaultAPIMsearchGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_msearch"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMsearchPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	searchType *SearchTypeMulti
	maxConcurrentSearches *int32
	typedKeys *bool
	preFilterShardSize *int32
	maxConcurrentShardRequests *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

func (r DefaultAPIMsearchPostRequest) Body(body map[string]interface{}) DefaultAPIMsearchPostRequest {
	r.body = &body
	return r
}

// Search operation type.
func (r DefaultAPIMsearchPostRequest) SearchType(searchType SearchTypeMulti) DefaultAPIMsearchPostRequest {
	r.searchType = &searchType
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r DefaultAPIMsearchPostRequest) MaxConcurrentSearches(maxConcurrentSearches int32) DefaultAPIMsearchPostRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPIMsearchPostRequest) TypedKeys(typedKeys bool) DefaultAPIMsearchPostRequest {
	r.typedKeys = &typedKeys
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r DefaultAPIMsearchPostRequest) PreFilterShardSize(preFilterShardSize int32) DefaultAPIMsearchPostRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r DefaultAPIMsearchPostRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) DefaultAPIMsearchPostRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPIMsearchPostRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPIMsearchPostRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPIMsearchPostRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPIMsearchPostRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r DefaultAPIMsearchPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchPostExecute(r)
}

/*
MsearchPost Method for MsearchPost

Allows to execute several search operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIMsearchPostRequest
*/
func (a *DefaultAPIService) MsearchPost(ctx context.Context) DefaultAPIMsearchPostRequest {
	return DefaultAPIMsearchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchPostExecute(r DefaultAPIMsearchPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_msearch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMsearchPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	searchType *SearchTypeMulti
	maxConcurrentSearches *int32
	typedKeys *bool
	preFilterShardSize *int32
	maxConcurrentShardRequests *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

func (r DefaultAPIMsearchPostWithIndexRequest) Body(body map[string]interface{}) DefaultAPIMsearchPostWithIndexRequest {
	r.body = &body
	return r
}

// Search operation type.
func (r DefaultAPIMsearchPostWithIndexRequest) SearchType(searchType SearchTypeMulti) DefaultAPIMsearchPostWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r DefaultAPIMsearchPostWithIndexRequest) MaxConcurrentSearches(maxConcurrentSearches int32) DefaultAPIMsearchPostWithIndexRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPIMsearchPostWithIndexRequest) TypedKeys(typedKeys bool) DefaultAPIMsearchPostWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r DefaultAPIMsearchPostWithIndexRequest) PreFilterShardSize(preFilterShardSize int32) DefaultAPIMsearchPostWithIndexRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r DefaultAPIMsearchPostWithIndexRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) DefaultAPIMsearchPostWithIndexRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPIMsearchPostWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPIMsearchPostWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPIMsearchPostWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPIMsearchPostWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r DefaultAPIMsearchPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchPostWithIndexExecute(r)
}

/*
MsearchPostWithIndex Method for MsearchPostWithIndex

Allows to execute several search operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to use as default.
 @return DefaultAPIMsearchPostWithIndexRequest
*/
func (a *DefaultAPIService) MsearchPostWithIndex(ctx context.Context, index string) DefaultAPIMsearchPostWithIndexRequest {
	return DefaultAPIMsearchPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchPostWithIndexExecute(r DefaultAPIMsearchPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_msearch"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMsearchTemplateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	searchType *SearchTypeMulti
	typedKeys *bool
	maxConcurrentSearches *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

// Search operation type.
func (r DefaultAPIMsearchTemplateGetRequest) SearchType(searchType SearchTypeMulti) DefaultAPIMsearchTemplateGetRequest {
	r.searchType = &searchType
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPIMsearchTemplateGetRequest) TypedKeys(typedKeys bool) DefaultAPIMsearchTemplateGetRequest {
	r.typedKeys = &typedKeys
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r DefaultAPIMsearchTemplateGetRequest) MaxConcurrentSearches(maxConcurrentSearches int32) DefaultAPIMsearchTemplateGetRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPIMsearchTemplateGetRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPIMsearchTemplateGetRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPIMsearchTemplateGetRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPIMsearchTemplateGetRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r DefaultAPIMsearchTemplateGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchTemplateGetExecute(r)
}

/*
MsearchTemplateGet Method for MsearchTemplateGet

Allows to execute several search template operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIMsearchTemplateGetRequest
*/
func (a *DefaultAPIService) MsearchTemplateGet(ctx context.Context) DefaultAPIMsearchTemplateGetRequest {
	return DefaultAPIMsearchTemplateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchTemplateGetExecute(r DefaultAPIMsearchTemplateGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchTemplateGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_msearch/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMsearchTemplateGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	searchType *SearchTypeMulti
	typedKeys *bool
	maxConcurrentSearches *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

// Search operation type.
func (r DefaultAPIMsearchTemplateGetWithIndexRequest) SearchType(searchType SearchTypeMulti) DefaultAPIMsearchTemplateGetWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPIMsearchTemplateGetWithIndexRequest) TypedKeys(typedKeys bool) DefaultAPIMsearchTemplateGetWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r DefaultAPIMsearchTemplateGetWithIndexRequest) MaxConcurrentSearches(maxConcurrentSearches int32) DefaultAPIMsearchTemplateGetWithIndexRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPIMsearchTemplateGetWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPIMsearchTemplateGetWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPIMsearchTemplateGetWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPIMsearchTemplateGetWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r DefaultAPIMsearchTemplateGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchTemplateGetWithIndexExecute(r)
}

/*
MsearchTemplateGetWithIndex Method for MsearchTemplateGetWithIndex

Allows to execute several search template operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to use as default.
 @return DefaultAPIMsearchTemplateGetWithIndexRequest
*/
func (a *DefaultAPIService) MsearchTemplateGetWithIndex(ctx context.Context, index string) DefaultAPIMsearchTemplateGetWithIndexRequest {
	return DefaultAPIMsearchTemplateGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchTemplateGetWithIndexExecute(r DefaultAPIMsearchTemplateGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchTemplateGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_msearch/template"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMsearchTemplatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	searchType *SearchTypeMulti
	typedKeys *bool
	maxConcurrentSearches *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

func (r DefaultAPIMsearchTemplatePostRequest) Body(body map[string]interface{}) DefaultAPIMsearchTemplatePostRequest {
	r.body = &body
	return r
}

// Search operation type.
func (r DefaultAPIMsearchTemplatePostRequest) SearchType(searchType SearchTypeMulti) DefaultAPIMsearchTemplatePostRequest {
	r.searchType = &searchType
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPIMsearchTemplatePostRequest) TypedKeys(typedKeys bool) DefaultAPIMsearchTemplatePostRequest {
	r.typedKeys = &typedKeys
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r DefaultAPIMsearchTemplatePostRequest) MaxConcurrentSearches(maxConcurrentSearches int32) DefaultAPIMsearchTemplatePostRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPIMsearchTemplatePostRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPIMsearchTemplatePostRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPIMsearchTemplatePostRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPIMsearchTemplatePostRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r DefaultAPIMsearchTemplatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchTemplatePostExecute(r)
}

/*
MsearchTemplatePost Method for MsearchTemplatePost

Allows to execute several search template operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIMsearchTemplatePostRequest
*/
func (a *DefaultAPIService) MsearchTemplatePost(ctx context.Context) DefaultAPIMsearchTemplatePostRequest {
	return DefaultAPIMsearchTemplatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchTemplatePostExecute(r DefaultAPIMsearchTemplatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchTemplatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_msearch/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMsearchTemplatePostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	searchType *SearchTypeMulti
	typedKeys *bool
	maxConcurrentSearches *int32
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

func (r DefaultAPIMsearchTemplatePostWithIndexRequest) Body(body map[string]interface{}) DefaultAPIMsearchTemplatePostWithIndexRequest {
	r.body = &body
	return r
}

// Search operation type.
func (r DefaultAPIMsearchTemplatePostWithIndexRequest) SearchType(searchType SearchTypeMulti) DefaultAPIMsearchTemplatePostWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPIMsearchTemplatePostWithIndexRequest) TypedKeys(typedKeys bool) DefaultAPIMsearchTemplatePostWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Controls the maximum number of concurrent searches the multi search api will execute.
func (r DefaultAPIMsearchTemplatePostWithIndexRequest) MaxConcurrentSearches(maxConcurrentSearches int32) DefaultAPIMsearchTemplatePostWithIndexRequest {
	r.maxConcurrentSearches = &maxConcurrentSearches
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPIMsearchTemplatePostWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPIMsearchTemplatePostWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPIMsearchTemplatePostWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPIMsearchTemplatePostWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r DefaultAPIMsearchTemplatePostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MsearchTemplatePostWithIndexExecute(r)
}

/*
MsearchTemplatePostWithIndex Method for MsearchTemplatePostWithIndex

Allows to execute several search template operations in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices to use as default.
 @return DefaultAPIMsearchTemplatePostWithIndexRequest
*/
func (a *DefaultAPIService) MsearchTemplatePostWithIndex(ctx context.Context, index string) DefaultAPIMsearchTemplatePostWithIndexRequest {
	return DefaultAPIMsearchTemplatePostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MsearchTemplatePostWithIndexExecute(r DefaultAPIMsearchTemplatePostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MsearchTemplatePostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_msearch/template"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.maxConcurrentSearches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_searches", r.maxConcurrentSearches, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMtermvectorsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ids *[]string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
}

// Comma-separated list of documents ids. You must define ids as parameter or set &#39;ids&#39; or &#39;docs&#39; in the request body.
func (r DefaultAPIMtermvectorsGetRequest) Ids(ids []string) DefaultAPIMtermvectorsGetRequest {
	r.ids = &ids
	return r
}

// Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetRequest) TermStatistics(termStatistics bool) DefaultAPIMtermvectorsGetRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetRequest) FieldStatistics(fieldStatistics bool) DefaultAPIMtermvectorsGetRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetRequest) Fields(fields []string) DefaultAPIMtermvectorsGetRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetRequest) Offsets(offsets bool) DefaultAPIMtermvectorsGetRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetRequest) Positions(positions bool) DefaultAPIMtermvectorsGetRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetRequest) Payloads(payloads bool) DefaultAPIMtermvectorsGetRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetRequest) Preference(preference string) DefaultAPIMtermvectorsGetRequest {
	r.preference = &preference
	return r
}

// Routing value. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetRequest) Routing(routing string) DefaultAPIMtermvectorsGetRequest {
	r.routing = &routing
	return r
}

// Specifies if requests are real-time as opposed to near-real-time.
func (r DefaultAPIMtermvectorsGetRequest) Realtime(realtime bool) DefaultAPIMtermvectorsGetRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPIMtermvectorsGetRequest) Version(version int32) DefaultAPIMtermvectorsGetRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPIMtermvectorsGetRequest) VersionType(versionType VersionType) DefaultAPIMtermvectorsGetRequest {
	r.versionType = &versionType
	return r
}

func (r DefaultAPIMtermvectorsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MtermvectorsGetExecute(r)
}

/*
MtermvectorsGet Method for MtermvectorsGet

Returns multiple termvectors in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIMtermvectorsGetRequest
*/
func (a *DefaultAPIService) MtermvectorsGet(ctx context.Context) DefaultAPIMtermvectorsGetRequest {
	return DefaultAPIMtermvectorsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MtermvectorsGetExecute(r DefaultAPIMtermvectorsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MtermvectorsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_mtermvectors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMtermvectorsGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ids *[]string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
}

// Comma-separated list of documents ids. You must define ids as parameter or set &#39;ids&#39; or &#39;docs&#39; in the request body.
func (r DefaultAPIMtermvectorsGetWithIndexRequest) Ids(ids []string) DefaultAPIMtermvectorsGetWithIndexRequest {
	r.ids = &ids
	return r
}

// Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetWithIndexRequest) TermStatistics(termStatistics bool) DefaultAPIMtermvectorsGetWithIndexRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetWithIndexRequest) FieldStatistics(fieldStatistics bool) DefaultAPIMtermvectorsGetWithIndexRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetWithIndexRequest) Fields(fields []string) DefaultAPIMtermvectorsGetWithIndexRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetWithIndexRequest) Offsets(offsets bool) DefaultAPIMtermvectorsGetWithIndexRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetWithIndexRequest) Positions(positions bool) DefaultAPIMtermvectorsGetWithIndexRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetWithIndexRequest) Payloads(payloads bool) DefaultAPIMtermvectorsGetWithIndexRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetWithIndexRequest) Preference(preference string) DefaultAPIMtermvectorsGetWithIndexRequest {
	r.preference = &preference
	return r
}

// Routing value. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsGetWithIndexRequest) Routing(routing string) DefaultAPIMtermvectorsGetWithIndexRequest {
	r.routing = &routing
	return r
}

// Specifies if requests are real-time as opposed to near-real-time.
func (r DefaultAPIMtermvectorsGetWithIndexRequest) Realtime(realtime bool) DefaultAPIMtermvectorsGetWithIndexRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPIMtermvectorsGetWithIndexRequest) Version(version int32) DefaultAPIMtermvectorsGetWithIndexRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPIMtermvectorsGetWithIndexRequest) VersionType(versionType VersionType) DefaultAPIMtermvectorsGetWithIndexRequest {
	r.versionType = &versionType
	return r
}

func (r DefaultAPIMtermvectorsGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MtermvectorsGetWithIndexExecute(r)
}

/*
MtermvectorsGetWithIndex Method for MtermvectorsGetWithIndex

Returns multiple termvectors in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The index in which the document resides.
 @return DefaultAPIMtermvectorsGetWithIndexRequest
*/
func (a *DefaultAPIService) MtermvectorsGetWithIndex(ctx context.Context, index string) DefaultAPIMtermvectorsGetWithIndexRequest {
	return DefaultAPIMtermvectorsGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MtermvectorsGetWithIndexExecute(r DefaultAPIMtermvectorsGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MtermvectorsGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mtermvectors"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMtermvectorsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ids *[]string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
	body *map[string]interface{}
}

// Comma-separated list of documents ids. You must define ids as parameter or set &#39;ids&#39; or &#39;docs&#39; in the request body.
func (r DefaultAPIMtermvectorsPostRequest) Ids(ids []string) DefaultAPIMtermvectorsPostRequest {
	r.ids = &ids
	return r
}

// Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostRequest) TermStatistics(termStatistics bool) DefaultAPIMtermvectorsPostRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostRequest) FieldStatistics(fieldStatistics bool) DefaultAPIMtermvectorsPostRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostRequest) Fields(fields []string) DefaultAPIMtermvectorsPostRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostRequest) Offsets(offsets bool) DefaultAPIMtermvectorsPostRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostRequest) Positions(positions bool) DefaultAPIMtermvectorsPostRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostRequest) Payloads(payloads bool) DefaultAPIMtermvectorsPostRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostRequest) Preference(preference string) DefaultAPIMtermvectorsPostRequest {
	r.preference = &preference
	return r
}

// Routing value. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostRequest) Routing(routing string) DefaultAPIMtermvectorsPostRequest {
	r.routing = &routing
	return r
}

// Specifies if requests are real-time as opposed to near-real-time.
func (r DefaultAPIMtermvectorsPostRequest) Realtime(realtime bool) DefaultAPIMtermvectorsPostRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPIMtermvectorsPostRequest) Version(version int32) DefaultAPIMtermvectorsPostRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPIMtermvectorsPostRequest) VersionType(versionType VersionType) DefaultAPIMtermvectorsPostRequest {
	r.versionType = &versionType
	return r
}

func (r DefaultAPIMtermvectorsPostRequest) Body(body map[string]interface{}) DefaultAPIMtermvectorsPostRequest {
	r.body = &body
	return r
}

func (r DefaultAPIMtermvectorsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.MtermvectorsPostExecute(r)
}

/*
MtermvectorsPost Method for MtermvectorsPost

Returns multiple termvectors in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIMtermvectorsPostRequest
*/
func (a *DefaultAPIService) MtermvectorsPost(ctx context.Context) DefaultAPIMtermvectorsPostRequest {
	return DefaultAPIMtermvectorsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MtermvectorsPostExecute(r DefaultAPIMtermvectorsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MtermvectorsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_mtermvectors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIMtermvectorsPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ids *[]string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
	body *map[string]interface{}
}

// Comma-separated list of documents ids. You must define ids as parameter or set &#39;ids&#39; or &#39;docs&#39; in the request body.
func (r DefaultAPIMtermvectorsPostWithIndexRequest) Ids(ids []string) DefaultAPIMtermvectorsPostWithIndexRequest {
	r.ids = &ids
	return r
}

// Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostWithIndexRequest) TermStatistics(termStatistics bool) DefaultAPIMtermvectorsPostWithIndexRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostWithIndexRequest) FieldStatistics(fieldStatistics bool) DefaultAPIMtermvectorsPostWithIndexRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostWithIndexRequest) Fields(fields []string) DefaultAPIMtermvectorsPostWithIndexRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostWithIndexRequest) Offsets(offsets bool) DefaultAPIMtermvectorsPostWithIndexRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostWithIndexRequest) Positions(positions bool) DefaultAPIMtermvectorsPostWithIndexRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostWithIndexRequest) Payloads(payloads bool) DefaultAPIMtermvectorsPostWithIndexRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostWithIndexRequest) Preference(preference string) DefaultAPIMtermvectorsPostWithIndexRequest {
	r.preference = &preference
	return r
}

// Routing value. Applies to all returned documents unless otherwise specified in body &#39;params&#39; or &#39;docs&#39;.
func (r DefaultAPIMtermvectorsPostWithIndexRequest) Routing(routing string) DefaultAPIMtermvectorsPostWithIndexRequest {
	r.routing = &routing
	return r
}

// Specifies if requests are real-time as opposed to near-real-time.
func (r DefaultAPIMtermvectorsPostWithIndexRequest) Realtime(realtime bool) DefaultAPIMtermvectorsPostWithIndexRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPIMtermvectorsPostWithIndexRequest) Version(version int32) DefaultAPIMtermvectorsPostWithIndexRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPIMtermvectorsPostWithIndexRequest) VersionType(versionType VersionType) DefaultAPIMtermvectorsPostWithIndexRequest {
	r.versionType = &versionType
	return r
}

func (r DefaultAPIMtermvectorsPostWithIndexRequest) Body(body map[string]interface{}) DefaultAPIMtermvectorsPostWithIndexRequest {
	r.body = &body
	return r
}

func (r DefaultAPIMtermvectorsPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.MtermvectorsPostWithIndexExecute(r)
}

/*
MtermvectorsPostWithIndex Method for MtermvectorsPostWithIndex

Returns multiple termvectors in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The index in which the document resides.
 @return DefaultAPIMtermvectorsPostWithIndexRequest
*/
func (a *DefaultAPIService) MtermvectorsPostWithIndex(ctx context.Context, index string) DefaultAPIMtermvectorsPostWithIndexRequest {
	return DefaultAPIMtermvectorsPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MtermvectorsPostWithIndexExecute(r DefaultAPIMtermvectorsPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MtermvectorsPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_mtermvectors"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesHotThreadsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r DefaultAPINodesHotThreadsRequest) Interval(interval string) DefaultAPINodesHotThreadsRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r DefaultAPINodesHotThreadsRequest) Snapshots(snapshots int32) DefaultAPINodesHotThreadsRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r DefaultAPINodesHotThreadsRequest) Threads(threads int32) DefaultAPINodesHotThreadsRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r DefaultAPINodesHotThreadsRequest) IgnoreIdleThreads(ignoreIdleThreads bool) DefaultAPINodesHotThreadsRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r DefaultAPINodesHotThreadsRequest) Type_(type_ SampleType) DefaultAPINodesHotThreadsRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r DefaultAPINodesHotThreadsRequest) Timeout(timeout string) DefaultAPINodesHotThreadsRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesHotThreadsRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsExecute(r)
}

/*
NodesHotThreads Method for NodesHotThreads

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPINodesHotThreadsRequest
*/
func (a *DefaultAPIService) NodesHotThreads(ctx context.Context) DefaultAPINodesHotThreadsRequest {
	return DefaultAPINodesHotThreadsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesHotThreadsExecute(r DefaultAPINodesHotThreadsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreads")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/hot_threads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesHotThreadsDeprecatedRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r DefaultAPINodesHotThreadsDeprecatedRequest) Interval(interval string) DefaultAPINodesHotThreadsDeprecatedRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r DefaultAPINodesHotThreadsDeprecatedRequest) Snapshots(snapshots int32) DefaultAPINodesHotThreadsDeprecatedRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r DefaultAPINodesHotThreadsDeprecatedRequest) Threads(threads int32) DefaultAPINodesHotThreadsDeprecatedRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r DefaultAPINodesHotThreadsDeprecatedRequest) IgnoreIdleThreads(ignoreIdleThreads bool) DefaultAPINodesHotThreadsDeprecatedRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r DefaultAPINodesHotThreadsDeprecatedRequest) Type_(type_ SampleType) DefaultAPINodesHotThreadsDeprecatedRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r DefaultAPINodesHotThreadsDeprecatedRequest) Timeout(timeout string) DefaultAPINodesHotThreadsDeprecatedRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesHotThreadsDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsDeprecatedExecute(r)
}

/*
NodesHotThreadsDeprecated Method for NodesHotThreadsDeprecated

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPINodesHotThreadsDeprecatedRequest

Deprecated
*/
func (a *DefaultAPIService) NodesHotThreadsDeprecated(ctx context.Context) DefaultAPINodesHotThreadsDeprecatedRequest {
	return DefaultAPINodesHotThreadsDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) NodesHotThreadsDeprecatedExecute(r DefaultAPINodesHotThreadsDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreadsDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/hotthreads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesHotThreadsDeprecatedClusterRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r DefaultAPINodesHotThreadsDeprecatedClusterRequest) Interval(interval string) DefaultAPINodesHotThreadsDeprecatedClusterRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r DefaultAPINodesHotThreadsDeprecatedClusterRequest) Snapshots(snapshots int32) DefaultAPINodesHotThreadsDeprecatedClusterRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r DefaultAPINodesHotThreadsDeprecatedClusterRequest) Threads(threads int32) DefaultAPINodesHotThreadsDeprecatedClusterRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r DefaultAPINodesHotThreadsDeprecatedClusterRequest) IgnoreIdleThreads(ignoreIdleThreads bool) DefaultAPINodesHotThreadsDeprecatedClusterRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r DefaultAPINodesHotThreadsDeprecatedClusterRequest) Type_(type_ SampleType) DefaultAPINodesHotThreadsDeprecatedClusterRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r DefaultAPINodesHotThreadsDeprecatedClusterRequest) Timeout(timeout string) DefaultAPINodesHotThreadsDeprecatedClusterRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesHotThreadsDeprecatedClusterRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsDeprecatedClusterExecute(r)
}

/*
NodesHotThreadsDeprecatedCluster Method for NodesHotThreadsDeprecatedCluster

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPINodesHotThreadsDeprecatedClusterRequest

Deprecated
*/
func (a *DefaultAPIService) NodesHotThreadsDeprecatedCluster(ctx context.Context) DefaultAPINodesHotThreadsDeprecatedClusterRequest {
	return DefaultAPINodesHotThreadsDeprecatedClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) NodesHotThreadsDeprecatedClusterExecute(r DefaultAPINodesHotThreadsDeprecatedClusterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreadsDeprecatedCluster")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/nodes/hotthreads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesHotThreadsDeprecatedDashRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r DefaultAPINodesHotThreadsDeprecatedDashRequest) Interval(interval string) DefaultAPINodesHotThreadsDeprecatedDashRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r DefaultAPINodesHotThreadsDeprecatedDashRequest) Snapshots(snapshots int32) DefaultAPINodesHotThreadsDeprecatedDashRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r DefaultAPINodesHotThreadsDeprecatedDashRequest) Threads(threads int32) DefaultAPINodesHotThreadsDeprecatedDashRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r DefaultAPINodesHotThreadsDeprecatedDashRequest) IgnoreIdleThreads(ignoreIdleThreads bool) DefaultAPINodesHotThreadsDeprecatedDashRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r DefaultAPINodesHotThreadsDeprecatedDashRequest) Type_(type_ SampleType) DefaultAPINodesHotThreadsDeprecatedDashRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r DefaultAPINodesHotThreadsDeprecatedDashRequest) Timeout(timeout string) DefaultAPINodesHotThreadsDeprecatedDashRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesHotThreadsDeprecatedDashRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsDeprecatedDashExecute(r)
}

/*
NodesHotThreadsDeprecatedDash Method for NodesHotThreadsDeprecatedDash

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPINodesHotThreadsDeprecatedDashRequest

Deprecated
*/
func (a *DefaultAPIService) NodesHotThreadsDeprecatedDash(ctx context.Context) DefaultAPINodesHotThreadsDeprecatedDashRequest {
	return DefaultAPINodesHotThreadsDeprecatedDashRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) NodesHotThreadsDeprecatedDashExecute(r DefaultAPINodesHotThreadsDeprecatedDashRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreadsDeprecatedDash")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/nodes/hot_threads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesHotThreadsWithNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r DefaultAPINodesHotThreadsWithNodeIdRequest) Interval(interval string) DefaultAPINodesHotThreadsWithNodeIdRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r DefaultAPINodesHotThreadsWithNodeIdRequest) Snapshots(snapshots int32) DefaultAPINodesHotThreadsWithNodeIdRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r DefaultAPINodesHotThreadsWithNodeIdRequest) Threads(threads int32) DefaultAPINodesHotThreadsWithNodeIdRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r DefaultAPINodesHotThreadsWithNodeIdRequest) IgnoreIdleThreads(ignoreIdleThreads bool) DefaultAPINodesHotThreadsWithNodeIdRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r DefaultAPINodesHotThreadsWithNodeIdRequest) Type_(type_ SampleType) DefaultAPINodesHotThreadsWithNodeIdRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r DefaultAPINodesHotThreadsWithNodeIdRequest) Timeout(timeout string) DefaultAPINodesHotThreadsWithNodeIdRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesHotThreadsWithNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsWithNodeIdExecute(r)
}

/*
NodesHotThreadsWithNodeId Method for NodesHotThreadsWithNodeId

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return DefaultAPINodesHotThreadsWithNodeIdRequest
*/
func (a *DefaultAPIService) NodesHotThreadsWithNodeId(ctx context.Context, nodeId string) DefaultAPINodesHotThreadsWithNodeIdRequest {
	return DefaultAPINodesHotThreadsWithNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesHotThreadsWithNodeIdExecute(r DefaultAPINodesHotThreadsWithNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreadsWithNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/hot_threads"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest) Interval(interval string) DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest) Snapshots(snapshots int32) DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest) Threads(threads int32) DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest) IgnoreIdleThreads(ignoreIdleThreads bool) DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest) Type_(type_ SampleType) DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest) Timeout(timeout string) DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsWithNodeIdDeprecatedExecute(r)
}

/*
NodesHotThreadsWithNodeIdDeprecated Method for NodesHotThreadsWithNodeIdDeprecated

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest

Deprecated
*/
func (a *DefaultAPIService) NodesHotThreadsWithNodeIdDeprecated(ctx context.Context, nodeId string) DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest {
	return DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) NodesHotThreadsWithNodeIdDeprecatedExecute(r DefaultAPINodesHotThreadsWithNodeIdDeprecatedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreadsWithNodeIdDeprecated")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/hotthreads"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest) Interval(interval string) DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest) Snapshots(snapshots int32) DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest) Threads(threads int32) DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest) IgnoreIdleThreads(ignoreIdleThreads bool) DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest) Type_(type_ SampleType) DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest) Timeout(timeout string) DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsWithNodeIdDeprecatedClusterExecute(r)
}

/*
NodesHotThreadsWithNodeIdDeprecatedCluster Method for NodesHotThreadsWithNodeIdDeprecatedCluster

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest

Deprecated
*/
func (a *DefaultAPIService) NodesHotThreadsWithNodeIdDeprecatedCluster(ctx context.Context, nodeId string) DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest {
	return DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) NodesHotThreadsWithNodeIdDeprecatedClusterExecute(r DefaultAPINodesHotThreadsWithNodeIdDeprecatedClusterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreadsWithNodeIdDeprecatedCluster")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/nodes/{node_id}/hotthreads"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	interval *string
	snapshots *int32
	threads *int32
	ignoreIdleThreads *bool
	type_ *SampleType
	timeout *string
}

// The interval for the second sampling of threads.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest) Interval(interval string) DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest {
	r.interval = &interval
	return r
}

// Number of samples of thread stacktrace.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest) Snapshots(snapshots int32) DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest {
	r.snapshots = &snapshots
	return r
}

// Specify the number of threads to provide information for.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest) Threads(threads int32) DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest {
	r.threads = &threads
	return r
}

// Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest) IgnoreIdleThreads(ignoreIdleThreads bool) DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest {
	r.ignoreIdleThreads = &ignoreIdleThreads
	return r
}

// The type to sample.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest) Type_(type_ SampleType) DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest {
	r.type_ = &type_
	return r
}

// Operation timeout.
func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest) Timeout(timeout string) DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesHotThreadsWithNodeIdDeprecatedDashExecute(r)
}

/*
NodesHotThreadsWithNodeIdDeprecatedDash Method for NodesHotThreadsWithNodeIdDeprecatedDash

Returns information about hot threads on each node in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest

Deprecated
*/
func (a *DefaultAPIService) NodesHotThreadsWithNodeIdDeprecatedDash(ctx context.Context, nodeId string) DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest {
	return DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) NodesHotThreadsWithNodeIdDeprecatedDashExecute(r DefaultAPINodesHotThreadsWithNodeIdDeprecatedDashRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesHotThreadsWithNodeIdDeprecatedDash")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_cluster/nodes/{node_id}/hot_threads"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.snapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshots", r.snapshots, "")
	} else {
		var defaultValue int32 = 10
		r.snapshots = &defaultValue
	}
	if r.threads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threads", r.threads, "")
	} else {
		var defaultValue int32 = 3
		r.threads = &defaultValue
	}
	if r.ignoreIdleThreads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_idle_threads", r.ignoreIdleThreads, "")
	} else {
		var defaultValue bool = true
		r.ignoreIdleThreads = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesInfoRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	flatSettings *bool
	timeout *string
}

// Return settings in flat format.
func (r DefaultAPINodesInfoRequest) FlatSettings(flatSettings bool) DefaultAPINodesInfoRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout.
func (r DefaultAPINodesInfoRequest) Timeout(timeout string) DefaultAPINodesInfoRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesInfoRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesInfoExecute(r)
}

/*
NodesInfo Method for NodesInfo

Returns information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPINodesInfoRequest
*/
func (a *DefaultAPIService) NodesInfo(ctx context.Context) DefaultAPINodesInfoRequest {
	return DefaultAPINodesInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesInfoExecute(r DefaultAPINodesInfoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesInfo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesInfoWithMetricNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	metric string
	flatSettings *bool
	timeout *string
}

// Return settings in flat format.
func (r DefaultAPINodesInfoWithMetricNodeIdRequest) FlatSettings(flatSettings bool) DefaultAPINodesInfoWithMetricNodeIdRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout.
func (r DefaultAPINodesInfoWithMetricNodeIdRequest) Timeout(timeout string) DefaultAPINodesInfoWithMetricNodeIdRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesInfoWithMetricNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesInfoWithMetricNodeIdExecute(r)
}

/*
NodesInfoWithMetricNodeId Method for NodesInfoWithMetricNodeId

Returns information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @param metric Comma-separated list of metrics you wish returned. Leave empty to return all.
 @return DefaultAPINodesInfoWithMetricNodeIdRequest
*/
func (a *DefaultAPIService) NodesInfoWithMetricNodeId(ctx context.Context, nodeId string, metric string) DefaultAPINodesInfoWithMetricNodeIdRequest {
	return DefaultAPINodesInfoWithMetricNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
		metric: metric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesInfoWithMetricNodeIdExecute(r DefaultAPINodesInfoWithMetricNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesInfoWithMetricNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesInfoWithNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	flatSettings *bool
	timeout *string
}

// Return settings in flat format.
func (r DefaultAPINodesInfoWithNodeIdRequest) FlatSettings(flatSettings bool) DefaultAPINodesInfoWithNodeIdRequest {
	r.flatSettings = &flatSettings
	return r
}

// Operation timeout.
func (r DefaultAPINodesInfoWithNodeIdRequest) Timeout(timeout string) DefaultAPINodesInfoWithNodeIdRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesInfoWithNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesInfoWithNodeIdExecute(r)
}

/*
NodesInfoWithNodeId Method for NodesInfoWithNodeId

Returns information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return DefaultAPINodesInfoWithNodeIdRequest
*/
func (a *DefaultAPIService) NodesInfoWithNodeId(ctx context.Context, nodeId string) DefaultAPINodesInfoWithNodeIdRequest {
	return DefaultAPINodesInfoWithNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesInfoWithNodeIdExecute(r DefaultAPINodesInfoWithNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesInfoWithNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flatSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flat_settings", r.flatSettings, "")
	} else {
		var defaultValue bool = false
		r.flatSettings = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesReloadSecureSettingsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	timeout *string
	body *map[string]interface{}
}

// Operation timeout.
func (r DefaultAPINodesReloadSecureSettingsRequest) Timeout(timeout string) DefaultAPINodesReloadSecureSettingsRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesReloadSecureSettingsRequest) Body(body map[string]interface{}) DefaultAPINodesReloadSecureSettingsRequest {
	r.body = &body
	return r
}

func (r DefaultAPINodesReloadSecureSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesReloadSecureSettingsExecute(r)
}

/*
NodesReloadSecureSettings Method for NodesReloadSecureSettings

Reloads secure settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPINodesReloadSecureSettingsRequest
*/
func (a *DefaultAPIService) NodesReloadSecureSettings(ctx context.Context) DefaultAPINodesReloadSecureSettingsRequest {
	return DefaultAPINodesReloadSecureSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesReloadSecureSettingsExecute(r DefaultAPINodesReloadSecureSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesReloadSecureSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/reload_secure_settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesReloadSecureSettingsWithNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	timeout *string
	body *map[string]interface{}
}

// Operation timeout.
func (r DefaultAPINodesReloadSecureSettingsWithNodeIdRequest) Timeout(timeout string) DefaultAPINodesReloadSecureSettingsWithNodeIdRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesReloadSecureSettingsWithNodeIdRequest) Body(body map[string]interface{}) DefaultAPINodesReloadSecureSettingsWithNodeIdRequest {
	r.body = &body
	return r
}

func (r DefaultAPINodesReloadSecureSettingsWithNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesReloadSecureSettingsWithNodeIdExecute(r)
}

/*
NodesReloadSecureSettingsWithNodeId Method for NodesReloadSecureSettingsWithNodeId

Reloads secure settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs to span the reload/reinit call. Should stay empty because reloading usually involves all cluster nodes.
 @return DefaultAPINodesReloadSecureSettingsWithNodeIdRequest
*/
func (a *DefaultAPIService) NodesReloadSecureSettingsWithNodeId(ctx context.Context, nodeId string) DefaultAPINodesReloadSecureSettingsWithNodeIdRequest {
	return DefaultAPINodesReloadSecureSettingsWithNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesReloadSecureSettingsWithNodeIdExecute(r DefaultAPINodesReloadSecureSettingsWithNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesReloadSecureSettingsWithNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/reload_secure_settings"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesStatsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *NodesStatLevel
	types *[]string
	timeout *string
	includeSegmentFileSizes *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsRequest) CompletionFields(completionFields []string) DefaultAPINodesStatsRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsRequest) FielddataFields(fielddataFields []string) DefaultAPINodesStatsRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsRequest) Fields(fields []string) DefaultAPINodesStatsRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r DefaultAPINodesStatsRequest) Groups(groups []string) DefaultAPINodesStatsRequest {
	r.groups = &groups
	return r
}

// Return indices stats aggregated at index, node or shard level.
func (r DefaultAPINodesStatsRequest) Level(level NodesStatLevel) DefaultAPINodesStatsRequest {
	r.level = &level
	return r
}

// Comma-separated list of document types for the &#x60;indexing&#x60; index metric.
func (r DefaultAPINodesStatsRequest) Types(types []string) DefaultAPINodesStatsRequest {
	r.types = &types
	return r
}

// Operation timeout.
func (r DefaultAPINodesStatsRequest) Timeout(timeout string) DefaultAPINodesStatsRequest {
	r.timeout = &timeout
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r DefaultAPINodesStatsRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) DefaultAPINodesStatsRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

func (r DefaultAPINodesStatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesStatsExecute(r)
}

/*
NodesStats Method for NodesStats

Returns statistical information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPINodesStatsRequest
*/
func (a *DefaultAPIService) NodesStats(ctx context.Context) DefaultAPINodesStatsRequest {
	return DefaultAPINodesStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesStatsExecute(r DefaultAPINodesStatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesStats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesStatsWithIndexMetricMetricRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	indexMetric string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *NodesStatLevel
	types *[]string
	timeout *string
	includeSegmentFileSizes *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithIndexMetricMetricRequest) CompletionFields(completionFields []string) DefaultAPINodesStatsWithIndexMetricMetricRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithIndexMetricMetricRequest) FielddataFields(fielddataFields []string) DefaultAPINodesStatsWithIndexMetricMetricRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithIndexMetricMetricRequest) Fields(fields []string) DefaultAPINodesStatsWithIndexMetricMetricRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r DefaultAPINodesStatsWithIndexMetricMetricRequest) Groups(groups []string) DefaultAPINodesStatsWithIndexMetricMetricRequest {
	r.groups = &groups
	return r
}

// Return indices stats aggregated at index, node or shard level.
func (r DefaultAPINodesStatsWithIndexMetricMetricRequest) Level(level NodesStatLevel) DefaultAPINodesStatsWithIndexMetricMetricRequest {
	r.level = &level
	return r
}

// Comma-separated list of document types for the &#x60;indexing&#x60; index metric.
func (r DefaultAPINodesStatsWithIndexMetricMetricRequest) Types(types []string) DefaultAPINodesStatsWithIndexMetricMetricRequest {
	r.types = &types
	return r
}

// Operation timeout.
func (r DefaultAPINodesStatsWithIndexMetricMetricRequest) Timeout(timeout string) DefaultAPINodesStatsWithIndexMetricMetricRequest {
	r.timeout = &timeout
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r DefaultAPINodesStatsWithIndexMetricMetricRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) DefaultAPINodesStatsWithIndexMetricMetricRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

func (r DefaultAPINodesStatsWithIndexMetricMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesStatsWithIndexMetricMetricExecute(r)
}

/*
NodesStatsWithIndexMetricMetric Method for NodesStatsWithIndexMetricMetric

Returns statistical information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned to the specified metrics.
 @param indexMetric Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
 @return DefaultAPINodesStatsWithIndexMetricMetricRequest
*/
func (a *DefaultAPIService) NodesStatsWithIndexMetricMetric(ctx context.Context, metric string, indexMetric string) DefaultAPINodesStatsWithIndexMetricMetricRequest {
	return DefaultAPINodesStatsWithIndexMetricMetricRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
		indexMetric: indexMetric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesStatsWithIndexMetricMetricExecute(r DefaultAPINodesStatsWithIndexMetricMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesStatsWithIndexMetricMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/stats/{metric}/{index_metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index_metric"+"}", url.PathEscape(parameterValueToString(r.indexMetric, "indexMetric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	indexMetric string
	nodeId string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *NodesStatLevel
	types *[]string
	timeout *string
	includeSegmentFileSizes *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest) CompletionFields(completionFields []string) DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest) FielddataFields(fielddataFields []string) DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest) Fields(fields []string) DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest) Groups(groups []string) DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest {
	r.groups = &groups
	return r
}

// Return indices stats aggregated at index, node or shard level.
func (r DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest) Level(level NodesStatLevel) DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest {
	r.level = &level
	return r
}

// Comma-separated list of document types for the &#x60;indexing&#x60; index metric.
func (r DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest) Types(types []string) DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest {
	r.types = &types
	return r
}

// Operation timeout.
func (r DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest) Timeout(timeout string) DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest {
	r.timeout = &timeout
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

func (r DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesStatsWithIndexMetricMetricNodeIdExecute(r)
}

/*
NodesStatsWithIndexMetricMetricNodeId Method for NodesStatsWithIndexMetricMetricNodeId

Returns statistical information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned to the specified metrics.
 @param indexMetric Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest
*/
func (a *DefaultAPIService) NodesStatsWithIndexMetricMetricNodeId(ctx context.Context, metric string, indexMetric string, nodeId string) DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest {
	return DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
		indexMetric: indexMetric,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesStatsWithIndexMetricMetricNodeIdExecute(r DefaultAPINodesStatsWithIndexMetricMetricNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesStatsWithIndexMetricMetricNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/stats/{metric}/{index_metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index_metric"+"}", url.PathEscape(parameterValueToString(r.indexMetric, "indexMetric")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesStatsWithMetricRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *NodesStatLevel
	types *[]string
	timeout *string
	includeSegmentFileSizes *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithMetricRequest) CompletionFields(completionFields []string) DefaultAPINodesStatsWithMetricRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithMetricRequest) FielddataFields(fielddataFields []string) DefaultAPINodesStatsWithMetricRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithMetricRequest) Fields(fields []string) DefaultAPINodesStatsWithMetricRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r DefaultAPINodesStatsWithMetricRequest) Groups(groups []string) DefaultAPINodesStatsWithMetricRequest {
	r.groups = &groups
	return r
}

// Return indices stats aggregated at index, node or shard level.
func (r DefaultAPINodesStatsWithMetricRequest) Level(level NodesStatLevel) DefaultAPINodesStatsWithMetricRequest {
	r.level = &level
	return r
}

// Comma-separated list of document types for the &#x60;indexing&#x60; index metric.
func (r DefaultAPINodesStatsWithMetricRequest) Types(types []string) DefaultAPINodesStatsWithMetricRequest {
	r.types = &types
	return r
}

// Operation timeout.
func (r DefaultAPINodesStatsWithMetricRequest) Timeout(timeout string) DefaultAPINodesStatsWithMetricRequest {
	r.timeout = &timeout
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r DefaultAPINodesStatsWithMetricRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) DefaultAPINodesStatsWithMetricRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

func (r DefaultAPINodesStatsWithMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesStatsWithMetricExecute(r)
}

/*
NodesStatsWithMetric Method for NodesStatsWithMetric

Returns statistical information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned to the specified metrics.
 @return DefaultAPINodesStatsWithMetricRequest
*/
func (a *DefaultAPIService) NodesStatsWithMetric(ctx context.Context, metric string) DefaultAPINodesStatsWithMetricRequest {
	return DefaultAPINodesStatsWithMetricRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesStatsWithMetricExecute(r DefaultAPINodesStatsWithMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesStatsWithMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/stats/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesStatsWithMetricNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	nodeId string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *NodesStatLevel
	types *[]string
	timeout *string
	includeSegmentFileSizes *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithMetricNodeIdRequest) CompletionFields(completionFields []string) DefaultAPINodesStatsWithMetricNodeIdRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithMetricNodeIdRequest) FielddataFields(fielddataFields []string) DefaultAPINodesStatsWithMetricNodeIdRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithMetricNodeIdRequest) Fields(fields []string) DefaultAPINodesStatsWithMetricNodeIdRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r DefaultAPINodesStatsWithMetricNodeIdRequest) Groups(groups []string) DefaultAPINodesStatsWithMetricNodeIdRequest {
	r.groups = &groups
	return r
}

// Return indices stats aggregated at index, node or shard level.
func (r DefaultAPINodesStatsWithMetricNodeIdRequest) Level(level NodesStatLevel) DefaultAPINodesStatsWithMetricNodeIdRequest {
	r.level = &level
	return r
}

// Comma-separated list of document types for the &#x60;indexing&#x60; index metric.
func (r DefaultAPINodesStatsWithMetricNodeIdRequest) Types(types []string) DefaultAPINodesStatsWithMetricNodeIdRequest {
	r.types = &types
	return r
}

// Operation timeout.
func (r DefaultAPINodesStatsWithMetricNodeIdRequest) Timeout(timeout string) DefaultAPINodesStatsWithMetricNodeIdRequest {
	r.timeout = &timeout
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r DefaultAPINodesStatsWithMetricNodeIdRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) DefaultAPINodesStatsWithMetricNodeIdRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

func (r DefaultAPINodesStatsWithMetricNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesStatsWithMetricNodeIdExecute(r)
}

/*
NodesStatsWithMetricNodeId Method for NodesStatsWithMetricNodeId

Returns statistical information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned to the specified metrics.
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return DefaultAPINodesStatsWithMetricNodeIdRequest
*/
func (a *DefaultAPIService) NodesStatsWithMetricNodeId(ctx context.Context, metric string, nodeId string) DefaultAPINodesStatsWithMetricNodeIdRequest {
	return DefaultAPINodesStatsWithMetricNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesStatsWithMetricNodeIdExecute(r DefaultAPINodesStatsWithMetricNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesStatsWithMetricNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/stats/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesStatsWithNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	completionFields *[]string
	fielddataFields *[]string
	fields *[]string
	groups *[]string
	level *NodesStatLevel
	types *[]string
	timeout *string
	includeSegmentFileSizes *bool
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;suggest&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithNodeIdRequest) CompletionFields(completionFields []string) DefaultAPINodesStatsWithNodeIdRequest {
	r.completionFields = &completionFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithNodeIdRequest) FielddataFields(fielddataFields []string) DefaultAPINodesStatsWithNodeIdRequest {
	r.fielddataFields = &fielddataFields
	return r
}

// Comma-separated list of fields for &#x60;fielddata&#x60; and &#x60;completion&#x60; index metric (supports wildcards).
func (r DefaultAPINodesStatsWithNodeIdRequest) Fields(fields []string) DefaultAPINodesStatsWithNodeIdRequest {
	r.fields = &fields
	return r
}

// Comma-separated list of search groups for &#x60;search&#x60; index metric.
func (r DefaultAPINodesStatsWithNodeIdRequest) Groups(groups []string) DefaultAPINodesStatsWithNodeIdRequest {
	r.groups = &groups
	return r
}

// Return indices stats aggregated at index, node or shard level.
func (r DefaultAPINodesStatsWithNodeIdRequest) Level(level NodesStatLevel) DefaultAPINodesStatsWithNodeIdRequest {
	r.level = &level
	return r
}

// Comma-separated list of document types for the &#x60;indexing&#x60; index metric.
func (r DefaultAPINodesStatsWithNodeIdRequest) Types(types []string) DefaultAPINodesStatsWithNodeIdRequest {
	r.types = &types
	return r
}

// Operation timeout.
func (r DefaultAPINodesStatsWithNodeIdRequest) Timeout(timeout string) DefaultAPINodesStatsWithNodeIdRequest {
	r.timeout = &timeout
	return r
}

// Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
func (r DefaultAPINodesStatsWithNodeIdRequest) IncludeSegmentFileSizes(includeSegmentFileSizes bool) DefaultAPINodesStatsWithNodeIdRequest {
	r.includeSegmentFileSizes = &includeSegmentFileSizes
	return r
}

func (r DefaultAPINodesStatsWithNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesStatsWithNodeIdExecute(r)
}

/*
NodesStatsWithNodeId Method for NodesStatsWithNodeId

Returns statistical information about nodes in the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return DefaultAPINodesStatsWithNodeIdRequest
*/
func (a *DefaultAPIService) NodesStatsWithNodeId(ctx context.Context, nodeId string) DefaultAPINodesStatsWithNodeIdRequest {
	return DefaultAPINodesStatsWithNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesStatsWithNodeIdExecute(r DefaultAPINodesStatsWithNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesStatsWithNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completionFields != nil {
		t := *r.completionFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completion_fields", t, "multi")
		}
	}
	if r.fielddataFields != nil {
		t := *r.fielddataFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fielddata_fields", t, "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.includeSegmentFileSizes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_segment_file_sizes", r.includeSegmentFileSizes, "")
	} else {
		var defaultValue bool = false
		r.includeSegmentFileSizes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesUsageRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	timeout *string
}

// Operation timeout.
func (r DefaultAPINodesUsageRequest) Timeout(timeout string) DefaultAPINodesUsageRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesUsageRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesUsageExecute(r)
}

/*
NodesUsage Method for NodesUsage

Returns low-level information about REST actions usage on nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPINodesUsageRequest
*/
func (a *DefaultAPIService) NodesUsage(ctx context.Context) DefaultAPINodesUsageRequest {
	return DefaultAPINodesUsageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesUsageExecute(r DefaultAPINodesUsageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesUsage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesUsageWithMetricRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	timeout *string
}

// Operation timeout.
func (r DefaultAPINodesUsageWithMetricRequest) Timeout(timeout string) DefaultAPINodesUsageWithMetricRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesUsageWithMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesUsageWithMetricExecute(r)
}

/*
NodesUsageWithMetric Method for NodesUsageWithMetric

Returns low-level information about REST actions usage on nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned to the specified metrics.
 @return DefaultAPINodesUsageWithMetricRequest
*/
func (a *DefaultAPIService) NodesUsageWithMetric(ctx context.Context, metric string) DefaultAPINodesUsageWithMetricRequest {
	return DefaultAPINodesUsageWithMetricRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesUsageWithMetricExecute(r DefaultAPINodesUsageWithMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesUsageWithMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/usage/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesUsageWithMetricNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	metric string
	nodeId string
	timeout *string
}

// Operation timeout.
func (r DefaultAPINodesUsageWithMetricNodeIdRequest) Timeout(timeout string) DefaultAPINodesUsageWithMetricNodeIdRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesUsageWithMetricNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesUsageWithMetricNodeIdExecute(r)
}

/*
NodesUsageWithMetricNodeId Method for NodesUsageWithMetricNodeId

Returns low-level information about REST actions usage on nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metric Limit the information returned to the specified metrics.
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return DefaultAPINodesUsageWithMetricNodeIdRequest
*/
func (a *DefaultAPIService) NodesUsageWithMetricNodeId(ctx context.Context, metric string, nodeId string) DefaultAPINodesUsageWithMetricNodeIdRequest {
	return DefaultAPINodesUsageWithMetricNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		metric: metric,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesUsageWithMetricNodeIdExecute(r DefaultAPINodesUsageWithMetricNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesUsageWithMetricNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/usage/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPINodesUsageWithNodeIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodeId string
	timeout *string
}

// Operation timeout.
func (r DefaultAPINodesUsageWithNodeIdRequest) Timeout(timeout string) DefaultAPINodesUsageWithNodeIdRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPINodesUsageWithNodeIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.NodesUsageWithNodeIdExecute(r)
}

/*
NodesUsageWithNodeId Method for NodesUsageWithNodeId

Returns low-level information about REST actions usage on nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
 @return DefaultAPINodesUsageWithNodeIdRequest
*/
func (a *DefaultAPIService) NodesUsageWithNodeId(ctx context.Context, nodeId string) DefaultAPINodesUsageWithNodeIdRequest {
	return DefaultAPINodesUsageWithNodeIdRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NodesUsageWithNodeIdExecute(r DefaultAPINodesUsageWithNodeIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NodesUsageWithNodeId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_nodes/{node_id}/usage"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIPatchActionGroupRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	actionGroup string
	patchOperation *[]PatchOperation
}

func (r DefaultAPIPatchActionGroupRequest) PatchOperation(patchOperation []PatchOperation) DefaultAPIPatchActionGroupRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r DefaultAPIPatchActionGroupRequest) Execute() (*PatchActionGroupResponseContent, *http.Response, error) {
	return r.ApiService.PatchActionGroupExecute(r)
}

/*
PatchActionGroup Method for PatchActionGroup

Updates individual attributes of an action group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionGroup
 @return DefaultAPIPatchActionGroupRequest
*/
func (a *DefaultAPIService) PatchActionGroup(ctx context.Context, actionGroup string) DefaultAPIPatchActionGroupRequest {
	return DefaultAPIPatchActionGroupRequest{
		ApiService: a,
		ctx: ctx,
		actionGroup: actionGroup,
	}
}

// Execute executes the request
//  @return PatchActionGroupResponseContent
func (a *DefaultAPIService) PatchActionGroupExecute(r DefaultAPIPatchActionGroupRequest) (*PatchActionGroupResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchActionGroupResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchActionGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/actiongroups/{action_group}"
	localVarPath = strings.Replace(localVarPath, "{"+"action_group"+"}", url.PathEscape(parameterValueToString(r.actionGroup, "actionGroup")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIPatchActionGroupsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r DefaultAPIPatchActionGroupsRequest) PatchOperation(patchOperation []PatchOperation) DefaultAPIPatchActionGroupsRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r DefaultAPIPatchActionGroupsRequest) Execute() (*PatchActionGroupsResponseContent, *http.Response, error) {
	return r.ApiService.PatchActionGroupsExecute(r)
}

/*
PatchActionGroups Method for PatchActionGroups

Creates, updates, or deletes multiple action groups in a single call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIPatchActionGroupsRequest
*/
func (a *DefaultAPIService) PatchActionGroups(ctx context.Context) DefaultAPIPatchActionGroupsRequest {
	return DefaultAPIPatchActionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchActionGroupsResponseContent
func (a *DefaultAPIService) PatchActionGroupsExecute(r DefaultAPIPatchActionGroupsRequest) (*PatchActionGroupsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchActionGroupsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchActionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/actiongroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIPatchAuditConfigurationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r DefaultAPIPatchAuditConfigurationRequest) PatchOperation(patchOperation []PatchOperation) DefaultAPIPatchAuditConfigurationRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r DefaultAPIPatchAuditConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.PatchAuditConfigurationExecute(r)
}

/*
PatchAuditConfiguration Method for PatchAuditConfiguration

A PATCH call is used to update specified fields in the audit configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIPatchAuditConfigurationRequest
*/
func (a *DefaultAPIService) PatchAuditConfiguration(ctx context.Context) DefaultAPIPatchAuditConfigurationRequest {
	return DefaultAPIPatchAuditConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PatchAuditConfigurationExecute(r DefaultAPIPatchAuditConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchAuditConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/audit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIPatchConfigurationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r DefaultAPIPatchConfigurationRequest) PatchOperation(patchOperation []PatchOperation) DefaultAPIPatchConfigurationRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r DefaultAPIPatchConfigurationRequest) Execute() (*PatchConfigurationResponseContent, *http.Response, error) {
	return r.ApiService.PatchConfigurationExecute(r)
}

/*
PatchConfiguration Method for PatchConfiguration

A PATCH call is used to update the existing configuration using the REST API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIPatchConfigurationRequest
*/
func (a *DefaultAPIService) PatchConfiguration(ctx context.Context) DefaultAPIPatchConfigurationRequest {
	return DefaultAPIPatchConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchConfigurationResponseContent
func (a *DefaultAPIService) PatchConfigurationExecute(r DefaultAPIPatchConfigurationRequest) (*PatchConfigurationResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchConfigurationResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/securityconfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIPatchDistinguishedNamesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r DefaultAPIPatchDistinguishedNamesRequest) PatchOperation(patchOperation []PatchOperation) DefaultAPIPatchDistinguishedNamesRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r DefaultAPIPatchDistinguishedNamesRequest) Execute() (*PatchDistinguishedNamesResponseContent, *http.Response, error) {
	return r.ApiService.PatchDistinguishedNamesExecute(r)
}

/*
PatchDistinguishedNames Method for PatchDistinguishedNames

Bulk update of distinguished names.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIPatchDistinguishedNamesRequest
*/
func (a *DefaultAPIService) PatchDistinguishedNames(ctx context.Context) DefaultAPIPatchDistinguishedNamesRequest {
	return DefaultAPIPatchDistinguishedNamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchDistinguishedNamesResponseContent
func (a *DefaultAPIService) PatchDistinguishedNamesExecute(r DefaultAPIPatchDistinguishedNamesRequest) (*PatchDistinguishedNamesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchDistinguishedNamesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchDistinguishedNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/nodesdn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIPatchRoleRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
	patchOperation *[]PatchOperation
}

func (r DefaultAPIPatchRoleRequest) PatchOperation(patchOperation []PatchOperation) DefaultAPIPatchRoleRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r DefaultAPIPatchRoleRequest) Execute() (*PatchRoleResponseContent, *http.Response, error) {
	return r.ApiService.PatchRoleExecute(r)
}

/*
PatchRole Method for PatchRole

Updates individual attributes of a role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return DefaultAPIPatchRoleRequest
*/
func (a *DefaultAPIService) PatchRole(ctx context.Context, role string) DefaultAPIPatchRoleRequest {
	return DefaultAPIPatchRoleRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return PatchRoleResponseContent
func (a *DefaultAPIService) PatchRoleExecute(r DefaultAPIPatchRoleRequest) (*PatchRoleResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchRoleResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/roles/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIPatchRoleMappingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	role string
	patchOperation *[]PatchOperation
}

func (r DefaultAPIPatchRoleMappingRequest) PatchOperation(patchOperation []PatchOperation) DefaultAPIPatchRoleMappingRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r DefaultAPIPatchRoleMappingRequest) Execute() (*PatchRoleMappingResponseContent, *http.Response, error) {
	return r.ApiService.PatchRoleMappingExecute(r)
}

/*
PatchRoleMapping Method for PatchRoleMapping

Updates individual attributes of a role mapping.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param role
 @return DefaultAPIPatchRoleMappingRequest
*/
func (a *DefaultAPIService) PatchRoleMapping(ctx context.Context, role string) DefaultAPIPatchRoleMappingRequest {
	return DefaultAPIPatchRoleMappingRequest{
		ApiService: a,
		ctx: ctx,
		role: role,
	}
}

// Execute executes the request
//  @return PatchRoleMappingResponseContent
func (a *DefaultAPIService) PatchRoleMappingExecute(r DefaultAPIPatchRoleMappingRequest) (*PatchRoleMappingResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchRoleMappingResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchRoleMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/rolesmapping/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", url.PathEscape(parameterValueToString(r.role, "role")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIPatchRoleMappingsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r DefaultAPIPatchRoleMappingsRequest) PatchOperation(patchOperation []PatchOperation) DefaultAPIPatchRoleMappingsRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r DefaultAPIPatchRoleMappingsRequest) Execute() (*PatchRoleMappingsResponseContent, *http.Response, error) {
	return r.ApiService.PatchRoleMappingsExecute(r)
}

/*
PatchRoleMappings Method for PatchRoleMappings

Creates or updates multiple role mappings in a single call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIPatchRoleMappingsRequest
*/
func (a *DefaultAPIService) PatchRoleMappings(ctx context.Context) DefaultAPIPatchRoleMappingsRequest {
	return DefaultAPIPatchRoleMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchRoleMappingsResponseContent
func (a *DefaultAPIService) PatchRoleMappingsExecute(r DefaultAPIPatchRoleMappingsRequest) (*PatchRoleMappingsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchRoleMappingsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchRoleMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/rolesmapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIPatchRolesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r DefaultAPIPatchRolesRequest) PatchOperation(patchOperation []PatchOperation) DefaultAPIPatchRolesRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r DefaultAPIPatchRolesRequest) Execute() (*PatchRolesResponseContent, *http.Response, error) {
	return r.ApiService.PatchRolesExecute(r)
}

/*
PatchRoles Method for PatchRoles

Creates, updates, or deletes multiple roles in a single call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIPatchRolesRequest
*/
func (a *DefaultAPIService) PatchRoles(ctx context.Context) DefaultAPIPatchRolesRequest {
	return DefaultAPIPatchRolesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchRolesResponseContent
func (a *DefaultAPIService) PatchRolesExecute(r DefaultAPIPatchRolesRequest) (*PatchRolesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchRolesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIPatchTenantRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	tenant string
	patchOperation *[]PatchOperation
}

func (r DefaultAPIPatchTenantRequest) PatchOperation(patchOperation []PatchOperation) DefaultAPIPatchTenantRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r DefaultAPIPatchTenantRequest) Execute() (*PatchTenantResponseContent, *http.Response, error) {
	return r.ApiService.PatchTenantExecute(r)
}

/*
PatchTenant Method for PatchTenant

Add, delete, or modify a single tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @return DefaultAPIPatchTenantRequest
*/
func (a *DefaultAPIService) PatchTenant(ctx context.Context, tenant string) DefaultAPIPatchTenantRequest {
	return DefaultAPIPatchTenantRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
	}
}

// Execute executes the request
//  @return PatchTenantResponseContent
func (a *DefaultAPIService) PatchTenantExecute(r DefaultAPIPatchTenantRequest) (*PatchTenantResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchTenantResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchTenant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/tenants/{tenant}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIPatchTenantsRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r DefaultAPIPatchTenantsRequest) PatchOperation(patchOperation []PatchOperation) DefaultAPIPatchTenantsRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r DefaultAPIPatchTenantsRequest) Execute() (*PatchTenantsResponseContent, *http.Response, error) {
	return r.ApiService.PatchTenantsExecute(r)
}

/*
PatchTenants Method for PatchTenants

Add, delete, or modify multiple tenants in a single call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIPatchTenantsRequest
*/
func (a *DefaultAPIService) PatchTenants(ctx context.Context) DefaultAPIPatchTenantsRequest {
	return DefaultAPIPatchTenantsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchTenantsResponseContent
func (a *DefaultAPIService) PatchTenantsExecute(r DefaultAPIPatchTenantsRequest) (*PatchTenantsResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchTenantsResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchTenants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/tenants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIPatchUserRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	username string
	patchOperation *[]PatchOperation
}

func (r DefaultAPIPatchUserRequest) PatchOperation(patchOperation []PatchOperation) DefaultAPIPatchUserRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r DefaultAPIPatchUserRequest) Execute() (*PatchUserResponseContent, *http.Response, error) {
	return r.ApiService.PatchUserExecute(r)
}

/*
PatchUser Method for PatchUser

Updates individual attributes of an internal user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username
 @return DefaultAPIPatchUserRequest
*/
func (a *DefaultAPIService) PatchUser(ctx context.Context, username string) DefaultAPIPatchUserRequest {
	return DefaultAPIPatchUserRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return PatchUserResponseContent
func (a *DefaultAPIService) PatchUserExecute(r DefaultAPIPatchUserRequest) (*PatchUserResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchUserResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/internalusers/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterValueToString(r.username, "username")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIPatchUsersRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	patchOperation *[]PatchOperation
}

func (r DefaultAPIPatchUsersRequest) PatchOperation(patchOperation []PatchOperation) DefaultAPIPatchUsersRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r DefaultAPIPatchUsersRequest) Execute() (*PatchUsersResponseContent, *http.Response, error) {
	return r.ApiService.PatchUsersExecute(r)
}

/*
PatchUsers Method for PatchUsers

Creates, updates, or deletes multiple internal users in a single call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIPatchUsersRequest
*/
func (a *DefaultAPIService) PatchUsers(ctx context.Context) DefaultAPIPatchUsersRequest {
	return DefaultAPIPatchUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PatchUsersResponseContent
func (a *DefaultAPIService) PatchUsersExecute(r DefaultAPIPatchUsersRequest) (*PatchUsersResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchUsersResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PatchUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/internalusers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIPingRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIPingRequest) Execute() (*http.Response, error) {
	return r.ApiService.PingExecute(r)
}

/*
Ping Method for Ping

Returns whether the cluster is running.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIPingRequest
*/
func (a *DefaultAPIService) Ping(ctx context.Context) DefaultAPIPingRequest {
	return DefaultAPIPingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PingExecute(r DefaultAPIPingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Ping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIPutScriptPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	body *map[string]interface{}
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r DefaultAPIPutScriptPostRequest) Body(body map[string]interface{}) DefaultAPIPutScriptPostRequest {
	r.body = &body
	return r
}

// Operation timeout.
func (r DefaultAPIPutScriptPostRequest) Timeout(timeout string) DefaultAPIPutScriptPostRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIPutScriptPostRequest) MasterTimeout(masterTimeout string) DefaultAPIPutScriptPostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIPutScriptPostRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIPutScriptPostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIPutScriptPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutScriptPostExecute(r)
}

/*
PutScriptPost Method for PutScriptPost

Creates or updates a script.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Script ID.
 @return DefaultAPIPutScriptPostRequest
*/
func (a *DefaultAPIService) PutScriptPost(ctx context.Context, id string) DefaultAPIPutScriptPostRequest {
	return DefaultAPIPutScriptPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PutScriptPostExecute(r DefaultAPIPutScriptPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PutScriptPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIPutScriptPostWithContextRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	context string
	body *map[string]interface{}
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r DefaultAPIPutScriptPostWithContextRequest) Body(body map[string]interface{}) DefaultAPIPutScriptPostWithContextRequest {
	r.body = &body
	return r
}

// Operation timeout.
func (r DefaultAPIPutScriptPostWithContextRequest) Timeout(timeout string) DefaultAPIPutScriptPostWithContextRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIPutScriptPostWithContextRequest) MasterTimeout(masterTimeout string) DefaultAPIPutScriptPostWithContextRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIPutScriptPostWithContextRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIPutScriptPostWithContextRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIPutScriptPostWithContextRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutScriptPostWithContextExecute(r)
}

/*
PutScriptPostWithContext Method for PutScriptPostWithContext

Creates or updates a script.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Script ID.
 @param context Script context.
 @return DefaultAPIPutScriptPostWithContextRequest
*/
func (a *DefaultAPIService) PutScriptPostWithContext(ctx context.Context, id string, context string) DefaultAPIPutScriptPostWithContextRequest {
	return DefaultAPIPutScriptPostWithContextRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		context: context,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PutScriptPostWithContextExecute(r DefaultAPIPutScriptPostWithContextRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PutScriptPostWithContext")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/{id}/{context}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"context"+"}", url.PathEscape(parameterValueToString(r.context, "context")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIPutScriptPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	body *map[string]interface{}
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r DefaultAPIPutScriptPutRequest) Body(body map[string]interface{}) DefaultAPIPutScriptPutRequest {
	r.body = &body
	return r
}

// Operation timeout.
func (r DefaultAPIPutScriptPutRequest) Timeout(timeout string) DefaultAPIPutScriptPutRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIPutScriptPutRequest) MasterTimeout(masterTimeout string) DefaultAPIPutScriptPutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIPutScriptPutRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIPutScriptPutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIPutScriptPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutScriptPutExecute(r)
}

/*
PutScriptPut Method for PutScriptPut

Creates or updates a script.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Script ID.
 @return DefaultAPIPutScriptPutRequest
*/
func (a *DefaultAPIService) PutScriptPut(ctx context.Context, id string) DefaultAPIPutScriptPutRequest {
	return DefaultAPIPutScriptPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PutScriptPutExecute(r DefaultAPIPutScriptPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PutScriptPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIPutScriptPutWithContextRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	context string
	body *map[string]interface{}
	timeout *string
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r DefaultAPIPutScriptPutWithContextRequest) Body(body map[string]interface{}) DefaultAPIPutScriptPutWithContextRequest {
	r.body = &body
	return r
}

// Operation timeout.
func (r DefaultAPIPutScriptPutWithContextRequest) Timeout(timeout string) DefaultAPIPutScriptPutWithContextRequest {
	r.timeout = &timeout
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPIPutScriptPutWithContextRequest) MasterTimeout(masterTimeout string) DefaultAPIPutScriptPutWithContextRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIPutScriptPutWithContextRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIPutScriptPutWithContextRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPIPutScriptPutWithContextRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutScriptPutWithContextExecute(r)
}

/*
PutScriptPutWithContext Method for PutScriptPutWithContext

Creates or updates a script.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Script ID.
 @param context Script context.
 @return DefaultAPIPutScriptPutWithContextRequest
*/
func (a *DefaultAPIService) PutScriptPutWithContext(ctx context.Context, id string, context string) DefaultAPIPutScriptPutWithContextRequest {
	return DefaultAPIPutScriptPutWithContextRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		context: context,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PutScriptPutWithContextExecute(r DefaultAPIPutScriptPutWithContextRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PutScriptPutWithContext")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/{id}/{context}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"context"+"}", url.PathEscape(parameterValueToString(r.context, "context")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIRankEvalGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	searchType *SearchType
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIRankEvalGetRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIRankEvalGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIRankEvalGetRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIRankEvalGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIRankEvalGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIRankEvalGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Search operation type.
func (r DefaultAPIRankEvalGetRequest) SearchType(searchType SearchType) DefaultAPIRankEvalGetRequest {
	r.searchType = &searchType
	return r
}

func (r DefaultAPIRankEvalGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.RankEvalGetExecute(r)
}

/*
RankEvalGet Method for RankEvalGet

Allows to evaluate the quality of ranked search results over a set of typical search queries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIRankEvalGetRequest
*/
func (a *DefaultAPIService) RankEvalGet(ctx context.Context) DefaultAPIRankEvalGetRequest {
	return DefaultAPIRankEvalGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RankEvalGetExecute(r DefaultAPIRankEvalGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RankEvalGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_rank_eval"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIRankEvalGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	searchType *SearchType
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIRankEvalGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIRankEvalGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIRankEvalGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIRankEvalGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIRankEvalGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIRankEvalGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Search operation type.
func (r DefaultAPIRankEvalGetWithIndexRequest) SearchType(searchType SearchType) DefaultAPIRankEvalGetWithIndexRequest {
	r.searchType = &searchType
	return r
}

func (r DefaultAPIRankEvalGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.RankEvalGetWithIndexExecute(r)
}

/*
RankEvalGetWithIndex Method for RankEvalGetWithIndex

Allows to evaluate the quality of ranked search results over a set of typical search queries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIRankEvalGetWithIndexRequest
*/
func (a *DefaultAPIService) RankEvalGetWithIndex(ctx context.Context, index string) DefaultAPIRankEvalGetWithIndexRequest {
	return DefaultAPIRankEvalGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RankEvalGetWithIndexExecute(r DefaultAPIRankEvalGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RankEvalGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_rank_eval"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIRankEvalPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	searchType *SearchType
}

func (r DefaultAPIRankEvalPostRequest) Body(body map[string]interface{}) DefaultAPIRankEvalPostRequest {
	r.body = &body
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIRankEvalPostRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIRankEvalPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIRankEvalPostRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIRankEvalPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIRankEvalPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIRankEvalPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Search operation type.
func (r DefaultAPIRankEvalPostRequest) SearchType(searchType SearchType) DefaultAPIRankEvalPostRequest {
	r.searchType = &searchType
	return r
}

func (r DefaultAPIRankEvalPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.RankEvalPostExecute(r)
}

/*
RankEvalPost Method for RankEvalPost

Allows to evaluate the quality of ranked search results over a set of typical search queries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIRankEvalPostRequest
*/
func (a *DefaultAPIService) RankEvalPost(ctx context.Context) DefaultAPIRankEvalPostRequest {
	return DefaultAPIRankEvalPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RankEvalPostExecute(r DefaultAPIRankEvalPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RankEvalPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_rank_eval"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIRankEvalPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	searchType *SearchType
}

func (r DefaultAPIRankEvalPostWithIndexRequest) Body(body map[string]interface{}) DefaultAPIRankEvalPostWithIndexRequest {
	r.body = &body
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIRankEvalPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIRankEvalPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIRankEvalPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIRankEvalPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIRankEvalPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIRankEvalPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Search operation type.
func (r DefaultAPIRankEvalPostWithIndexRequest) SearchType(searchType SearchType) DefaultAPIRankEvalPostWithIndexRequest {
	r.searchType = &searchType
	return r
}

func (r DefaultAPIRankEvalPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.RankEvalPostWithIndexExecute(r)
}

/*
RankEvalPostWithIndex Method for RankEvalPostWithIndex

Allows to evaluate the quality of ranked search results over a set of typical search queries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIRankEvalPostWithIndexRequest
*/
func (a *DefaultAPIService) RankEvalPostWithIndex(ctx context.Context, index string) DefaultAPIRankEvalPostWithIndexRequest {
	return DefaultAPIRankEvalPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RankEvalPostWithIndexExecute(r DefaultAPIRankEvalPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RankEvalPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_rank_eval"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIReindexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	refresh *bool
	timeout *string
	waitForActiveShards *string
	waitForCompletion *bool
	requestsPerSecond *int32
	scroll *string
	slices *string
	maxDocs *int32
}

func (r DefaultAPIReindexRequest) Body(body map[string]interface{}) DefaultAPIReindexRequest {
	r.body = &body
	return r
}

// Should the affected indexes be refreshed?.
func (r DefaultAPIReindexRequest) Refresh(refresh bool) DefaultAPIReindexRequest {
	r.refresh = &refresh
	return r
}

// Time each individual bulk request should wait for shards that are unavailable.
func (r DefaultAPIReindexRequest) Timeout(timeout string) DefaultAPIReindexRequest {
	r.timeout = &timeout
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r DefaultAPIReindexRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIReindexRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Should this request wait until the operation has completed before returning.
func (r DefaultAPIReindexRequest) WaitForCompletion(waitForCompletion bool) DefaultAPIReindexRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

// The throttle for this request in sub-requests per second. -1 means no throttle.
func (r DefaultAPIReindexRequest) RequestsPerSecond(requestsPerSecond int32) DefaultAPIReindexRequest {
	r.requestsPerSecond = &requestsPerSecond
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPIReindexRequest) Scroll(scroll string) DefaultAPIReindexRequest {
	r.scroll = &scroll
	return r
}

// The number of slices this task should be divided into. Defaults to 1, meaning the task isn&#39;t sliced into subtasks. Can be set to &#x60;auto&#x60;.
func (r DefaultAPIReindexRequest) Slices(slices string) DefaultAPIReindexRequest {
	r.slices = &slices
	return r
}

// Maximum number of documents to process (default: all documents).
func (r DefaultAPIReindexRequest) MaxDocs(maxDocs int32) DefaultAPIReindexRequest {
	r.maxDocs = &maxDocs
	return r
}

func (r DefaultAPIReindexRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReindexExecute(r)
}

/*
Reindex Method for Reindex

Allows to copy documents from one index to another, optionally filtering the source
documents by a query, changing the destination index settings, or fetching the
documents from a remote cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIReindexRequest
*/
func (a *DefaultAPIService) Reindex(ctx context.Context) DefaultAPIReindexRequest {
	return DefaultAPIReindexRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ReindexExecute(r DefaultAPIReindexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Reindex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_reindex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	} else {
		var defaultValue string = "1m"
		r.timeout = &defaultValue
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = true
		r.waitForCompletion = &defaultValue
	}
	if r.requestsPerSecond != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requests_per_second", r.requestsPerSecond, "")
	} else {
		var defaultValue int32 = 0
		r.requestsPerSecond = &defaultValue
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.slices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slices", r.slices, "")
	} else {
		var defaultValue string = "1"
		r.slices = &defaultValue
	}
	if r.maxDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_docs", r.maxDocs, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIReindexRethrottleRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	requestsPerSecond *int32
}

// The throttle for this request in sub-requests per second. -1 means no throttle.
func (r DefaultAPIReindexRethrottleRequest) RequestsPerSecond(requestsPerSecond int32) DefaultAPIReindexRethrottleRequest {
	r.requestsPerSecond = &requestsPerSecond
	return r
}

func (r DefaultAPIReindexRethrottleRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReindexRethrottleExecute(r)
}

/*
ReindexRethrottle Method for ReindexRethrottle

Changes the number of requests per second for a particular Reindex operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id to rethrottle.
 @return DefaultAPIReindexRethrottleRequest
*/
func (a *DefaultAPIService) ReindexRethrottle(ctx context.Context, taskId string) DefaultAPIReindexRethrottleRequest {
	return DefaultAPIReindexRethrottleRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ReindexRethrottleExecute(r DefaultAPIReindexRethrottleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ReindexRethrottle")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_reindex/{task_id}/_rethrottle"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestsPerSecond == nil {
		return nil, reportError("requestsPerSecond is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "requests_per_second", r.requestsPerSecond, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIReloadHttpCertificatesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIReloadHttpCertificatesRequest) Execute() (*ReloadHttpCertificatesResponseContent, *http.Response, error) {
	return r.ApiService.ReloadHttpCertificatesExecute(r)
}

/*
ReloadHttpCertificates Method for ReloadHttpCertificates

Reload HTTP layer communication certificates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIReloadHttpCertificatesRequest
*/
func (a *DefaultAPIService) ReloadHttpCertificates(ctx context.Context) DefaultAPIReloadHttpCertificatesRequest {
	return DefaultAPIReloadHttpCertificatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReloadHttpCertificatesResponseContent
func (a *DefaultAPIService) ReloadHttpCertificatesExecute(r DefaultAPIReloadHttpCertificatesRequest) (*ReloadHttpCertificatesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReloadHttpCertificatesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ReloadHttpCertificates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/ssl/http/reloadcerts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIReloadTransportCertificatesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIReloadTransportCertificatesRequest) Execute() (*ReloadTransportCertificatesResponseContent, *http.Response, error) {
	return r.ApiService.ReloadTransportCertificatesExecute(r)
}

/*
ReloadTransportCertificates Method for ReloadTransportCertificates

Reload transport layer communication certificates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIReloadTransportCertificatesRequest
*/
func (a *DefaultAPIService) ReloadTransportCertificates(ctx context.Context) DefaultAPIReloadTransportCertificatesRequest {
	return DefaultAPIReloadTransportCertificatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReloadTransportCertificatesResponseContent
func (a *DefaultAPIService) ReloadTransportCertificatesExecute(r DefaultAPIReloadTransportCertificatesRequest) (*ReloadTransportCertificatesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReloadTransportCertificatesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ReloadTransportCertificates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/ssl/transport/reloadcerts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIRemoteStoreRestoreRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	remoteStoreRestoreBodyParams *RemoteStoreRestoreBodyParams
	clusterManagerTimeout *string
	waitForCompletion *bool
}

func (r DefaultAPIRemoteStoreRestoreRequest) RemoteStoreRestoreBodyParams(remoteStoreRestoreBodyParams RemoteStoreRestoreBodyParams) DefaultAPIRemoteStoreRestoreRequest {
	r.remoteStoreRestoreBodyParams = &remoteStoreRestoreBodyParams
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPIRemoteStoreRestoreRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPIRemoteStoreRestoreRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Should this request wait until the operation has completed before returning.
func (r DefaultAPIRemoteStoreRestoreRequest) WaitForCompletion(waitForCompletion bool) DefaultAPIRemoteStoreRestoreRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

func (r DefaultAPIRemoteStoreRestoreRequest) Execute() (*RemoteStoreRestoreResponseContent, *http.Response, error) {
	return r.ApiService.RemoteStoreRestoreExecute(r)
}

/*
RemoteStoreRestore Method for RemoteStoreRestore

Restores from remote store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIRemoteStoreRestoreRequest
*/
func (a *DefaultAPIService) RemoteStoreRestore(ctx context.Context) DefaultAPIRemoteStoreRestoreRequest {
	return DefaultAPIRemoteStoreRestoreRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RemoteStoreRestoreResponseContent
func (a *DefaultAPIService) RemoteStoreRestoreExecute(r DefaultAPIRemoteStoreRestoreRequest) (*RemoteStoreRestoreResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemoteStoreRestoreResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RemoteStoreRestore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_remotestore/_restore"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.remoteStoreRestoreBodyParams == nil {
		return localVarReturnValue, nil, reportError("remoteStoreRestoreBodyParams is required and must be specified")
	}

	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.remoteStoreRestoreBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIRenderSearchTemplateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIRenderSearchTemplateGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.RenderSearchTemplateGetExecute(r)
}

/*
RenderSearchTemplateGet Method for RenderSearchTemplateGet

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIRenderSearchTemplateGetRequest
*/
func (a *DefaultAPIService) RenderSearchTemplateGet(ctx context.Context) DefaultAPIRenderSearchTemplateGetRequest {
	return DefaultAPIRenderSearchTemplateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RenderSearchTemplateGetExecute(r DefaultAPIRenderSearchTemplateGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RenderSearchTemplateGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_render/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIRenderSearchTemplateGetWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
}

func (r DefaultAPIRenderSearchTemplateGetWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.RenderSearchTemplateGetWithIdExecute(r)
}

/*
RenderSearchTemplateGetWithId Method for RenderSearchTemplateGetWithId

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the stored search template.
 @return DefaultAPIRenderSearchTemplateGetWithIdRequest
*/
func (a *DefaultAPIService) RenderSearchTemplateGetWithId(ctx context.Context, id string) DefaultAPIRenderSearchTemplateGetWithIdRequest {
	return DefaultAPIRenderSearchTemplateGetWithIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RenderSearchTemplateGetWithIdExecute(r DefaultAPIRenderSearchTemplateGetWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RenderSearchTemplateGetWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_render/template/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIRenderSearchTemplatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
}

func (r DefaultAPIRenderSearchTemplatePostRequest) Body(body map[string]interface{}) DefaultAPIRenderSearchTemplatePostRequest {
	r.body = &body
	return r
}

func (r DefaultAPIRenderSearchTemplatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.RenderSearchTemplatePostExecute(r)
}

/*
RenderSearchTemplatePost Method for RenderSearchTemplatePost

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIRenderSearchTemplatePostRequest
*/
func (a *DefaultAPIService) RenderSearchTemplatePost(ctx context.Context) DefaultAPIRenderSearchTemplatePostRequest {
	return DefaultAPIRenderSearchTemplatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RenderSearchTemplatePostExecute(r DefaultAPIRenderSearchTemplatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RenderSearchTemplatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_render/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIRenderSearchTemplatePostWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	body *map[string]interface{}
}

func (r DefaultAPIRenderSearchTemplatePostWithIdRequest) Body(body map[string]interface{}) DefaultAPIRenderSearchTemplatePostWithIdRequest {
	r.body = &body
	return r
}

func (r DefaultAPIRenderSearchTemplatePostWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.RenderSearchTemplatePostWithIdExecute(r)
}

/*
RenderSearchTemplatePostWithId Method for RenderSearchTemplatePostWithId

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the stored search template.
 @return DefaultAPIRenderSearchTemplatePostWithIdRequest
*/
func (a *DefaultAPIService) RenderSearchTemplatePostWithId(ctx context.Context, id string) DefaultAPIRenderSearchTemplatePostWithIdRequest {
	return DefaultAPIRenderSearchTemplatePostWithIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RenderSearchTemplatePostWithIdExecute(r DefaultAPIRenderSearchTemplatePostWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RenderSearchTemplatePostWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_render/template/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIScriptsPainlessExecuteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPIScriptsPainlessExecuteGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScriptsPainlessExecuteGetExecute(r)
}

/*
ScriptsPainlessExecuteGet Method for ScriptsPainlessExecuteGet

Allows an arbitrary script to be executed and a result to be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIScriptsPainlessExecuteGetRequest
*/
func (a *DefaultAPIService) ScriptsPainlessExecuteGet(ctx context.Context) DefaultAPIScriptsPainlessExecuteGetRequest {
	return DefaultAPIScriptsPainlessExecuteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScriptsPainlessExecuteGetExecute(r DefaultAPIScriptsPainlessExecuteGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScriptsPainlessExecuteGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/painless/_execute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIScriptsPainlessExecutePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
}

func (r DefaultAPIScriptsPainlessExecutePostRequest) Body(body map[string]interface{}) DefaultAPIScriptsPainlessExecutePostRequest {
	r.body = &body
	return r
}

func (r DefaultAPIScriptsPainlessExecutePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScriptsPainlessExecutePostExecute(r)
}

/*
ScriptsPainlessExecutePost Method for ScriptsPainlessExecutePost

Allows an arbitrary script to be executed and a result to be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIScriptsPainlessExecutePostRequest
*/
func (a *DefaultAPIService) ScriptsPainlessExecutePost(ctx context.Context) DefaultAPIScriptsPainlessExecutePostRequest {
	return DefaultAPIScriptsPainlessExecutePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScriptsPainlessExecutePostExecute(r DefaultAPIScriptsPainlessExecutePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScriptsPainlessExecutePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_scripts/painless/_execute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIScrollGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	scroll *string
	scrollId *string
	restTotalHitsAsInt *bool
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPIScrollGetRequest) Scroll(scroll string) DefaultAPIScrollGetRequest {
	r.scroll = &scroll
	return r
}

// Scroll ID.
func (r DefaultAPIScrollGetRequest) ScrollId(scrollId string) DefaultAPIScrollGetRequest {
	r.scrollId = &scrollId
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPIScrollGetRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPIScrollGetRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r DefaultAPIScrollGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScrollGetExecute(r)
}

/*
ScrollGet Method for ScrollGet

Allows to retrieve a large numbers of results from a single search request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIScrollGetRequest
*/
func (a *DefaultAPIService) ScrollGet(ctx context.Context) DefaultAPIScrollGetRequest {
	return DefaultAPIScrollGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScrollGetExecute(r DefaultAPIScrollGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScrollGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/scroll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.scrollId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll_id", r.scrollId, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIScrollGetWithScrollIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	scrollId string
	scroll *string
	scrollId2 *string
	restTotalHitsAsInt *bool
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPIScrollGetWithScrollIdRequest) Scroll(scroll string) DefaultAPIScrollGetWithScrollIdRequest {
	r.scroll = &scroll
	return r
}

// Scroll ID.
func (r DefaultAPIScrollGetWithScrollIdRequest) ScrollId2(scrollId2 string) DefaultAPIScrollGetWithScrollIdRequest {
	r.scrollId2 = &scrollId2
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPIScrollGetWithScrollIdRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPIScrollGetWithScrollIdRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r DefaultAPIScrollGetWithScrollIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScrollGetWithScrollIdExecute(r)
}

/*
ScrollGetWithScrollId Method for ScrollGetWithScrollId

Allows to retrieve a large numbers of results from a single search request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param scrollId Scroll ID.
 @return DefaultAPIScrollGetWithScrollIdRequest

Deprecated
*/
func (a *DefaultAPIService) ScrollGetWithScrollId(ctx context.Context, scrollId string) DefaultAPIScrollGetWithScrollIdRequest {
	return DefaultAPIScrollGetWithScrollIdRequest{
		ApiService: a,
		ctx: ctx,
		scrollId: scrollId,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) ScrollGetWithScrollIdExecute(r DefaultAPIScrollGetWithScrollIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScrollGetWithScrollId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/scroll/{scroll_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"scroll_id"+"}", url.PathEscape(parameterValueToString(r.scrollId, "scrollId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.scrollId2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll_id", r.scrollId2, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIScrollPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	scroll *string
	scrollId *string
	restTotalHitsAsInt *bool
	body *map[string]interface{}
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPIScrollPostRequest) Scroll(scroll string) DefaultAPIScrollPostRequest {
	r.scroll = &scroll
	return r
}

// Scroll ID.
func (r DefaultAPIScrollPostRequest) ScrollId(scrollId string) DefaultAPIScrollPostRequest {
	r.scrollId = &scrollId
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPIScrollPostRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPIScrollPostRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r DefaultAPIScrollPostRequest) Body(body map[string]interface{}) DefaultAPIScrollPostRequest {
	r.body = &body
	return r
}

func (r DefaultAPIScrollPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScrollPostExecute(r)
}

/*
ScrollPost Method for ScrollPost

Allows to retrieve a large numbers of results from a single search request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIScrollPostRequest
*/
func (a *DefaultAPIService) ScrollPost(ctx context.Context) DefaultAPIScrollPostRequest {
	return DefaultAPIScrollPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScrollPostExecute(r DefaultAPIScrollPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScrollPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/scroll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.scrollId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll_id", r.scrollId, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIScrollPostWithScrollIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	scrollId string
	scroll *string
	scrollId2 *string
	restTotalHitsAsInt *bool
	body *map[string]interface{}
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPIScrollPostWithScrollIdRequest) Scroll(scroll string) DefaultAPIScrollPostWithScrollIdRequest {
	r.scroll = &scroll
	return r
}

// Scroll ID.
func (r DefaultAPIScrollPostWithScrollIdRequest) ScrollId2(scrollId2 string) DefaultAPIScrollPostWithScrollIdRequest {
	r.scrollId2 = &scrollId2
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPIScrollPostWithScrollIdRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPIScrollPostWithScrollIdRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r DefaultAPIScrollPostWithScrollIdRequest) Body(body map[string]interface{}) DefaultAPIScrollPostWithScrollIdRequest {
	r.body = &body
	return r
}

func (r DefaultAPIScrollPostWithScrollIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScrollPostWithScrollIdExecute(r)
}

/*
ScrollPostWithScrollId Method for ScrollPostWithScrollId

Allows to retrieve a large numbers of results from a single search request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param scrollId Scroll ID.
 @return DefaultAPIScrollPostWithScrollIdRequest

Deprecated
*/
func (a *DefaultAPIService) ScrollPostWithScrollId(ctx context.Context, scrollId string) DefaultAPIScrollPostWithScrollIdRequest {
	return DefaultAPIScrollPostWithScrollIdRequest{
		ApiService: a,
		ctx: ctx,
		scrollId: scrollId,
	}
}

// Execute executes the request
// Deprecated
func (a *DefaultAPIService) ScrollPostWithScrollIdExecute(r DefaultAPIScrollPostWithScrollIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScrollPostWithScrollId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/scroll/{scroll_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"scroll_id"+"}", url.PathEscape(parameterValueToString(r.scrollId, "scrollId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.scrollId2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll_id", r.scrollId2, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISearchGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	analyzer *string
	analyzeWildcard *bool
	ccsMinimizeRoundtrips *bool
	defaultOperator *DefaultOperator
	df *string
	explain *bool
	storedFields *[]string
	docvalueFields *[]string
	from *int32
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	lenient *bool
	preference *string
	q *string
	routing *[]string
	scroll *string
	searchType *SearchType
	size *int32
	sort *[]string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	terminateAfter *int32
	stats *[]string
	suggestField *string
	suggestMode *SuggestMode
	suggestSize *int32
	suggestText *string
	timeout *string
	trackScores *bool
	trackTotalHits *bool
	allowPartialSearchResults *bool
	typedKeys *bool
	version *bool
	seqNoPrimaryTerm *bool
	requestCache *bool
	batchedReduceSize *int32
	maxConcurrentShardRequests *int32
	preFilterShardSize *int32
	restTotalHitsAsInt *bool
}

// The analyzer to use for the query string.
func (r DefaultAPISearchGetRequest) Analyzer(analyzer string) DefaultAPISearchGetRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r DefaultAPISearchGetRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPISearchGetRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPISearchGetRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPISearchGetRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPISearchGetRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPISearchGetRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r DefaultAPISearchGetRequest) Df(df string) DefaultAPISearchGetRequest {
	r.df = &df
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r DefaultAPISearchGetRequest) Explain(explain bool) DefaultAPISearchGetRequest {
	r.explain = &explain
	return r
}

// Comma-separated list of stored fields to return.
func (r DefaultAPISearchGetRequest) StoredFields(storedFields []string) DefaultAPISearchGetRequest {
	r.storedFields = &storedFields
	return r
}

// Comma-separated list of fields to return as the docvalue representation of a field for each hit.
func (r DefaultAPISearchGetRequest) DocvalueFields(docvalueFields []string) DefaultAPISearchGetRequest {
	r.docvalueFields = &docvalueFields
	return r
}

// Starting offset.
func (r DefaultAPISearchGetRequest) From(from int32) DefaultAPISearchGetRequest {
	r.from = &from
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPISearchGetRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISearchGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r DefaultAPISearchGetRequest) IgnoreThrottled(ignoreThrottled bool) DefaultAPISearchGetRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPISearchGetRequest) AllowNoIndices(allowNoIndices bool) DefaultAPISearchGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPISearchGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPISearchGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPISearchGetRequest) Lenient(lenient bool) DefaultAPISearchGetRequest {
	r.lenient = &lenient
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPISearchGetRequest) Preference(preference string) DefaultAPISearchGetRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPISearchGetRequest) Q(q string) DefaultAPISearchGetRequest {
	r.q = &q
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPISearchGetRequest) Routing(routing []string) DefaultAPISearchGetRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPISearchGetRequest) Scroll(scroll string) DefaultAPISearchGetRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r DefaultAPISearchGetRequest) SearchType(searchType SearchType) DefaultAPISearchGetRequest {
	r.searchType = &searchType
	return r
}

// Number of hits to return.
func (r DefaultAPISearchGetRequest) Size(size int32) DefaultAPISearchGetRequest {
	r.size = &size
	return r
}

// Comma-separated list of &lt;field&gt;:&lt;direction&gt; pairs.
func (r DefaultAPISearchGetRequest) Sort(sort []string) DefaultAPISearchGetRequest {
	r.sort = &sort
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPISearchGetRequest) Source(source []string) DefaultAPISearchGetRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPISearchGetRequest) SourceExcludes(sourceExcludes []string) DefaultAPISearchGetRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPISearchGetRequest) SourceIncludes(sourceIncludes []string) DefaultAPISearchGetRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r DefaultAPISearchGetRequest) TerminateAfter(terminateAfter int32) DefaultAPISearchGetRequest {
	r.terminateAfter = &terminateAfter
	return r
}

// Specific &#39;tag&#39; of the request for logging and statistical purposes.
func (r DefaultAPISearchGetRequest) Stats(stats []string) DefaultAPISearchGetRequest {
	r.stats = &stats
	return r
}

// Specify which field to use for suggestions.
func (r DefaultAPISearchGetRequest) SuggestField(suggestField string) DefaultAPISearchGetRequest {
	r.suggestField = &suggestField
	return r
}

// Specify suggest mode.
func (r DefaultAPISearchGetRequest) SuggestMode(suggestMode SuggestMode) DefaultAPISearchGetRequest {
	r.suggestMode = &suggestMode
	return r
}

// How many suggestions to return in response.
func (r DefaultAPISearchGetRequest) SuggestSize(suggestSize int32) DefaultAPISearchGetRequest {
	r.suggestSize = &suggestSize
	return r
}

// The source text for which the suggestions should be returned.
func (r DefaultAPISearchGetRequest) SuggestText(suggestText string) DefaultAPISearchGetRequest {
	r.suggestText = &suggestText
	return r
}

// Operation timeout.
func (r DefaultAPISearchGetRequest) Timeout(timeout string) DefaultAPISearchGetRequest {
	r.timeout = &timeout
	return r
}

// Whether to calculate and return scores even if they are not used for sorting.
func (r DefaultAPISearchGetRequest) TrackScores(trackScores bool) DefaultAPISearchGetRequest {
	r.trackScores = &trackScores
	return r
}

// Indicate if the number of documents that match the query should be tracked.
func (r DefaultAPISearchGetRequest) TrackTotalHits(trackTotalHits bool) DefaultAPISearchGetRequest {
	r.trackTotalHits = &trackTotalHits
	return r
}

// Indicate if an error should be returned if there is a partial search failure or timeout.
func (r DefaultAPISearchGetRequest) AllowPartialSearchResults(allowPartialSearchResults bool) DefaultAPISearchGetRequest {
	r.allowPartialSearchResults = &allowPartialSearchResults
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPISearchGetRequest) TypedKeys(typedKeys bool) DefaultAPISearchGetRequest {
	r.typedKeys = &typedKeys
	return r
}

// Whether to return document version as part of a hit.
func (r DefaultAPISearchGetRequest) Version(version bool) DefaultAPISearchGetRequest {
	r.version = &version
	return r
}

// Specify whether to return sequence number and primary term of the last modification of each hit.
func (r DefaultAPISearchGetRequest) SeqNoPrimaryTerm(seqNoPrimaryTerm bool) DefaultAPISearchGetRequest {
	r.seqNoPrimaryTerm = &seqNoPrimaryTerm
	return r
}

// Specify if request cache should be used for this request or not, defaults to index level setting.
func (r DefaultAPISearchGetRequest) RequestCache(requestCache bool) DefaultAPISearchGetRequest {
	r.requestCache = &requestCache
	return r
}

// The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
func (r DefaultAPISearchGetRequest) BatchedReduceSize(batchedReduceSize int32) DefaultAPISearchGetRequest {
	r.batchedReduceSize = &batchedReduceSize
	return r
}

// The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r DefaultAPISearchGetRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) DefaultAPISearchGetRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r DefaultAPISearchGetRequest) PreFilterShardSize(preFilterShardSize int32) DefaultAPISearchGetRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPISearchGetRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPISearchGetRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r DefaultAPISearchGetRequest) Execute() (*SearchGetResponseContent, *http.Response, error) {
	return r.ApiService.SearchGetExecute(r)
}

/*
SearchGet Method for SearchGet

Returns results matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPISearchGetRequest
*/
func (a *DefaultAPIService) SearchGet(ctx context.Context) DefaultAPISearchGetRequest {
	return DefaultAPISearchGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchGetResponseContent
func (a *DefaultAPIService) SearchGetExecute(r DefaultAPISearchGetRequest) (*SearchGetResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchGetResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.docvalueFields != nil {
		t := *r.docvalueFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", t, "multi")
		}
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	} else {
		var defaultValue int32 = 0
		r.from = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	if r.stats != nil {
		t := *r.stats
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stats", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stats", t, "multi")
		}
	}
	if r.suggestField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_field", r.suggestField, "")
	}
	if r.suggestMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_mode", r.suggestMode, "")
	}
	if r.suggestSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_size", r.suggestSize, "")
	}
	if r.suggestText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_text", r.suggestText, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.trackScores != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_scores", r.trackScores, "")
	}
	if r.trackTotalHits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_total_hits", r.trackTotalHits, "")
	}
	if r.allowPartialSearchResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_partial_search_results", r.allowPartialSearchResults, "")
	} else {
		var defaultValue bool = true
		r.allowPartialSearchResults = &defaultValue
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.seqNoPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seq_no_primary_term", r.seqNoPrimaryTerm, "")
	}
	if r.requestCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_cache", r.requestCache, "")
	}
	if r.batchedReduceSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batched_reduce_size", r.batchedReduceSize, "")
	} else {
		var defaultValue int32 = 512
		r.batchedReduceSize = &defaultValue
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPISearchGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	analyzer *string
	analyzeWildcard *bool
	ccsMinimizeRoundtrips *bool
	defaultOperator *DefaultOperator
	df *string
	explain *bool
	storedFields *[]string
	docvalueFields *[]string
	from *int32
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	lenient *bool
	preference *string
	q *string
	routing *[]string
	scroll *string
	searchType *SearchType
	size *int32
	sort *[]string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	terminateAfter *int32
	stats *[]string
	suggestField *string
	suggestMode *SuggestMode
	suggestSize *int32
	suggestText *string
	timeout *string
	trackScores *bool
	trackTotalHits *bool
	allowPartialSearchResults *bool
	typedKeys *bool
	version *bool
	seqNoPrimaryTerm *bool
	requestCache *bool
	batchedReduceSize *int32
	maxConcurrentShardRequests *int32
	preFilterShardSize *int32
	restTotalHitsAsInt *bool
}

// The analyzer to use for the query string.
func (r DefaultAPISearchGetWithIndexRequest) Analyzer(analyzer string) DefaultAPISearchGetWithIndexRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r DefaultAPISearchGetWithIndexRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPISearchGetWithIndexRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPISearchGetWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPISearchGetWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPISearchGetWithIndexRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPISearchGetWithIndexRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r DefaultAPISearchGetWithIndexRequest) Df(df string) DefaultAPISearchGetWithIndexRequest {
	r.df = &df
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r DefaultAPISearchGetWithIndexRequest) Explain(explain bool) DefaultAPISearchGetWithIndexRequest {
	r.explain = &explain
	return r
}

// Comma-separated list of stored fields to return.
func (r DefaultAPISearchGetWithIndexRequest) StoredFields(storedFields []string) DefaultAPISearchGetWithIndexRequest {
	r.storedFields = &storedFields
	return r
}

// Comma-separated list of fields to return as the docvalue representation of a field for each hit.
func (r DefaultAPISearchGetWithIndexRequest) DocvalueFields(docvalueFields []string) DefaultAPISearchGetWithIndexRequest {
	r.docvalueFields = &docvalueFields
	return r
}

// Starting offset.
func (r DefaultAPISearchGetWithIndexRequest) From(from int32) DefaultAPISearchGetWithIndexRequest {
	r.from = &from
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPISearchGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISearchGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r DefaultAPISearchGetWithIndexRequest) IgnoreThrottled(ignoreThrottled bool) DefaultAPISearchGetWithIndexRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPISearchGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPISearchGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPISearchGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPISearchGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPISearchGetWithIndexRequest) Lenient(lenient bool) DefaultAPISearchGetWithIndexRequest {
	r.lenient = &lenient
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPISearchGetWithIndexRequest) Preference(preference string) DefaultAPISearchGetWithIndexRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPISearchGetWithIndexRequest) Q(q string) DefaultAPISearchGetWithIndexRequest {
	r.q = &q
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPISearchGetWithIndexRequest) Routing(routing []string) DefaultAPISearchGetWithIndexRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPISearchGetWithIndexRequest) Scroll(scroll string) DefaultAPISearchGetWithIndexRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r DefaultAPISearchGetWithIndexRequest) SearchType(searchType SearchType) DefaultAPISearchGetWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Number of hits to return.
func (r DefaultAPISearchGetWithIndexRequest) Size(size int32) DefaultAPISearchGetWithIndexRequest {
	r.size = &size
	return r
}

// Comma-separated list of &lt;field&gt;:&lt;direction&gt; pairs.
func (r DefaultAPISearchGetWithIndexRequest) Sort(sort []string) DefaultAPISearchGetWithIndexRequest {
	r.sort = &sort
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPISearchGetWithIndexRequest) Source(source []string) DefaultAPISearchGetWithIndexRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPISearchGetWithIndexRequest) SourceExcludes(sourceExcludes []string) DefaultAPISearchGetWithIndexRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPISearchGetWithIndexRequest) SourceIncludes(sourceIncludes []string) DefaultAPISearchGetWithIndexRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r DefaultAPISearchGetWithIndexRequest) TerminateAfter(terminateAfter int32) DefaultAPISearchGetWithIndexRequest {
	r.terminateAfter = &terminateAfter
	return r
}

// Specific &#39;tag&#39; of the request for logging and statistical purposes.
func (r DefaultAPISearchGetWithIndexRequest) Stats(stats []string) DefaultAPISearchGetWithIndexRequest {
	r.stats = &stats
	return r
}

// Specify which field to use for suggestions.
func (r DefaultAPISearchGetWithIndexRequest) SuggestField(suggestField string) DefaultAPISearchGetWithIndexRequest {
	r.suggestField = &suggestField
	return r
}

// Specify suggest mode.
func (r DefaultAPISearchGetWithIndexRequest) SuggestMode(suggestMode SuggestMode) DefaultAPISearchGetWithIndexRequest {
	r.suggestMode = &suggestMode
	return r
}

// How many suggestions to return in response.
func (r DefaultAPISearchGetWithIndexRequest) SuggestSize(suggestSize int32) DefaultAPISearchGetWithIndexRequest {
	r.suggestSize = &suggestSize
	return r
}

// The source text for which the suggestions should be returned.
func (r DefaultAPISearchGetWithIndexRequest) SuggestText(suggestText string) DefaultAPISearchGetWithIndexRequest {
	r.suggestText = &suggestText
	return r
}

// Operation timeout.
func (r DefaultAPISearchGetWithIndexRequest) Timeout(timeout string) DefaultAPISearchGetWithIndexRequest {
	r.timeout = &timeout
	return r
}

// Whether to calculate and return scores even if they are not used for sorting.
func (r DefaultAPISearchGetWithIndexRequest) TrackScores(trackScores bool) DefaultAPISearchGetWithIndexRequest {
	r.trackScores = &trackScores
	return r
}

// Indicate if the number of documents that match the query should be tracked.
func (r DefaultAPISearchGetWithIndexRequest) TrackTotalHits(trackTotalHits bool) DefaultAPISearchGetWithIndexRequest {
	r.trackTotalHits = &trackTotalHits
	return r
}

// Indicate if an error should be returned if there is a partial search failure or timeout.
func (r DefaultAPISearchGetWithIndexRequest) AllowPartialSearchResults(allowPartialSearchResults bool) DefaultAPISearchGetWithIndexRequest {
	r.allowPartialSearchResults = &allowPartialSearchResults
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPISearchGetWithIndexRequest) TypedKeys(typedKeys bool) DefaultAPISearchGetWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Whether to return document version as part of a hit.
func (r DefaultAPISearchGetWithIndexRequest) Version(version bool) DefaultAPISearchGetWithIndexRequest {
	r.version = &version
	return r
}

// Specify whether to return sequence number and primary term of the last modification of each hit.
func (r DefaultAPISearchGetWithIndexRequest) SeqNoPrimaryTerm(seqNoPrimaryTerm bool) DefaultAPISearchGetWithIndexRequest {
	r.seqNoPrimaryTerm = &seqNoPrimaryTerm
	return r
}

// Specify if request cache should be used for this request or not, defaults to index level setting.
func (r DefaultAPISearchGetWithIndexRequest) RequestCache(requestCache bool) DefaultAPISearchGetWithIndexRequest {
	r.requestCache = &requestCache
	return r
}

// The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
func (r DefaultAPISearchGetWithIndexRequest) BatchedReduceSize(batchedReduceSize int32) DefaultAPISearchGetWithIndexRequest {
	r.batchedReduceSize = &batchedReduceSize
	return r
}

// The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r DefaultAPISearchGetWithIndexRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) DefaultAPISearchGetWithIndexRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r DefaultAPISearchGetWithIndexRequest) PreFilterShardSize(preFilterShardSize int32) DefaultAPISearchGetWithIndexRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPISearchGetWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPISearchGetWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r DefaultAPISearchGetWithIndexRequest) Execute() (*SearchGetWithIndexResponseContent, *http.Response, error) {
	return r.ApiService.SearchGetWithIndexExecute(r)
}

/*
SearchGetWithIndex Method for SearchGetWithIndex

Returns results matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPISearchGetWithIndexRequest
*/
func (a *DefaultAPIService) SearchGetWithIndex(ctx context.Context, index string) DefaultAPISearchGetWithIndexRequest {
	return DefaultAPISearchGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
//  @return SearchGetWithIndexResponseContent
func (a *DefaultAPIService) SearchGetWithIndexExecute(r DefaultAPISearchGetWithIndexRequest) (*SearchGetWithIndexResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchGetWithIndexResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchGetWithIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_search"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.docvalueFields != nil {
		t := *r.docvalueFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", t, "multi")
		}
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	} else {
		var defaultValue int32 = 0
		r.from = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	if r.stats != nil {
		t := *r.stats
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stats", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stats", t, "multi")
		}
	}
	if r.suggestField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_field", r.suggestField, "")
	}
	if r.suggestMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_mode", r.suggestMode, "")
	}
	if r.suggestSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_size", r.suggestSize, "")
	}
	if r.suggestText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_text", r.suggestText, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.trackScores != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_scores", r.trackScores, "")
	}
	if r.trackTotalHits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_total_hits", r.trackTotalHits, "")
	}
	if r.allowPartialSearchResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_partial_search_results", r.allowPartialSearchResults, "")
	} else {
		var defaultValue bool = true
		r.allowPartialSearchResults = &defaultValue
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.seqNoPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seq_no_primary_term", r.seqNoPrimaryTerm, "")
	}
	if r.requestCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_cache", r.requestCache, "")
	}
	if r.batchedReduceSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batched_reduce_size", r.batchedReduceSize, "")
	} else {
		var defaultValue int32 = 512
		r.batchedReduceSize = &defaultValue
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPISearchPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	analyzer *string
	analyzeWildcard *bool
	ccsMinimizeRoundtrips *bool
	defaultOperator *DefaultOperator
	df *string
	explain *bool
	storedFields *[]string
	docvalueFields *[]string
	from *int32
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	lenient *bool
	preference *string
	q *string
	routing *[]string
	scroll *string
	searchType *SearchType
	size *int32
	sort *[]string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	terminateAfter *int32
	stats *[]string
	suggestField *string
	suggestMode *SuggestMode
	suggestSize *int32
	suggestText *string
	timeout *string
	trackScores *bool
	trackTotalHits *bool
	allowPartialSearchResults *bool
	typedKeys *bool
	version *bool
	seqNoPrimaryTerm *bool
	requestCache *bool
	batchedReduceSize *int32
	maxConcurrentShardRequests *int32
	preFilterShardSize *int32
	restTotalHitsAsInt *bool
	searchBodyParams *SearchBodyParams
}

// The analyzer to use for the query string.
func (r DefaultAPISearchPostRequest) Analyzer(analyzer string) DefaultAPISearchPostRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r DefaultAPISearchPostRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPISearchPostRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPISearchPostRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPISearchPostRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPISearchPostRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPISearchPostRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r DefaultAPISearchPostRequest) Df(df string) DefaultAPISearchPostRequest {
	r.df = &df
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r DefaultAPISearchPostRequest) Explain(explain bool) DefaultAPISearchPostRequest {
	r.explain = &explain
	return r
}

// Comma-separated list of stored fields to return.
func (r DefaultAPISearchPostRequest) StoredFields(storedFields []string) DefaultAPISearchPostRequest {
	r.storedFields = &storedFields
	return r
}

// Comma-separated list of fields to return as the docvalue representation of a field for each hit.
func (r DefaultAPISearchPostRequest) DocvalueFields(docvalueFields []string) DefaultAPISearchPostRequest {
	r.docvalueFields = &docvalueFields
	return r
}

// Starting offset.
func (r DefaultAPISearchPostRequest) From(from int32) DefaultAPISearchPostRequest {
	r.from = &from
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPISearchPostRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISearchPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r DefaultAPISearchPostRequest) IgnoreThrottled(ignoreThrottled bool) DefaultAPISearchPostRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPISearchPostRequest) AllowNoIndices(allowNoIndices bool) DefaultAPISearchPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPISearchPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPISearchPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPISearchPostRequest) Lenient(lenient bool) DefaultAPISearchPostRequest {
	r.lenient = &lenient
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPISearchPostRequest) Preference(preference string) DefaultAPISearchPostRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPISearchPostRequest) Q(q string) DefaultAPISearchPostRequest {
	r.q = &q
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPISearchPostRequest) Routing(routing []string) DefaultAPISearchPostRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPISearchPostRequest) Scroll(scroll string) DefaultAPISearchPostRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r DefaultAPISearchPostRequest) SearchType(searchType SearchType) DefaultAPISearchPostRequest {
	r.searchType = &searchType
	return r
}

// Number of hits to return.
func (r DefaultAPISearchPostRequest) Size(size int32) DefaultAPISearchPostRequest {
	r.size = &size
	return r
}

// Comma-separated list of &lt;field&gt;:&lt;direction&gt; pairs.
func (r DefaultAPISearchPostRequest) Sort(sort []string) DefaultAPISearchPostRequest {
	r.sort = &sort
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPISearchPostRequest) Source(source []string) DefaultAPISearchPostRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPISearchPostRequest) SourceExcludes(sourceExcludes []string) DefaultAPISearchPostRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPISearchPostRequest) SourceIncludes(sourceIncludes []string) DefaultAPISearchPostRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r DefaultAPISearchPostRequest) TerminateAfter(terminateAfter int32) DefaultAPISearchPostRequest {
	r.terminateAfter = &terminateAfter
	return r
}

// Specific &#39;tag&#39; of the request for logging and statistical purposes.
func (r DefaultAPISearchPostRequest) Stats(stats []string) DefaultAPISearchPostRequest {
	r.stats = &stats
	return r
}

// Specify which field to use for suggestions.
func (r DefaultAPISearchPostRequest) SuggestField(suggestField string) DefaultAPISearchPostRequest {
	r.suggestField = &suggestField
	return r
}

// Specify suggest mode.
func (r DefaultAPISearchPostRequest) SuggestMode(suggestMode SuggestMode) DefaultAPISearchPostRequest {
	r.suggestMode = &suggestMode
	return r
}

// How many suggestions to return in response.
func (r DefaultAPISearchPostRequest) SuggestSize(suggestSize int32) DefaultAPISearchPostRequest {
	r.suggestSize = &suggestSize
	return r
}

// The source text for which the suggestions should be returned.
func (r DefaultAPISearchPostRequest) SuggestText(suggestText string) DefaultAPISearchPostRequest {
	r.suggestText = &suggestText
	return r
}

// Operation timeout.
func (r DefaultAPISearchPostRequest) Timeout(timeout string) DefaultAPISearchPostRequest {
	r.timeout = &timeout
	return r
}

// Whether to calculate and return scores even if they are not used for sorting.
func (r DefaultAPISearchPostRequest) TrackScores(trackScores bool) DefaultAPISearchPostRequest {
	r.trackScores = &trackScores
	return r
}

// Indicate if the number of documents that match the query should be tracked.
func (r DefaultAPISearchPostRequest) TrackTotalHits(trackTotalHits bool) DefaultAPISearchPostRequest {
	r.trackTotalHits = &trackTotalHits
	return r
}

// Indicate if an error should be returned if there is a partial search failure or timeout.
func (r DefaultAPISearchPostRequest) AllowPartialSearchResults(allowPartialSearchResults bool) DefaultAPISearchPostRequest {
	r.allowPartialSearchResults = &allowPartialSearchResults
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPISearchPostRequest) TypedKeys(typedKeys bool) DefaultAPISearchPostRequest {
	r.typedKeys = &typedKeys
	return r
}

// Whether to return document version as part of a hit.
func (r DefaultAPISearchPostRequest) Version(version bool) DefaultAPISearchPostRequest {
	r.version = &version
	return r
}

// Specify whether to return sequence number and primary term of the last modification of each hit.
func (r DefaultAPISearchPostRequest) SeqNoPrimaryTerm(seqNoPrimaryTerm bool) DefaultAPISearchPostRequest {
	r.seqNoPrimaryTerm = &seqNoPrimaryTerm
	return r
}

// Specify if request cache should be used for this request or not, defaults to index level setting.
func (r DefaultAPISearchPostRequest) RequestCache(requestCache bool) DefaultAPISearchPostRequest {
	r.requestCache = &requestCache
	return r
}

// The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
func (r DefaultAPISearchPostRequest) BatchedReduceSize(batchedReduceSize int32) DefaultAPISearchPostRequest {
	r.batchedReduceSize = &batchedReduceSize
	return r
}

// The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r DefaultAPISearchPostRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) DefaultAPISearchPostRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r DefaultAPISearchPostRequest) PreFilterShardSize(preFilterShardSize int32) DefaultAPISearchPostRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPISearchPostRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPISearchPostRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r DefaultAPISearchPostRequest) SearchBodyParams(searchBodyParams SearchBodyParams) DefaultAPISearchPostRequest {
	r.searchBodyParams = &searchBodyParams
	return r
}

func (r DefaultAPISearchPostRequest) Execute() (*SearchPostResponseContent, *http.Response, error) {
	return r.ApiService.SearchPostExecute(r)
}

/*
SearchPost Method for SearchPost

Returns results matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPISearchPostRequest
*/
func (a *DefaultAPIService) SearchPost(ctx context.Context) DefaultAPISearchPostRequest {
	return DefaultAPISearchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchPostResponseContent
func (a *DefaultAPIService) SearchPostExecute(r DefaultAPISearchPostRequest) (*SearchPostResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchPostResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.docvalueFields != nil {
		t := *r.docvalueFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", t, "multi")
		}
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	} else {
		var defaultValue int32 = 0
		r.from = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	if r.stats != nil {
		t := *r.stats
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stats", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stats", t, "multi")
		}
	}
	if r.suggestField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_field", r.suggestField, "")
	}
	if r.suggestMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_mode", r.suggestMode, "")
	}
	if r.suggestSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_size", r.suggestSize, "")
	}
	if r.suggestText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_text", r.suggestText, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.trackScores != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_scores", r.trackScores, "")
	}
	if r.trackTotalHits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_total_hits", r.trackTotalHits, "")
	}
	if r.allowPartialSearchResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_partial_search_results", r.allowPartialSearchResults, "")
	} else {
		var defaultValue bool = true
		r.allowPartialSearchResults = &defaultValue
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.seqNoPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seq_no_primary_term", r.seqNoPrimaryTerm, "")
	}
	if r.requestCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_cache", r.requestCache, "")
	}
	if r.batchedReduceSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batched_reduce_size", r.batchedReduceSize, "")
	} else {
		var defaultValue int32 = 512
		r.batchedReduceSize = &defaultValue
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.searchBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPISearchPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	analyzer *string
	analyzeWildcard *bool
	ccsMinimizeRoundtrips *bool
	defaultOperator *DefaultOperator
	df *string
	explain *bool
	storedFields *[]string
	docvalueFields *[]string
	from *int32
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	lenient *bool
	preference *string
	q *string
	routing *[]string
	scroll *string
	searchType *SearchType
	size *int32
	sort *[]string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	terminateAfter *int32
	stats *[]string
	suggestField *string
	suggestMode *SuggestMode
	suggestSize *int32
	suggestText *string
	timeout *string
	trackScores *bool
	trackTotalHits *bool
	allowPartialSearchResults *bool
	typedKeys *bool
	version *bool
	seqNoPrimaryTerm *bool
	requestCache *bool
	batchedReduceSize *int32
	maxConcurrentShardRequests *int32
	preFilterShardSize *int32
	restTotalHitsAsInt *bool
	searchBodyParams *SearchBodyParams
}

// The analyzer to use for the query string.
func (r DefaultAPISearchPostWithIndexRequest) Analyzer(analyzer string) DefaultAPISearchPostWithIndexRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r DefaultAPISearchPostWithIndexRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPISearchPostWithIndexRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPISearchPostWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPISearchPostWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPISearchPostWithIndexRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPISearchPostWithIndexRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r DefaultAPISearchPostWithIndexRequest) Df(df string) DefaultAPISearchPostWithIndexRequest {
	r.df = &df
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r DefaultAPISearchPostWithIndexRequest) Explain(explain bool) DefaultAPISearchPostWithIndexRequest {
	r.explain = &explain
	return r
}

// Comma-separated list of stored fields to return.
func (r DefaultAPISearchPostWithIndexRequest) StoredFields(storedFields []string) DefaultAPISearchPostWithIndexRequest {
	r.storedFields = &storedFields
	return r
}

// Comma-separated list of fields to return as the docvalue representation of a field for each hit.
func (r DefaultAPISearchPostWithIndexRequest) DocvalueFields(docvalueFields []string) DefaultAPISearchPostWithIndexRequest {
	r.docvalueFields = &docvalueFields
	return r
}

// Starting offset.
func (r DefaultAPISearchPostWithIndexRequest) From(from int32) DefaultAPISearchPostWithIndexRequest {
	r.from = &from
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPISearchPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISearchPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r DefaultAPISearchPostWithIndexRequest) IgnoreThrottled(ignoreThrottled bool) DefaultAPISearchPostWithIndexRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPISearchPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPISearchPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPISearchPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPISearchPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPISearchPostWithIndexRequest) Lenient(lenient bool) DefaultAPISearchPostWithIndexRequest {
	r.lenient = &lenient
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPISearchPostWithIndexRequest) Preference(preference string) DefaultAPISearchPostWithIndexRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPISearchPostWithIndexRequest) Q(q string) DefaultAPISearchPostWithIndexRequest {
	r.q = &q
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPISearchPostWithIndexRequest) Routing(routing []string) DefaultAPISearchPostWithIndexRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPISearchPostWithIndexRequest) Scroll(scroll string) DefaultAPISearchPostWithIndexRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r DefaultAPISearchPostWithIndexRequest) SearchType(searchType SearchType) DefaultAPISearchPostWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Number of hits to return.
func (r DefaultAPISearchPostWithIndexRequest) Size(size int32) DefaultAPISearchPostWithIndexRequest {
	r.size = &size
	return r
}

// Comma-separated list of &lt;field&gt;:&lt;direction&gt; pairs.
func (r DefaultAPISearchPostWithIndexRequest) Sort(sort []string) DefaultAPISearchPostWithIndexRequest {
	r.sort = &sort
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPISearchPostWithIndexRequest) Source(source []string) DefaultAPISearchPostWithIndexRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPISearchPostWithIndexRequest) SourceExcludes(sourceExcludes []string) DefaultAPISearchPostWithIndexRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPISearchPostWithIndexRequest) SourceIncludes(sourceIncludes []string) DefaultAPISearchPostWithIndexRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r DefaultAPISearchPostWithIndexRequest) TerminateAfter(terminateAfter int32) DefaultAPISearchPostWithIndexRequest {
	r.terminateAfter = &terminateAfter
	return r
}

// Specific &#39;tag&#39; of the request for logging and statistical purposes.
func (r DefaultAPISearchPostWithIndexRequest) Stats(stats []string) DefaultAPISearchPostWithIndexRequest {
	r.stats = &stats
	return r
}

// Specify which field to use for suggestions.
func (r DefaultAPISearchPostWithIndexRequest) SuggestField(suggestField string) DefaultAPISearchPostWithIndexRequest {
	r.suggestField = &suggestField
	return r
}

// Specify suggest mode.
func (r DefaultAPISearchPostWithIndexRequest) SuggestMode(suggestMode SuggestMode) DefaultAPISearchPostWithIndexRequest {
	r.suggestMode = &suggestMode
	return r
}

// How many suggestions to return in response.
func (r DefaultAPISearchPostWithIndexRequest) SuggestSize(suggestSize int32) DefaultAPISearchPostWithIndexRequest {
	r.suggestSize = &suggestSize
	return r
}

// The source text for which the suggestions should be returned.
func (r DefaultAPISearchPostWithIndexRequest) SuggestText(suggestText string) DefaultAPISearchPostWithIndexRequest {
	r.suggestText = &suggestText
	return r
}

// Operation timeout.
func (r DefaultAPISearchPostWithIndexRequest) Timeout(timeout string) DefaultAPISearchPostWithIndexRequest {
	r.timeout = &timeout
	return r
}

// Whether to calculate and return scores even if they are not used for sorting.
func (r DefaultAPISearchPostWithIndexRequest) TrackScores(trackScores bool) DefaultAPISearchPostWithIndexRequest {
	r.trackScores = &trackScores
	return r
}

// Indicate if the number of documents that match the query should be tracked.
func (r DefaultAPISearchPostWithIndexRequest) TrackTotalHits(trackTotalHits bool) DefaultAPISearchPostWithIndexRequest {
	r.trackTotalHits = &trackTotalHits
	return r
}

// Indicate if an error should be returned if there is a partial search failure or timeout.
func (r DefaultAPISearchPostWithIndexRequest) AllowPartialSearchResults(allowPartialSearchResults bool) DefaultAPISearchPostWithIndexRequest {
	r.allowPartialSearchResults = &allowPartialSearchResults
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPISearchPostWithIndexRequest) TypedKeys(typedKeys bool) DefaultAPISearchPostWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Whether to return document version as part of a hit.
func (r DefaultAPISearchPostWithIndexRequest) Version(version bool) DefaultAPISearchPostWithIndexRequest {
	r.version = &version
	return r
}

// Specify whether to return sequence number and primary term of the last modification of each hit.
func (r DefaultAPISearchPostWithIndexRequest) SeqNoPrimaryTerm(seqNoPrimaryTerm bool) DefaultAPISearchPostWithIndexRequest {
	r.seqNoPrimaryTerm = &seqNoPrimaryTerm
	return r
}

// Specify if request cache should be used for this request or not, defaults to index level setting.
func (r DefaultAPISearchPostWithIndexRequest) RequestCache(requestCache bool) DefaultAPISearchPostWithIndexRequest {
	r.requestCache = &requestCache
	return r
}

// The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
func (r DefaultAPISearchPostWithIndexRequest) BatchedReduceSize(batchedReduceSize int32) DefaultAPISearchPostWithIndexRequest {
	r.batchedReduceSize = &batchedReduceSize
	return r
}

// The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
func (r DefaultAPISearchPostWithIndexRequest) MaxConcurrentShardRequests(maxConcurrentShardRequests int32) DefaultAPISearchPostWithIndexRequest {
	r.maxConcurrentShardRequests = &maxConcurrentShardRequests
	return r
}

// Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
func (r DefaultAPISearchPostWithIndexRequest) PreFilterShardSize(preFilterShardSize int32) DefaultAPISearchPostWithIndexRequest {
	r.preFilterShardSize = &preFilterShardSize
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPISearchPostWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPISearchPostWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

func (r DefaultAPISearchPostWithIndexRequest) SearchBodyParams(searchBodyParams SearchBodyParams) DefaultAPISearchPostWithIndexRequest {
	r.searchBodyParams = &searchBodyParams
	return r
}

func (r DefaultAPISearchPostWithIndexRequest) Execute() (*SearchPostWithIndexResponseContent, *http.Response, error) {
	return r.ApiService.SearchPostWithIndexExecute(r)
}

/*
SearchPostWithIndex Method for SearchPostWithIndex

Returns results matching a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPISearchPostWithIndexRequest
*/
func (a *DefaultAPIService) SearchPostWithIndex(ctx context.Context, index string) DefaultAPISearchPostWithIndexRequest {
	return DefaultAPISearchPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
//  @return SearchPostWithIndexResponseContent
func (a *DefaultAPIService) SearchPostWithIndexExecute(r DefaultAPISearchPostWithIndexRequest) (*SearchPostWithIndexResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchPostWithIndexResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchPostWithIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_search"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.storedFields != nil {
		t := *r.storedFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stored_fields", t, "multi")
		}
	}
	if r.docvalueFields != nil {
		t := *r.docvalueFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "docvalue_fields", t, "multi")
		}
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	} else {
		var defaultValue int32 = 0
		r.from = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	if r.stats != nil {
		t := *r.stats
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stats", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stats", t, "multi")
		}
	}
	if r.suggestField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_field", r.suggestField, "")
	}
	if r.suggestMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_mode", r.suggestMode, "")
	}
	if r.suggestSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_size", r.suggestSize, "")
	}
	if r.suggestText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suggest_text", r.suggestText, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.trackScores != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_scores", r.trackScores, "")
	}
	if r.trackTotalHits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track_total_hits", r.trackTotalHits, "")
	}
	if r.allowPartialSearchResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_partial_search_results", r.allowPartialSearchResults, "")
	} else {
		var defaultValue bool = true
		r.allowPartialSearchResults = &defaultValue
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.seqNoPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seq_no_primary_term", r.seqNoPrimaryTerm, "")
	}
	if r.requestCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_cache", r.requestCache, "")
	}
	if r.batchedReduceSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batched_reduce_size", r.batchedReduceSize, "")
	} else {
		var defaultValue int32 = 512
		r.batchedReduceSize = &defaultValue
	}
	if r.maxConcurrentShardRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_concurrent_shard_requests", r.maxConcurrentShardRequests, "")
	} else {
		var defaultValue int32 = 5
		r.maxConcurrentShardRequests = &defaultValue
	}
	if r.preFilterShardSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_filter_shard_size", r.preFilterShardSize, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.searchBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPISearchShardsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	preference *string
	routing *string
	local *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPISearchShardsGetRequest) Preference(preference string) DefaultAPISearchShardsGetRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r DefaultAPISearchShardsGetRequest) Routing(routing string) DefaultAPISearchShardsGetRequest {
	r.routing = &routing
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPISearchShardsGetRequest) Local(local bool) DefaultAPISearchShardsGetRequest {
	r.local = &local
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPISearchShardsGetRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISearchShardsGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPISearchShardsGetRequest) AllowNoIndices(allowNoIndices bool) DefaultAPISearchShardsGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPISearchShardsGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPISearchShardsGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPISearchShardsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchShardsGetExecute(r)
}

/*
SearchShardsGet Method for SearchShardsGet

Returns information about the indices and shards that a search request would be executed against.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPISearchShardsGetRequest
*/
func (a *DefaultAPIService) SearchShardsGet(ctx context.Context) DefaultAPISearchShardsGetRequest {
	return DefaultAPISearchShardsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchShardsGetExecute(r DefaultAPISearchShardsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchShardsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search_shards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISearchShardsGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	preference *string
	routing *string
	local *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPISearchShardsGetWithIndexRequest) Preference(preference string) DefaultAPISearchShardsGetWithIndexRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r DefaultAPISearchShardsGetWithIndexRequest) Routing(routing string) DefaultAPISearchShardsGetWithIndexRequest {
	r.routing = &routing
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPISearchShardsGetWithIndexRequest) Local(local bool) DefaultAPISearchShardsGetWithIndexRequest {
	r.local = &local
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPISearchShardsGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISearchShardsGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPISearchShardsGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPISearchShardsGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPISearchShardsGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPISearchShardsGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPISearchShardsGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchShardsGetWithIndexExecute(r)
}

/*
SearchShardsGetWithIndex Method for SearchShardsGetWithIndex

Returns information about the indices and shards that a search request would be executed against.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPISearchShardsGetWithIndexRequest
*/
func (a *DefaultAPIService) SearchShardsGetWithIndex(ctx context.Context, index string) DefaultAPISearchShardsGetWithIndexRequest {
	return DefaultAPISearchShardsGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchShardsGetWithIndexExecute(r DefaultAPISearchShardsGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchShardsGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_search_shards"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISearchShardsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	preference *string
	routing *string
	local *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPISearchShardsPostRequest) Preference(preference string) DefaultAPISearchShardsPostRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r DefaultAPISearchShardsPostRequest) Routing(routing string) DefaultAPISearchShardsPostRequest {
	r.routing = &routing
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPISearchShardsPostRequest) Local(local bool) DefaultAPISearchShardsPostRequest {
	r.local = &local
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPISearchShardsPostRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISearchShardsPostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPISearchShardsPostRequest) AllowNoIndices(allowNoIndices bool) DefaultAPISearchShardsPostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPISearchShardsPostRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPISearchShardsPostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPISearchShardsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchShardsPostExecute(r)
}

/*
SearchShardsPost Method for SearchShardsPost

Returns information about the indices and shards that a search request would be executed against.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPISearchShardsPostRequest
*/
func (a *DefaultAPIService) SearchShardsPost(ctx context.Context) DefaultAPISearchShardsPostRequest {
	return DefaultAPISearchShardsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchShardsPostExecute(r DefaultAPISearchShardsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchShardsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search_shards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISearchShardsPostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	preference *string
	routing *string
	local *bool
	ignoreUnavailable *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPISearchShardsPostWithIndexRequest) Preference(preference string) DefaultAPISearchShardsPostWithIndexRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r DefaultAPISearchShardsPostWithIndexRequest) Routing(routing string) DefaultAPISearchShardsPostWithIndexRequest {
	r.routing = &routing
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPISearchShardsPostWithIndexRequest) Local(local bool) DefaultAPISearchShardsPostWithIndexRequest {
	r.local = &local
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPISearchShardsPostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISearchShardsPostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPISearchShardsPostWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPISearchShardsPostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPISearchShardsPostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPISearchShardsPostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

func (r DefaultAPISearchShardsPostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchShardsPostWithIndexExecute(r)
}

/*
SearchShardsPostWithIndex Method for SearchShardsPostWithIndex

Returns information about the indices and shards that a search request would be executed against.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPISearchShardsPostWithIndexRequest
*/
func (a *DefaultAPIService) SearchShardsPostWithIndex(ctx context.Context, index string) DefaultAPISearchShardsPostWithIndexRequest {
	return DefaultAPISearchShardsPostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchShardsPostWithIndexExecute(r DefaultAPISearchShardsPostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchShardsPostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_search_shards"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISearchTemplateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	preference *string
	routing *[]string
	scroll *string
	searchType *SearchTypeMulti
	explain *bool
	profile *bool
	typedKeys *bool
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPISearchTemplateGetRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISearchTemplateGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r DefaultAPISearchTemplateGetRequest) IgnoreThrottled(ignoreThrottled bool) DefaultAPISearchTemplateGetRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPISearchTemplateGetRequest) AllowNoIndices(allowNoIndices bool) DefaultAPISearchTemplateGetRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPISearchTemplateGetRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPISearchTemplateGetRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPISearchTemplateGetRequest) Preference(preference string) DefaultAPISearchTemplateGetRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPISearchTemplateGetRequest) Routing(routing []string) DefaultAPISearchTemplateGetRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPISearchTemplateGetRequest) Scroll(scroll string) DefaultAPISearchTemplateGetRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r DefaultAPISearchTemplateGetRequest) SearchType(searchType SearchTypeMulti) DefaultAPISearchTemplateGetRequest {
	r.searchType = &searchType
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r DefaultAPISearchTemplateGetRequest) Explain(explain bool) DefaultAPISearchTemplateGetRequest {
	r.explain = &explain
	return r
}

// Specify whether to profile the query execution.
func (r DefaultAPISearchTemplateGetRequest) Profile(profile bool) DefaultAPISearchTemplateGetRequest {
	r.profile = &profile
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPISearchTemplateGetRequest) TypedKeys(typedKeys bool) DefaultAPISearchTemplateGetRequest {
	r.typedKeys = &typedKeys
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPISearchTemplateGetRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPISearchTemplateGetRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPISearchTemplateGetRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPISearchTemplateGetRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r DefaultAPISearchTemplateGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchTemplateGetExecute(r)
}

/*
SearchTemplateGet Method for SearchTemplateGet

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPISearchTemplateGetRequest
*/
func (a *DefaultAPIService) SearchTemplateGet(ctx context.Context) DefaultAPISearchTemplateGetRequest {
	return DefaultAPISearchTemplateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchTemplateGetExecute(r DefaultAPISearchTemplateGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchTemplateGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISearchTemplateGetWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	preference *string
	routing *[]string
	scroll *string
	searchType *SearchTypeMulti
	explain *bool
	profile *bool
	typedKeys *bool
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPISearchTemplateGetWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISearchTemplateGetWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r DefaultAPISearchTemplateGetWithIndexRequest) IgnoreThrottled(ignoreThrottled bool) DefaultAPISearchTemplateGetWithIndexRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPISearchTemplateGetWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPISearchTemplateGetWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPISearchTemplateGetWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPISearchTemplateGetWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPISearchTemplateGetWithIndexRequest) Preference(preference string) DefaultAPISearchTemplateGetWithIndexRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPISearchTemplateGetWithIndexRequest) Routing(routing []string) DefaultAPISearchTemplateGetWithIndexRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPISearchTemplateGetWithIndexRequest) Scroll(scroll string) DefaultAPISearchTemplateGetWithIndexRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r DefaultAPISearchTemplateGetWithIndexRequest) SearchType(searchType SearchTypeMulti) DefaultAPISearchTemplateGetWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r DefaultAPISearchTemplateGetWithIndexRequest) Explain(explain bool) DefaultAPISearchTemplateGetWithIndexRequest {
	r.explain = &explain
	return r
}

// Specify whether to profile the query execution.
func (r DefaultAPISearchTemplateGetWithIndexRequest) Profile(profile bool) DefaultAPISearchTemplateGetWithIndexRequest {
	r.profile = &profile
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPISearchTemplateGetWithIndexRequest) TypedKeys(typedKeys bool) DefaultAPISearchTemplateGetWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPISearchTemplateGetWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPISearchTemplateGetWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPISearchTemplateGetWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPISearchTemplateGetWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r DefaultAPISearchTemplateGetWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchTemplateGetWithIndexExecute(r)
}

/*
SearchTemplateGetWithIndex Method for SearchTemplateGetWithIndex

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPISearchTemplateGetWithIndexRequest
*/
func (a *DefaultAPIService) SearchTemplateGetWithIndex(ctx context.Context, index string) DefaultAPISearchTemplateGetWithIndexRequest {
	return DefaultAPISearchTemplateGetWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchTemplateGetWithIndexExecute(r DefaultAPISearchTemplateGetWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchTemplateGetWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_search/template"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISearchTemplatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	body *map[string]interface{}
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	preference *string
	routing *[]string
	scroll *string
	searchType *SearchTypeMulti
	explain *bool
	profile *bool
	typedKeys *bool
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

func (r DefaultAPISearchTemplatePostRequest) Body(body map[string]interface{}) DefaultAPISearchTemplatePostRequest {
	r.body = &body
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPISearchTemplatePostRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISearchTemplatePostRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r DefaultAPISearchTemplatePostRequest) IgnoreThrottled(ignoreThrottled bool) DefaultAPISearchTemplatePostRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPISearchTemplatePostRequest) AllowNoIndices(allowNoIndices bool) DefaultAPISearchTemplatePostRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPISearchTemplatePostRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPISearchTemplatePostRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPISearchTemplatePostRequest) Preference(preference string) DefaultAPISearchTemplatePostRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPISearchTemplatePostRequest) Routing(routing []string) DefaultAPISearchTemplatePostRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPISearchTemplatePostRequest) Scroll(scroll string) DefaultAPISearchTemplatePostRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r DefaultAPISearchTemplatePostRequest) SearchType(searchType SearchTypeMulti) DefaultAPISearchTemplatePostRequest {
	r.searchType = &searchType
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r DefaultAPISearchTemplatePostRequest) Explain(explain bool) DefaultAPISearchTemplatePostRequest {
	r.explain = &explain
	return r
}

// Specify whether to profile the query execution.
func (r DefaultAPISearchTemplatePostRequest) Profile(profile bool) DefaultAPISearchTemplatePostRequest {
	r.profile = &profile
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPISearchTemplatePostRequest) TypedKeys(typedKeys bool) DefaultAPISearchTemplatePostRequest {
	r.typedKeys = &typedKeys
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPISearchTemplatePostRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPISearchTemplatePostRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPISearchTemplatePostRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPISearchTemplatePostRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r DefaultAPISearchTemplatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchTemplatePostExecute(r)
}

/*
SearchTemplatePost Method for SearchTemplatePost

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPISearchTemplatePostRequest
*/
func (a *DefaultAPIService) SearchTemplatePost(ctx context.Context) DefaultAPISearchTemplatePostRequest {
	return DefaultAPISearchTemplatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchTemplatePostExecute(r DefaultAPISearchTemplatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchTemplatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_search/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISearchTemplatePostWithIndexRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	body *map[string]interface{}
	ignoreUnavailable *bool
	ignoreThrottled *bool
	allowNoIndices *bool
	expandWildcards *ExpandWildcards
	preference *string
	routing *[]string
	scroll *string
	searchType *SearchTypeMulti
	explain *bool
	profile *bool
	typedKeys *bool
	restTotalHitsAsInt *bool
	ccsMinimizeRoundtrips *bool
}

func (r DefaultAPISearchTemplatePostWithIndexRequest) Body(body map[string]interface{}) DefaultAPISearchTemplatePostWithIndexRequest {
	r.body = &body
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPISearchTemplatePostWithIndexRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISearchTemplatePostWithIndexRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether specified concrete, expanded or aliased indices should be ignored when throttled.
func (r DefaultAPISearchTemplatePostWithIndexRequest) IgnoreThrottled(ignoreThrottled bool) DefaultAPISearchTemplatePostWithIndexRequest {
	r.ignoreThrottled = &ignoreThrottled
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPISearchTemplatePostWithIndexRequest) AllowNoIndices(allowNoIndices bool) DefaultAPISearchTemplatePostWithIndexRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPISearchTemplatePostWithIndexRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPISearchTemplatePostWithIndexRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPISearchTemplatePostWithIndexRequest) Preference(preference string) DefaultAPISearchTemplatePostWithIndexRequest {
	r.preference = &preference
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPISearchTemplatePostWithIndexRequest) Routing(routing []string) DefaultAPISearchTemplatePostWithIndexRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPISearchTemplatePostWithIndexRequest) Scroll(scroll string) DefaultAPISearchTemplatePostWithIndexRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r DefaultAPISearchTemplatePostWithIndexRequest) SearchType(searchType SearchTypeMulti) DefaultAPISearchTemplatePostWithIndexRequest {
	r.searchType = &searchType
	return r
}

// Specify whether to return detailed information about score computation as part of a hit.
func (r DefaultAPISearchTemplatePostWithIndexRequest) Explain(explain bool) DefaultAPISearchTemplatePostWithIndexRequest {
	r.explain = &explain
	return r
}

// Specify whether to profile the query execution.
func (r DefaultAPISearchTemplatePostWithIndexRequest) Profile(profile bool) DefaultAPISearchTemplatePostWithIndexRequest {
	r.profile = &profile
	return r
}

// Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
func (r DefaultAPISearchTemplatePostWithIndexRequest) TypedKeys(typedKeys bool) DefaultAPISearchTemplatePostWithIndexRequest {
	r.typedKeys = &typedKeys
	return r
}

// Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
func (r DefaultAPISearchTemplatePostWithIndexRequest) RestTotalHitsAsInt(restTotalHitsAsInt bool) DefaultAPISearchTemplatePostWithIndexRequest {
	r.restTotalHitsAsInt = &restTotalHitsAsInt
	return r
}

// Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
func (r DefaultAPISearchTemplatePostWithIndexRequest) CcsMinimizeRoundtrips(ccsMinimizeRoundtrips bool) DefaultAPISearchTemplatePostWithIndexRequest {
	r.ccsMinimizeRoundtrips = &ccsMinimizeRoundtrips
	return r
}

func (r DefaultAPISearchTemplatePostWithIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchTemplatePostWithIndexExecute(r)
}

/*
SearchTemplatePostWithIndex Method for SearchTemplatePostWithIndex

Allows to use the Mustache language to pre-render a search definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPISearchTemplatePostWithIndexRequest
*/
func (a *DefaultAPIService) SearchTemplatePostWithIndex(ctx context.Context, index string) DefaultAPISearchTemplatePostWithIndexRequest {
	return DefaultAPISearchTemplatePostWithIndexRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SearchTemplatePostWithIndexExecute(r DefaultAPISearchTemplatePostWithIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SearchTemplatePostWithIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_search/template"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.ignoreThrottled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_throttled", r.ignoreThrottled, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "")
	}
	if r.typedKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typed_keys", r.typedKeys, "")
	}
	if r.restTotalHitsAsInt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rest_total_hits_as_int", r.restTotalHitsAsInt, "")
	} else {
		var defaultValue bool = false
		r.restTotalHitsAsInt = &defaultValue
	}
	if r.ccsMinimizeRoundtrips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccs_minimize_roundtrips", r.ccsMinimizeRoundtrips, "")
	} else {
		var defaultValue bool = true
		r.ccsMinimizeRoundtrips = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISecurityHealthRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r DefaultAPISecurityHealthRequest) Execute() (*SecurityHealthResponseContent, *http.Response, error) {
	return r.ApiService.SecurityHealthExecute(r)
}

/*
SecurityHealth Method for SecurityHealth

Checks to see if the Security plugin is up and running.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPISecurityHealthRequest
*/
func (a *DefaultAPIService) SecurityHealth(ctx context.Context) DefaultAPISecurityHealthRequest {
	return DefaultAPISecurityHealthRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SecurityHealthResponseContent
func (a *DefaultAPIService) SecurityHealthExecute(r DefaultAPISecurityHealthRequest) (*SecurityHealthResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecurityHealthResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SecurityHealth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPISnapshotCleanupRepositoryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotCleanupRepositoryRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotCleanupRepositoryRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotCleanupRepositoryRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotCleanupRepositoryRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r DefaultAPISnapshotCleanupRepositoryRequest) Timeout(timeout string) DefaultAPISnapshotCleanupRepositoryRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPISnapshotCleanupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotCleanupRepositoryExecute(r)
}

/*
SnapshotCleanupRepository Method for SnapshotCleanupRepository

Removes stale data from repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @return DefaultAPISnapshotCleanupRepositoryRequest
*/
func (a *DefaultAPIService) SnapshotCleanupRepository(ctx context.Context, repository string) DefaultAPISnapshotCleanupRepositoryRequest {
	return DefaultAPISnapshotCleanupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotCleanupRepositoryExecute(r DefaultAPISnapshotCleanupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotCleanupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/_cleanup"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotCloneRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	snapshot string
	targetSnapshot string
	body *map[string]interface{}
	masterTimeout *string
	clusterManagerTimeout *string
}

func (r DefaultAPISnapshotCloneRequest) Body(body map[string]interface{}) DefaultAPISnapshotCloneRequest {
	r.body = &body
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotCloneRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotCloneRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotCloneRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotCloneRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPISnapshotCloneRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotCloneExecute(r)
}

/*
SnapshotClone Method for SnapshotClone

Clones indices from one snapshot into another snapshot in the same repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @param snapshot Snapshot name.
 @param targetSnapshot The name of the cloned snapshot to create.
 @return DefaultAPISnapshotCloneRequest
*/
func (a *DefaultAPIService) SnapshotClone(ctx context.Context, repository string, snapshot string, targetSnapshot string) DefaultAPISnapshotCloneRequest {
	return DefaultAPISnapshotCloneRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
		snapshot: snapshot,
		targetSnapshot: targetSnapshot,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotCloneExecute(r DefaultAPISnapshotCloneRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotClone")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/{snapshot}/_clone/{target_snapshot}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot"+"}", url.PathEscape(parameterValueToString(r.snapshot, "snapshot")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target_snapshot"+"}", url.PathEscape(parameterValueToString(r.targetSnapshot, "targetSnapshot")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotCreatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	snapshot string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForCompletion *bool
	body *map[string]interface{}
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotCreatePostRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotCreatePostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotCreatePostRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotCreatePostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Should this request wait until the operation has completed before returning.
func (r DefaultAPISnapshotCreatePostRequest) WaitForCompletion(waitForCompletion bool) DefaultAPISnapshotCreatePostRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

func (r DefaultAPISnapshotCreatePostRequest) Body(body map[string]interface{}) DefaultAPISnapshotCreatePostRequest {
	r.body = &body
	return r
}

func (r DefaultAPISnapshotCreatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotCreatePostExecute(r)
}

/*
SnapshotCreatePost Method for SnapshotCreatePost

Creates a snapshot in a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @param snapshot Snapshot name.
 @return DefaultAPISnapshotCreatePostRequest
*/
func (a *DefaultAPIService) SnapshotCreatePost(ctx context.Context, repository string, snapshot string) DefaultAPISnapshotCreatePostRequest {
	return DefaultAPISnapshotCreatePostRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
		snapshot: snapshot,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotCreatePostExecute(r DefaultAPISnapshotCreatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotCreatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/{snapshot}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot"+"}", url.PathEscape(parameterValueToString(r.snapshot, "snapshot")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotCreatePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	snapshot string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForCompletion *bool
	body *map[string]interface{}
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotCreatePutRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotCreatePutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotCreatePutRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotCreatePutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Should this request wait until the operation has completed before returning.
func (r DefaultAPISnapshotCreatePutRequest) WaitForCompletion(waitForCompletion bool) DefaultAPISnapshotCreatePutRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

func (r DefaultAPISnapshotCreatePutRequest) Body(body map[string]interface{}) DefaultAPISnapshotCreatePutRequest {
	r.body = &body
	return r
}

func (r DefaultAPISnapshotCreatePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotCreatePutExecute(r)
}

/*
SnapshotCreatePut Method for SnapshotCreatePut

Creates a snapshot in a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @param snapshot Snapshot name.
 @return DefaultAPISnapshotCreatePutRequest
*/
func (a *DefaultAPIService) SnapshotCreatePut(ctx context.Context, repository string, snapshot string) DefaultAPISnapshotCreatePutRequest {
	return DefaultAPISnapshotCreatePutRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
		snapshot: snapshot,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotCreatePutExecute(r DefaultAPISnapshotCreatePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotCreatePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/{snapshot}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot"+"}", url.PathEscape(parameterValueToString(r.snapshot, "snapshot")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotCreateRepositoryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	body *map[string]interface{}
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	verify *bool
}

func (r DefaultAPISnapshotCreateRepositoryPostRequest) Body(body map[string]interface{}) DefaultAPISnapshotCreateRepositoryPostRequest {
	r.body = &body
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotCreateRepositoryPostRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotCreateRepositoryPostRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotCreateRepositoryPostRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotCreateRepositoryPostRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r DefaultAPISnapshotCreateRepositoryPostRequest) Timeout(timeout string) DefaultAPISnapshotCreateRepositoryPostRequest {
	r.timeout = &timeout
	return r
}

// Whether to verify the repository after creation.
func (r DefaultAPISnapshotCreateRepositoryPostRequest) Verify(verify bool) DefaultAPISnapshotCreateRepositoryPostRequest {
	r.verify = &verify
	return r
}

func (r DefaultAPISnapshotCreateRepositoryPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotCreateRepositoryPostExecute(r)
}

/*
SnapshotCreateRepositoryPost Method for SnapshotCreateRepositoryPost

Creates a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @return DefaultAPISnapshotCreateRepositoryPostRequest
*/
func (a *DefaultAPIService) SnapshotCreateRepositoryPost(ctx context.Context, repository string) DefaultAPISnapshotCreateRepositoryPostRequest {
	return DefaultAPISnapshotCreateRepositoryPostRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotCreateRepositoryPostExecute(r DefaultAPISnapshotCreateRepositoryPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotCreateRepositoryPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.verify != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verify", r.verify, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotCreateRepositoryPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	body *map[string]interface{}
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
	verify *bool
}

func (r DefaultAPISnapshotCreateRepositoryPutRequest) Body(body map[string]interface{}) DefaultAPISnapshotCreateRepositoryPutRequest {
	r.body = &body
	return r
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotCreateRepositoryPutRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotCreateRepositoryPutRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotCreateRepositoryPutRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotCreateRepositoryPutRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r DefaultAPISnapshotCreateRepositoryPutRequest) Timeout(timeout string) DefaultAPISnapshotCreateRepositoryPutRequest {
	r.timeout = &timeout
	return r
}

// Whether to verify the repository after creation.
func (r DefaultAPISnapshotCreateRepositoryPutRequest) Verify(verify bool) DefaultAPISnapshotCreateRepositoryPutRequest {
	r.verify = &verify
	return r
}

func (r DefaultAPISnapshotCreateRepositoryPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotCreateRepositoryPutExecute(r)
}

/*
SnapshotCreateRepositoryPut Method for SnapshotCreateRepositoryPut

Creates a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @return DefaultAPISnapshotCreateRepositoryPutRequest
*/
func (a *DefaultAPIService) SnapshotCreateRepositoryPut(ctx context.Context, repository string) DefaultAPISnapshotCreateRepositoryPutRequest {
	return DefaultAPISnapshotCreateRepositoryPutRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotCreateRepositoryPutExecute(r DefaultAPISnapshotCreateRepositoryPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotCreateRepositoryPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.verify != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verify", r.verify, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	snapshot string
	masterTimeout *string
	clusterManagerTimeout *string
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotDeleteRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotDeleteRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotDeleteRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotDeleteRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

func (r DefaultAPISnapshotDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotDeleteExecute(r)
}

/*
SnapshotDelete Method for SnapshotDelete

Deletes a snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @param snapshot Snapshot name.
 @return DefaultAPISnapshotDeleteRequest
*/
func (a *DefaultAPIService) SnapshotDelete(ctx context.Context, repository string, snapshot string) DefaultAPISnapshotDeleteRequest {
	return DefaultAPISnapshotDeleteRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
		snapshot: snapshot,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotDeleteExecute(r DefaultAPISnapshotDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/{snapshot}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot"+"}", url.PathEscape(parameterValueToString(r.snapshot, "snapshot")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotDeleteRepositoryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotDeleteRepositoryRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotDeleteRepositoryRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotDeleteRepositoryRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotDeleteRepositoryRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r DefaultAPISnapshotDeleteRepositoryRequest) Timeout(timeout string) DefaultAPISnapshotDeleteRepositoryRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPISnapshotDeleteRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotDeleteRepositoryExecute(r)
}

/*
SnapshotDeleteRepository Method for SnapshotDeleteRepository

Deletes a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Name of the snapshot repository to unregister. Wildcard (`*`) patterns are supported.
 @return DefaultAPISnapshotDeleteRepositoryRequest
*/
func (a *DefaultAPIService) SnapshotDeleteRepository(ctx context.Context, repository string) DefaultAPISnapshotDeleteRepositoryRequest {
	return DefaultAPISnapshotDeleteRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotDeleteRepositoryExecute(r DefaultAPISnapshotDeleteRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotDeleteRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	snapshot string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
	verbose *bool
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotGetRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotGetRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotGetRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotGetRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
func (r DefaultAPISnapshotGetRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISnapshotGetRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to show verbose snapshot info or only show the basic info found in the repository index blob.
func (r DefaultAPISnapshotGetRequest) Verbose(verbose bool) DefaultAPISnapshotGetRequest {
	r.verbose = &verbose
	return r
}

func (r DefaultAPISnapshotGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotGetExecute(r)
}

/*
SnapshotGet Method for SnapshotGet

Returns information about a snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @param snapshot Comma-separated list of snapshot names.
 @return DefaultAPISnapshotGetRequest
*/
func (a *DefaultAPIService) SnapshotGet(ctx context.Context, repository string, snapshot string) DefaultAPISnapshotGetRequest {
	return DefaultAPISnapshotGetRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
		snapshot: snapshot,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotGetExecute(r DefaultAPISnapshotGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/{snapshot}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot"+"}", url.PathEscape(parameterValueToString(r.snapshot, "snapshot")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotGetRepositoryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotGetRepositoryRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotGetRepositoryRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotGetRepositoryRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotGetRepositoryRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPISnapshotGetRepositoryRequest) Local(local bool) DefaultAPISnapshotGetRepositoryRequest {
	r.local = &local
	return r
}

func (r DefaultAPISnapshotGetRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotGetRepositoryExecute(r)
}

/*
SnapshotGetRepository Method for SnapshotGetRepository

Returns information about a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPISnapshotGetRepositoryRequest
*/
func (a *DefaultAPIService) SnapshotGetRepository(ctx context.Context) DefaultAPISnapshotGetRepositoryRequest {
	return DefaultAPISnapshotGetRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotGetRepositoryExecute(r DefaultAPISnapshotGetRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotGetRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotGetRepositoryWithRepositoryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	masterTimeout *string
	clusterManagerTimeout *string
	local *bool
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotGetRepositoryWithRepositoryRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotGetRepositoryWithRepositoryRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotGetRepositoryWithRepositoryRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotGetRepositoryWithRepositoryRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Return local information, do not retrieve the state from cluster-manager node.
func (r DefaultAPISnapshotGetRepositoryWithRepositoryRequest) Local(local bool) DefaultAPISnapshotGetRepositoryWithRepositoryRequest {
	r.local = &local
	return r
}

func (r DefaultAPISnapshotGetRepositoryWithRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotGetRepositoryWithRepositoryExecute(r)
}

/*
SnapshotGetRepositoryWithRepository Method for SnapshotGetRepositoryWithRepository

Returns information about a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Comma-separated list of repository names.
 @return DefaultAPISnapshotGetRepositoryWithRepositoryRequest
*/
func (a *DefaultAPIService) SnapshotGetRepositoryWithRepository(ctx context.Context, repository string) DefaultAPISnapshotGetRepositoryWithRepositoryRequest {
	return DefaultAPISnapshotGetRepositoryWithRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotGetRepositoryWithRepositoryExecute(r DefaultAPISnapshotGetRepositoryWithRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotGetRepositoryWithRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.local != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local", r.local, "")
	} else {
		var defaultValue bool = false
		r.local = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotRestoreRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	snapshot string
	masterTimeout *string
	clusterManagerTimeout *string
	waitForCompletion *bool
	body *map[string]interface{}
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotRestoreRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotRestoreRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotRestoreRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotRestoreRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Should this request wait until the operation has completed before returning.
func (r DefaultAPISnapshotRestoreRequest) WaitForCompletion(waitForCompletion bool) DefaultAPISnapshotRestoreRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

func (r DefaultAPISnapshotRestoreRequest) Body(body map[string]interface{}) DefaultAPISnapshotRestoreRequest {
	r.body = &body
	return r
}

func (r DefaultAPISnapshotRestoreRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotRestoreExecute(r)
}

/*
SnapshotRestore Method for SnapshotRestore

Restores a snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @param snapshot Snapshot name.
 @return DefaultAPISnapshotRestoreRequest
*/
func (a *DefaultAPIService) SnapshotRestore(ctx context.Context, repository string, snapshot string) DefaultAPISnapshotRestoreRequest {
	return DefaultAPISnapshotRestoreRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
		snapshot: snapshot,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotRestoreExecute(r DefaultAPISnapshotRestoreRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotRestore")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/{snapshot}/_restore"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot"+"}", url.PathEscape(parameterValueToString(r.snapshot, "snapshot")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotStatusRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotStatusRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotStatusRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotStatusRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotStatusRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
func (r DefaultAPISnapshotStatusRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISnapshotStatusRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

func (r DefaultAPISnapshotStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotStatusExecute(r)
}

/*
SnapshotStatus Method for SnapshotStatus

Returns information about the status of a snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPISnapshotStatusRequest
*/
func (a *DefaultAPIService) SnapshotStatus(ctx context.Context) DefaultAPISnapshotStatusRequest {
	return DefaultAPISnapshotStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotStatusExecute(r DefaultAPISnapshotStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/_status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotStatusWithRepositoryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotStatusWithRepositoryRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotStatusWithRepositoryRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotStatusWithRepositoryRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotStatusWithRepositoryRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
func (r DefaultAPISnapshotStatusWithRepositoryRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISnapshotStatusWithRepositoryRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

func (r DefaultAPISnapshotStatusWithRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotStatusWithRepositoryExecute(r)
}

/*
SnapshotStatusWithRepository Method for SnapshotStatusWithRepository

Returns information about the status of a snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @return DefaultAPISnapshotStatusWithRepositoryRequest
*/
func (a *DefaultAPIService) SnapshotStatusWithRepository(ctx context.Context, repository string) DefaultAPISnapshotStatusWithRepositoryRequest {
	return DefaultAPISnapshotStatusWithRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotStatusWithRepositoryExecute(r DefaultAPISnapshotStatusWithRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotStatusWithRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/_status"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotStatusWithRepositorySnapshotRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	snapshot string
	masterTimeout *string
	clusterManagerTimeout *string
	ignoreUnavailable *bool
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotStatusWithRepositorySnapshotRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotStatusWithRepositorySnapshotRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotStatusWithRepositorySnapshotRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotStatusWithRepositorySnapshotRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
func (r DefaultAPISnapshotStatusWithRepositorySnapshotRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPISnapshotStatusWithRepositorySnapshotRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

func (r DefaultAPISnapshotStatusWithRepositorySnapshotRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotStatusWithRepositorySnapshotExecute(r)
}

/*
SnapshotStatusWithRepositorySnapshot Method for SnapshotStatusWithRepositorySnapshot

Returns information about the status of a snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @param snapshot Comma-separated list of snapshot names.
 @return DefaultAPISnapshotStatusWithRepositorySnapshotRequest
*/
func (a *DefaultAPIService) SnapshotStatusWithRepositorySnapshot(ctx context.Context, repository string, snapshot string) DefaultAPISnapshotStatusWithRepositorySnapshotRequest {
	return DefaultAPISnapshotStatusWithRepositorySnapshotRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
		snapshot: snapshot,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotStatusWithRepositorySnapshotExecute(r DefaultAPISnapshotStatusWithRepositorySnapshotRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotStatusWithRepositorySnapshot")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/{snapshot}/_status"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot"+"}", url.PathEscape(parameterValueToString(r.snapshot, "snapshot")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	} else {
		var defaultValue bool = false
		r.ignoreUnavailable = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPISnapshotVerifyRepositoryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	repository string
	masterTimeout *string
	clusterManagerTimeout *string
	timeout *string
}

// Operation timeout for connection to master node.
func (r DefaultAPISnapshotVerifyRepositoryRequest) MasterTimeout(masterTimeout string) DefaultAPISnapshotVerifyRepositoryRequest {
	r.masterTimeout = &masterTimeout
	return r
}

// Operation timeout for connection to cluster-manager node.
func (r DefaultAPISnapshotVerifyRepositoryRequest) ClusterManagerTimeout(clusterManagerTimeout string) DefaultAPISnapshotVerifyRepositoryRequest {
	r.clusterManagerTimeout = &clusterManagerTimeout
	return r
}

// Operation timeout.
func (r DefaultAPISnapshotVerifyRepositoryRequest) Timeout(timeout string) DefaultAPISnapshotVerifyRepositoryRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPISnapshotVerifyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.SnapshotVerifyRepositoryExecute(r)
}

/*
SnapshotVerifyRepository Method for SnapshotVerifyRepository

Verifies a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repository Repository name.
 @return DefaultAPISnapshotVerifyRepositoryRequest
*/
func (a *DefaultAPIService) SnapshotVerifyRepository(ctx context.Context, repository string) DefaultAPISnapshotVerifyRepositoryRequest {
	return DefaultAPISnapshotVerifyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repository: repository,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SnapshotVerifyRepositoryExecute(r DefaultAPISnapshotVerifyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SnapshotVerifyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_snapshot/{repository}/_verify"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.masterTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master_timeout", r.masterTimeout, "")
	}
	if r.clusterManagerTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_manager_timeout", r.clusterManagerTimeout, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPITasksCancelRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodes *[]string
	actions *[]string
	parentTaskId *string
	waitForCompletion *bool
}

// Comma-separated list of node IDs or names to limit the returned information; use &#x60;_local&#x60; to return information from the node you&#39;re connecting to, leave empty to get information from all nodes.
func (r DefaultAPITasksCancelRequest) Nodes(nodes []string) DefaultAPITasksCancelRequest {
	r.nodes = &nodes
	return r
}

// Comma-separated list of actions that should be cancelled. Leave empty to cancel all.
func (r DefaultAPITasksCancelRequest) Actions(actions []string) DefaultAPITasksCancelRequest {
	r.actions = &actions
	return r
}

// Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
func (r DefaultAPITasksCancelRequest) ParentTaskId(parentTaskId string) DefaultAPITasksCancelRequest {
	r.parentTaskId = &parentTaskId
	return r
}

// Should this request wait until the operation has completed before returning.
func (r DefaultAPITasksCancelRequest) WaitForCompletion(waitForCompletion bool) DefaultAPITasksCancelRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

func (r DefaultAPITasksCancelRequest) Execute() (*http.Response, error) {
	return r.ApiService.TasksCancelExecute(r)
}

/*
TasksCancel Method for TasksCancel

Cancels a task, if it can be cancelled through an API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPITasksCancelRequest
*/
func (a *DefaultAPIService) TasksCancel(ctx context.Context) DefaultAPITasksCancelRequest {
	return DefaultAPITasksCancelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TasksCancelExecute(r DefaultAPITasksCancelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TasksCancel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_tasks/_cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodes != nil {
		t := *r.nodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", t, "multi")
		}
	}
	if r.actions != nil {
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "multi")
		}
	}
	if r.parentTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_task_id", r.parentTaskId, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPITasksCancelWithTaskIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	nodes *[]string
	actions *[]string
	parentTaskId *string
	waitForCompletion *bool
}

// Comma-separated list of node IDs or names to limit the returned information; use &#x60;_local&#x60; to return information from the node you&#39;re connecting to, leave empty to get information from all nodes.
func (r DefaultAPITasksCancelWithTaskIdRequest) Nodes(nodes []string) DefaultAPITasksCancelWithTaskIdRequest {
	r.nodes = &nodes
	return r
}

// Comma-separated list of actions that should be cancelled. Leave empty to cancel all.
func (r DefaultAPITasksCancelWithTaskIdRequest) Actions(actions []string) DefaultAPITasksCancelWithTaskIdRequest {
	r.actions = &actions
	return r
}

// Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
func (r DefaultAPITasksCancelWithTaskIdRequest) ParentTaskId(parentTaskId string) DefaultAPITasksCancelWithTaskIdRequest {
	r.parentTaskId = &parentTaskId
	return r
}

// Should this request wait until the operation has completed before returning.
func (r DefaultAPITasksCancelWithTaskIdRequest) WaitForCompletion(waitForCompletion bool) DefaultAPITasksCancelWithTaskIdRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

func (r DefaultAPITasksCancelWithTaskIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.TasksCancelWithTaskIdExecute(r)
}

/*
TasksCancelWithTaskId Method for TasksCancelWithTaskId

Cancels a task, if it can be cancelled through an API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId Cancel the task with specified task id (node_id:task_number).
 @return DefaultAPITasksCancelWithTaskIdRequest
*/
func (a *DefaultAPIService) TasksCancelWithTaskId(ctx context.Context, taskId string) DefaultAPITasksCancelWithTaskIdRequest {
	return DefaultAPITasksCancelWithTaskIdRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TasksCancelWithTaskIdExecute(r DefaultAPITasksCancelWithTaskIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TasksCancelWithTaskId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_tasks/{task_id}/_cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodes != nil {
		t := *r.nodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", t, "multi")
		}
	}
	if r.actions != nil {
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "multi")
		}
	}
	if r.parentTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_task_id", r.parentTaskId, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPITasksGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	waitForCompletion *bool
	timeout *string
}

// Should this request wait until the operation has completed before returning.
func (r DefaultAPITasksGetRequest) WaitForCompletion(waitForCompletion bool) DefaultAPITasksGetRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

// Operation timeout.
func (r DefaultAPITasksGetRequest) Timeout(timeout string) DefaultAPITasksGetRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPITasksGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.TasksGetExecute(r)
}

/*
TasksGet Method for TasksGet

Returns information about a task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId Return the task with specified id (node_id:task_number).
 @return DefaultAPITasksGetRequest
*/
func (a *DefaultAPIService) TasksGet(ctx context.Context, taskId string) DefaultAPITasksGetRequest {
	return DefaultAPITasksGetRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TasksGetExecute(r DefaultAPITasksGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TasksGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_tasks/{task_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPITasksListRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nodes *[]string
	actions *[]string
	detailed *bool
	parentTaskId *string
	waitForCompletion *bool
	groupBy *GroupBy
	timeout *string
}

// Comma-separated list of node IDs or names to limit the returned information; use &#x60;_local&#x60; to return information from the node you&#39;re connecting to, leave empty to get information from all nodes.
func (r DefaultAPITasksListRequest) Nodes(nodes []string) DefaultAPITasksListRequest {
	r.nodes = &nodes
	return r
}

// Comma-separated list of actions that should be returned. Leave empty to return all.
func (r DefaultAPITasksListRequest) Actions(actions []string) DefaultAPITasksListRequest {
	r.actions = &actions
	return r
}

// Return detailed task information.
func (r DefaultAPITasksListRequest) Detailed(detailed bool) DefaultAPITasksListRequest {
	r.detailed = &detailed
	return r
}

// Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
func (r DefaultAPITasksListRequest) ParentTaskId(parentTaskId string) DefaultAPITasksListRequest {
	r.parentTaskId = &parentTaskId
	return r
}

// Should this request wait until the operation has completed before returning.
func (r DefaultAPITasksListRequest) WaitForCompletion(waitForCompletion bool) DefaultAPITasksListRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

// Group tasks by nodes or parent/child relationships.
func (r DefaultAPITasksListRequest) GroupBy(groupBy GroupBy) DefaultAPITasksListRequest {
	r.groupBy = &groupBy
	return r
}

// Operation timeout.
func (r DefaultAPITasksListRequest) Timeout(timeout string) DefaultAPITasksListRequest {
	r.timeout = &timeout
	return r
}

func (r DefaultAPITasksListRequest) Execute() (*http.Response, error) {
	return r.ApiService.TasksListExecute(r)
}

/*
TasksList Method for TasksList

Returns a list of tasks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPITasksListRequest
*/
func (a *DefaultAPIService) TasksList(ctx context.Context) DefaultAPITasksListRequest {
	return DefaultAPITasksListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TasksListExecute(r DefaultAPITasksListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TasksList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodes != nil {
		t := *r.nodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nodes", t, "multi")
		}
	}
	if r.actions != nil {
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "multi")
		}
	}
	if r.detailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailed", r.detailed, "")
	} else {
		var defaultValue bool = false
		r.detailed = &defaultValue
	}
	if r.parentTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_task_id", r.parentTaskId, "")
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = false
		r.waitForCompletion = &defaultValue
	}
	if r.groupBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", r.groupBy, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPITermvectorsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
}

// Specifies if total term frequency and document frequency should be returned.
func (r DefaultAPITermvectorsGetRequest) TermStatistics(termStatistics bool) DefaultAPITermvectorsGetRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
func (r DefaultAPITermvectorsGetRequest) FieldStatistics(fieldStatistics bool) DefaultAPITermvectorsGetRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return.
func (r DefaultAPITermvectorsGetRequest) Fields(fields []string) DefaultAPITermvectorsGetRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned.
func (r DefaultAPITermvectorsGetRequest) Offsets(offsets bool) DefaultAPITermvectorsGetRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned.
func (r DefaultAPITermvectorsGetRequest) Positions(positions bool) DefaultAPITermvectorsGetRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned.
func (r DefaultAPITermvectorsGetRequest) Payloads(payloads bool) DefaultAPITermvectorsGetRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPITermvectorsGetRequest) Preference(preference string) DefaultAPITermvectorsGetRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r DefaultAPITermvectorsGetRequest) Routing(routing string) DefaultAPITermvectorsGetRequest {
	r.routing = &routing
	return r
}

// Specifies if request is real-time as opposed to near-real-time.
func (r DefaultAPITermvectorsGetRequest) Realtime(realtime bool) DefaultAPITermvectorsGetRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPITermvectorsGetRequest) Version(version int32) DefaultAPITermvectorsGetRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPITermvectorsGetRequest) VersionType(versionType VersionType) DefaultAPITermvectorsGetRequest {
	r.versionType = &versionType
	return r
}

func (r DefaultAPITermvectorsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.TermvectorsGetExecute(r)
}

/*
TermvectorsGet Method for TermvectorsGet

Returns information and statistics about terms in the fields of a particular document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The index in which the document resides.
 @return DefaultAPITermvectorsGetRequest
*/
func (a *DefaultAPIService) TermvectorsGet(ctx context.Context, index string) DefaultAPITermvectorsGetRequest {
	return DefaultAPITermvectorsGetRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TermvectorsGetExecute(r DefaultAPITermvectorsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TermvectorsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_termvectors"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPITermvectorsGetWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	id string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
}

// Specifies if total term frequency and document frequency should be returned.
func (r DefaultAPITermvectorsGetWithIdRequest) TermStatistics(termStatistics bool) DefaultAPITermvectorsGetWithIdRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
func (r DefaultAPITermvectorsGetWithIdRequest) FieldStatistics(fieldStatistics bool) DefaultAPITermvectorsGetWithIdRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return.
func (r DefaultAPITermvectorsGetWithIdRequest) Fields(fields []string) DefaultAPITermvectorsGetWithIdRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned.
func (r DefaultAPITermvectorsGetWithIdRequest) Offsets(offsets bool) DefaultAPITermvectorsGetWithIdRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned.
func (r DefaultAPITermvectorsGetWithIdRequest) Positions(positions bool) DefaultAPITermvectorsGetWithIdRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned.
func (r DefaultAPITermvectorsGetWithIdRequest) Payloads(payloads bool) DefaultAPITermvectorsGetWithIdRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPITermvectorsGetWithIdRequest) Preference(preference string) DefaultAPITermvectorsGetWithIdRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r DefaultAPITermvectorsGetWithIdRequest) Routing(routing string) DefaultAPITermvectorsGetWithIdRequest {
	r.routing = &routing
	return r
}

// Specifies if request is real-time as opposed to near-real-time.
func (r DefaultAPITermvectorsGetWithIdRequest) Realtime(realtime bool) DefaultAPITermvectorsGetWithIdRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPITermvectorsGetWithIdRequest) Version(version int32) DefaultAPITermvectorsGetWithIdRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPITermvectorsGetWithIdRequest) VersionType(versionType VersionType) DefaultAPITermvectorsGetWithIdRequest {
	r.versionType = &versionType
	return r
}

func (r DefaultAPITermvectorsGetWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.TermvectorsGetWithIdExecute(r)
}

/*
TermvectorsGetWithId Method for TermvectorsGetWithId

Returns information and statistics about terms in the fields of a particular document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The index in which the document resides.
 @param id Document ID. When not specified a doc param should be supplied.
 @return DefaultAPITermvectorsGetWithIdRequest
*/
func (a *DefaultAPIService) TermvectorsGetWithId(ctx context.Context, index string, id string) DefaultAPITermvectorsGetWithIdRequest {
	return DefaultAPITermvectorsGetWithIdRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TermvectorsGetWithIdExecute(r DefaultAPITermvectorsGetWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TermvectorsGetWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_termvectors/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPITermvectorsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
	body *map[string]interface{}
}

// Specifies if total term frequency and document frequency should be returned.
func (r DefaultAPITermvectorsPostRequest) TermStatistics(termStatistics bool) DefaultAPITermvectorsPostRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
func (r DefaultAPITermvectorsPostRequest) FieldStatistics(fieldStatistics bool) DefaultAPITermvectorsPostRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return.
func (r DefaultAPITermvectorsPostRequest) Fields(fields []string) DefaultAPITermvectorsPostRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned.
func (r DefaultAPITermvectorsPostRequest) Offsets(offsets bool) DefaultAPITermvectorsPostRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned.
func (r DefaultAPITermvectorsPostRequest) Positions(positions bool) DefaultAPITermvectorsPostRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned.
func (r DefaultAPITermvectorsPostRequest) Payloads(payloads bool) DefaultAPITermvectorsPostRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPITermvectorsPostRequest) Preference(preference string) DefaultAPITermvectorsPostRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r DefaultAPITermvectorsPostRequest) Routing(routing string) DefaultAPITermvectorsPostRequest {
	r.routing = &routing
	return r
}

// Specifies if request is real-time as opposed to near-real-time.
func (r DefaultAPITermvectorsPostRequest) Realtime(realtime bool) DefaultAPITermvectorsPostRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPITermvectorsPostRequest) Version(version int32) DefaultAPITermvectorsPostRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPITermvectorsPostRequest) VersionType(versionType VersionType) DefaultAPITermvectorsPostRequest {
	r.versionType = &versionType
	return r
}

func (r DefaultAPITermvectorsPostRequest) Body(body map[string]interface{}) DefaultAPITermvectorsPostRequest {
	r.body = &body
	return r
}

func (r DefaultAPITermvectorsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.TermvectorsPostExecute(r)
}

/*
TermvectorsPost Method for TermvectorsPost

Returns information and statistics about terms in the fields of a particular document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The index in which the document resides.
 @return DefaultAPITermvectorsPostRequest
*/
func (a *DefaultAPIService) TermvectorsPost(ctx context.Context, index string) DefaultAPITermvectorsPostRequest {
	return DefaultAPITermvectorsPostRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TermvectorsPostExecute(r DefaultAPITermvectorsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TermvectorsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_termvectors"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPITermvectorsPostWithIdRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	id string
	termStatistics *bool
	fieldStatistics *bool
	fields *[]string
	offsets *bool
	positions *bool
	payloads *bool
	preference *string
	routing *string
	realtime *bool
	version *int32
	versionType *VersionType
	body *map[string]interface{}
}

// Specifies if total term frequency and document frequency should be returned.
func (r DefaultAPITermvectorsPostWithIdRequest) TermStatistics(termStatistics bool) DefaultAPITermvectorsPostWithIdRequest {
	r.termStatistics = &termStatistics
	return r
}

// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
func (r DefaultAPITermvectorsPostWithIdRequest) FieldStatistics(fieldStatistics bool) DefaultAPITermvectorsPostWithIdRequest {
	r.fieldStatistics = &fieldStatistics
	return r
}

// Comma-separated list of fields to return.
func (r DefaultAPITermvectorsPostWithIdRequest) Fields(fields []string) DefaultAPITermvectorsPostWithIdRequest {
	r.fields = &fields
	return r
}

// Specifies if term offsets should be returned.
func (r DefaultAPITermvectorsPostWithIdRequest) Offsets(offsets bool) DefaultAPITermvectorsPostWithIdRequest {
	r.offsets = &offsets
	return r
}

// Specifies if term positions should be returned.
func (r DefaultAPITermvectorsPostWithIdRequest) Positions(positions bool) DefaultAPITermvectorsPostWithIdRequest {
	r.positions = &positions
	return r
}

// Specifies if term payloads should be returned.
func (r DefaultAPITermvectorsPostWithIdRequest) Payloads(payloads bool) DefaultAPITermvectorsPostWithIdRequest {
	r.payloads = &payloads
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPITermvectorsPostWithIdRequest) Preference(preference string) DefaultAPITermvectorsPostWithIdRequest {
	r.preference = &preference
	return r
}

// Routing value.
func (r DefaultAPITermvectorsPostWithIdRequest) Routing(routing string) DefaultAPITermvectorsPostWithIdRequest {
	r.routing = &routing
	return r
}

// Specifies if request is real-time as opposed to near-real-time.
func (r DefaultAPITermvectorsPostWithIdRequest) Realtime(realtime bool) DefaultAPITermvectorsPostWithIdRequest {
	r.realtime = &realtime
	return r
}

// Explicit version number for concurrency control.
func (r DefaultAPITermvectorsPostWithIdRequest) Version(version int32) DefaultAPITermvectorsPostWithIdRequest {
	r.version = &version
	return r
}

// Specific version type.
func (r DefaultAPITermvectorsPostWithIdRequest) VersionType(versionType VersionType) DefaultAPITermvectorsPostWithIdRequest {
	r.versionType = &versionType
	return r
}

func (r DefaultAPITermvectorsPostWithIdRequest) Body(body map[string]interface{}) DefaultAPITermvectorsPostWithIdRequest {
	r.body = &body
	return r
}

func (r DefaultAPITermvectorsPostWithIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.TermvectorsPostWithIdExecute(r)
}

/*
TermvectorsPostWithId Method for TermvectorsPostWithId

Returns information and statistics about terms in the fields of a particular document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index The index in which the document resides.
 @param id Document ID. When not specified a doc param should be supplied.
 @return DefaultAPITermvectorsPostWithIdRequest
*/
func (a *DefaultAPIService) TermvectorsPostWithId(ctx context.Context, index string, id string) DefaultAPITermvectorsPostWithIdRequest {
	return DefaultAPITermvectorsPostWithIdRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) TermvectorsPostWithIdExecute(r DefaultAPITermvectorsPostWithIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TermvectorsPostWithId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_termvectors/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.termStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "term_statistics", r.termStatistics, "")
	} else {
		var defaultValue bool = false
		r.termStatistics = &defaultValue
	}
	if r.fieldStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_statistics", r.fieldStatistics, "")
	} else {
		var defaultValue bool = true
		r.fieldStatistics = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.offsets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsets", r.offsets, "")
	} else {
		var defaultValue bool = true
		r.offsets = &defaultValue
	}
	if r.positions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positions", r.positions, "")
	} else {
		var defaultValue bool = true
		r.positions = &defaultValue
	}
	if r.payloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payloads", r.payloads, "")
	} else {
		var defaultValue bool = true
		r.payloads = &defaultValue
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.realtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtime", r.realtime, "")
	} else {
		var defaultValue bool = true
		r.realtime = &defaultValue
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.versionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version_type", r.versionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIUpdateRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	index string
	body *map[string]interface{}
	waitForActiveShards *string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	lang *string
	refresh *RefreshEnum
	retryOnConflict *int32
	routing *string
	timeout *string
	ifSeqNo *int32
	ifPrimaryTerm *int32
	requireAlias *bool
}

func (r DefaultAPIUpdateRequest) Body(body map[string]interface{}) DefaultAPIUpdateRequest {
	r.body = &body
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r DefaultAPIUpdateRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIUpdateRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPIUpdateRequest) Source(source []string) DefaultAPIUpdateRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPIUpdateRequest) SourceExcludes(sourceExcludes []string) DefaultAPIUpdateRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPIUpdateRequest) SourceIncludes(sourceIncludes []string) DefaultAPIUpdateRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The script language.
func (r DefaultAPIUpdateRequest) Lang(lang string) DefaultAPIUpdateRequest {
	r.lang = &lang
	return r
}

// If &#x60;true&#x60; then refresh the affected shards to make this operation visible to search, if &#x60;wait_for&#x60; then wait for a refresh to make this operation visible to search, if &#x60;false&#x60; (the default) then do nothing with refreshes.
func (r DefaultAPIUpdateRequest) Refresh(refresh RefreshEnum) DefaultAPIUpdateRequest {
	r.refresh = &refresh
	return r
}

// Specify how many times should the operation be retried when a conflict occurs.
func (r DefaultAPIUpdateRequest) RetryOnConflict(retryOnConflict int32) DefaultAPIUpdateRequest {
	r.retryOnConflict = &retryOnConflict
	return r
}

// Routing value.
func (r DefaultAPIUpdateRequest) Routing(routing string) DefaultAPIUpdateRequest {
	r.routing = &routing
	return r
}

// Operation timeout.
func (r DefaultAPIUpdateRequest) Timeout(timeout string) DefaultAPIUpdateRequest {
	r.timeout = &timeout
	return r
}

// only perform the operation if the last operation that has changed the document has the specified sequence number.
func (r DefaultAPIUpdateRequest) IfSeqNo(ifSeqNo int32) DefaultAPIUpdateRequest {
	r.ifSeqNo = &ifSeqNo
	return r
}

// only perform the operation if the last operation that has changed the document has the specified primary term.
func (r DefaultAPIUpdateRequest) IfPrimaryTerm(ifPrimaryTerm int32) DefaultAPIUpdateRequest {
	r.ifPrimaryTerm = &ifPrimaryTerm
	return r
}

// When true, requires destination to be an alias.
func (r DefaultAPIUpdateRequest) RequireAlias(requireAlias bool) DefaultAPIUpdateRequest {
	r.requireAlias = &requireAlias
	return r
}

func (r DefaultAPIUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateExecute(r)
}

/*
Update Method for Update

Updates a document with a script or partial document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Document ID.
 @param index Index name.
 @return DefaultAPIUpdateRequest
*/
func (a *DefaultAPIService) Update(ctx context.Context, id string, index string) DefaultAPIUpdateRequest {
	return DefaultAPIUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) UpdateExecute(r DefaultAPIUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Update")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_update/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.lang != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang", r.lang, "")
	} else {
		var defaultValue string = "painless"
		r.lang = &defaultValue
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.retryOnConflict != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retry_on_conflict", r.retryOnConflict, "")
	} else {
		var defaultValue int32 = 0
		r.retryOnConflict = &defaultValue
	}
	if r.routing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routing", r.routing, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.ifSeqNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_seq_no", r.ifSeqNo, "")
	}
	if r.ifPrimaryTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "if_primary_term", r.ifPrimaryTerm, "")
	}
	if r.requireAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "require_alias", r.requireAlias, "")
	} else {
		var defaultValue bool = false
		r.requireAlias = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIUpdateAuditConfigurationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	auditConfig *AuditConfig
}

func (r DefaultAPIUpdateAuditConfigurationRequest) AuditConfig(auditConfig AuditConfig) DefaultAPIUpdateAuditConfigurationRequest {
	r.auditConfig = &auditConfig
	return r
}

func (r DefaultAPIUpdateAuditConfigurationRequest) Execute() (*UpdateAuditConfigurationResponseContent, *http.Response, error) {
	return r.ApiService.UpdateAuditConfigurationExecute(r)
}

/*
UpdateAuditConfiguration Method for UpdateAuditConfiguration

Updates the audit configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIUpdateAuditConfigurationRequest
*/
func (a *DefaultAPIService) UpdateAuditConfiguration(ctx context.Context) DefaultAPIUpdateAuditConfigurationRequest {
	return DefaultAPIUpdateAuditConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateAuditConfigurationResponseContent
func (a *DefaultAPIService) UpdateAuditConfigurationExecute(r DefaultAPIUpdateAuditConfigurationRequest) (*UpdateAuditConfigurationResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateAuditConfigurationResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateAuditConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/audit/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.auditConfig == nil {
		return localVarReturnValue, nil, reportError("auditConfig is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.auditConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIUpdateByQueryRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	index string
	analyzer *string
	analyzeWildcard *bool
	defaultOperator *DefaultOperator
	df *string
	from *int32
	ignoreUnavailable *bool
	allowNoIndices *bool
	conflicts *Conflicts
	expandWildcards *ExpandWildcards
	lenient *bool
	pipeline *string
	preference *string
	q *string
	routing *[]string
	scroll *string
	searchType *SearchType
	searchTimeout *string
	size *int32
	maxDocs *int32
	sort *[]string
	source *[]string
	sourceExcludes *[]string
	sourceIncludes *[]string
	terminateAfter *int32
	stats *[]string
	version *bool
	requestCache *bool
	refresh *bool
	timeout *string
	waitForActiveShards *string
	scrollSize *int32
	waitForCompletion *bool
	requestsPerSecond *int32
	slices *string
	body *map[string]interface{}
}

// The analyzer to use for the query string.
func (r DefaultAPIUpdateByQueryRequest) Analyzer(analyzer string) DefaultAPIUpdateByQueryRequest {
	r.analyzer = &analyzer
	return r
}

// Specify whether wildcard and prefix queries should be analyzed.
func (r DefaultAPIUpdateByQueryRequest) AnalyzeWildcard(analyzeWildcard bool) DefaultAPIUpdateByQueryRequest {
	r.analyzeWildcard = &analyzeWildcard
	return r
}

// The default operator for query string query (AND or OR).
func (r DefaultAPIUpdateByQueryRequest) DefaultOperator(defaultOperator DefaultOperator) DefaultAPIUpdateByQueryRequest {
	r.defaultOperator = &defaultOperator
	return r
}

// The field to use as default where no field prefix is given in the query string.
func (r DefaultAPIUpdateByQueryRequest) Df(df string) DefaultAPIUpdateByQueryRequest {
	r.df = &df
	return r
}

// Starting offset.
func (r DefaultAPIUpdateByQueryRequest) From(from int32) DefaultAPIUpdateByQueryRequest {
	r.from = &from
	return r
}

// Whether specified concrete indices should be ignored when unavailable (missing or closed).
func (r DefaultAPIUpdateByQueryRequest) IgnoreUnavailable(ignoreUnavailable bool) DefaultAPIUpdateByQueryRequest {
	r.ignoreUnavailable = &ignoreUnavailable
	return r
}

// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes &#x60;_all&#x60; string or when no indices have been specified).
func (r DefaultAPIUpdateByQueryRequest) AllowNoIndices(allowNoIndices bool) DefaultAPIUpdateByQueryRequest {
	r.allowNoIndices = &allowNoIndices
	return r
}

// What to do when the operation encounters version conflicts?.
func (r DefaultAPIUpdateByQueryRequest) Conflicts(conflicts Conflicts) DefaultAPIUpdateByQueryRequest {
	r.conflicts = &conflicts
	return r
}

// Whether to expand wildcard expression to concrete indices that are open, closed or both.
func (r DefaultAPIUpdateByQueryRequest) ExpandWildcards(expandWildcards ExpandWildcards) DefaultAPIUpdateByQueryRequest {
	r.expandWildcards = &expandWildcards
	return r
}

// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
func (r DefaultAPIUpdateByQueryRequest) Lenient(lenient bool) DefaultAPIUpdateByQueryRequest {
	r.lenient = &lenient
	return r
}

// The pipeline id to preprocess incoming documents with.
func (r DefaultAPIUpdateByQueryRequest) Pipeline(pipeline string) DefaultAPIUpdateByQueryRequest {
	r.pipeline = &pipeline
	return r
}

// Specify the node or shard the operation should be performed on.
func (r DefaultAPIUpdateByQueryRequest) Preference(preference string) DefaultAPIUpdateByQueryRequest {
	r.preference = &preference
	return r
}

// Query in the Lucene query string syntax.
func (r DefaultAPIUpdateByQueryRequest) Q(q string) DefaultAPIUpdateByQueryRequest {
	r.q = &q
	return r
}

// Comma-separated list of specific routing values.
func (r DefaultAPIUpdateByQueryRequest) Routing(routing []string) DefaultAPIUpdateByQueryRequest {
	r.routing = &routing
	return r
}

// Specify how long a consistent view of the index should be maintained for scrolled search.
func (r DefaultAPIUpdateByQueryRequest) Scroll(scroll string) DefaultAPIUpdateByQueryRequest {
	r.scroll = &scroll
	return r
}

// Search operation type.
func (r DefaultAPIUpdateByQueryRequest) SearchType(searchType SearchType) DefaultAPIUpdateByQueryRequest {
	r.searchType = &searchType
	return r
}

// Explicit timeout for each search request. Defaults to no timeout.
func (r DefaultAPIUpdateByQueryRequest) SearchTimeout(searchTimeout string) DefaultAPIUpdateByQueryRequest {
	r.searchTimeout = &searchTimeout
	return r
}

// Deprecated, please use &#x60;max_docs&#x60; instead.
func (r DefaultAPIUpdateByQueryRequest) Size(size int32) DefaultAPIUpdateByQueryRequest {
	r.size = &size
	return r
}

// Maximum number of documents to process (default: all documents).
func (r DefaultAPIUpdateByQueryRequest) MaxDocs(maxDocs int32) DefaultAPIUpdateByQueryRequest {
	r.maxDocs = &maxDocs
	return r
}

// Comma-separated list of &lt;field&gt;:&lt;direction&gt; pairs.
func (r DefaultAPIUpdateByQueryRequest) Sort(sort []string) DefaultAPIUpdateByQueryRequest {
	r.sort = &sort
	return r
}

// True or false to return the _source field or not, or a list of fields to return.
func (r DefaultAPIUpdateByQueryRequest) Source(source []string) DefaultAPIUpdateByQueryRequest {
	r.source = &source
	return r
}

// List of fields to exclude from the returned _source field.
func (r DefaultAPIUpdateByQueryRequest) SourceExcludes(sourceExcludes []string) DefaultAPIUpdateByQueryRequest {
	r.sourceExcludes = &sourceExcludes
	return r
}

// List of fields to extract and return from the _source field.
func (r DefaultAPIUpdateByQueryRequest) SourceIncludes(sourceIncludes []string) DefaultAPIUpdateByQueryRequest {
	r.sourceIncludes = &sourceIncludes
	return r
}

// The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
func (r DefaultAPIUpdateByQueryRequest) TerminateAfter(terminateAfter int32) DefaultAPIUpdateByQueryRequest {
	r.terminateAfter = &terminateAfter
	return r
}

// Specific &#39;tag&#39; of the request for logging and statistical purposes.
func (r DefaultAPIUpdateByQueryRequest) Stats(stats []string) DefaultAPIUpdateByQueryRequest {
	r.stats = &stats
	return r
}

// Whether to return document version as part of a hit.
func (r DefaultAPIUpdateByQueryRequest) Version(version bool) DefaultAPIUpdateByQueryRequest {
	r.version = &version
	return r
}

// Specify if request cache should be used for this request or not, defaults to index level setting.
func (r DefaultAPIUpdateByQueryRequest) RequestCache(requestCache bool) DefaultAPIUpdateByQueryRequest {
	r.requestCache = &requestCache
	return r
}

// Should the affected indexes be refreshed?.
func (r DefaultAPIUpdateByQueryRequest) Refresh(refresh bool) DefaultAPIUpdateByQueryRequest {
	r.refresh = &refresh
	return r
}

// Time each individual bulk request should wait for shards that are unavailable.
func (r DefaultAPIUpdateByQueryRequest) Timeout(timeout string) DefaultAPIUpdateByQueryRequest {
	r.timeout = &timeout
	return r
}

// Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to &#x60;all&#x60; for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
func (r DefaultAPIUpdateByQueryRequest) WaitForActiveShards(waitForActiveShards string) DefaultAPIUpdateByQueryRequest {
	r.waitForActiveShards = &waitForActiveShards
	return r
}

// Size on the scroll request powering the operation.
func (r DefaultAPIUpdateByQueryRequest) ScrollSize(scrollSize int32) DefaultAPIUpdateByQueryRequest {
	r.scrollSize = &scrollSize
	return r
}

// Should this request wait until the operation has completed before returning.
func (r DefaultAPIUpdateByQueryRequest) WaitForCompletion(waitForCompletion bool) DefaultAPIUpdateByQueryRequest {
	r.waitForCompletion = &waitForCompletion
	return r
}

// The throttle for this request in sub-requests per second. -1 means no throttle.
func (r DefaultAPIUpdateByQueryRequest) RequestsPerSecond(requestsPerSecond int32) DefaultAPIUpdateByQueryRequest {
	r.requestsPerSecond = &requestsPerSecond
	return r
}

// The number of slices this task should be divided into. Defaults to 1, meaning the task isn&#39;t sliced into subtasks. Can be set to &#x60;auto&#x60;.
func (r DefaultAPIUpdateByQueryRequest) Slices(slices string) DefaultAPIUpdateByQueryRequest {
	r.slices = &slices
	return r
}

func (r DefaultAPIUpdateByQueryRequest) Body(body map[string]interface{}) DefaultAPIUpdateByQueryRequest {
	r.body = &body
	return r
}

func (r DefaultAPIUpdateByQueryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateByQueryExecute(r)
}

/*
UpdateByQuery Method for UpdateByQuery

Performs an update on every document in the index without changing the source,
for example to pick up a mapping change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param index Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
 @return DefaultAPIUpdateByQueryRequest
*/
func (a *DefaultAPIService) UpdateByQuery(ctx context.Context, index string) DefaultAPIUpdateByQueryRequest {
	return DefaultAPIUpdateByQueryRequest{
		ApiService: a,
		ctx: ctx,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) UpdateByQueryExecute(r DefaultAPIUpdateByQueryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateByQuery")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{index}/_update_by_query"
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.analyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzer", r.analyzer, "")
	}
	if r.analyzeWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyze_wildcard", r.analyzeWildcard, "")
	} else {
		var defaultValue bool = false
		r.analyzeWildcard = &defaultValue
	}
	if r.defaultOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_operator", r.defaultOperator, "")
	}
	if r.df != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "df", r.df, "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	} else {
		var defaultValue int32 = 0
		r.from = &defaultValue
	}
	if r.ignoreUnavailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_unavailable", r.ignoreUnavailable, "")
	}
	if r.allowNoIndices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_no_indices", r.allowNoIndices, "")
	}
	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.expandWildcards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_wildcards", r.expandWildcards, "")
	}
	if r.lenient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lenient", r.lenient, "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "")
	}
	if r.preference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preference", r.preference, "")
	} else {
		var defaultValue string = "random"
		r.preference = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.routing != nil {
		t := *r.routing
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routing", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routing", t, "multi")
		}
	}
	if r.scroll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll", r.scroll, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.searchTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_timeout", r.searchTimeout, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.maxDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_docs", r.maxDocs, "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	if r.source != nil {
		t := *r.source
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source", t, "multi")
		}
	}
	if r.sourceExcludes != nil {
		t := *r.sourceExcludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_excludes", t, "multi")
		}
	}
	if r.sourceIncludes != nil {
		t := *r.sourceIncludes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "_source_includes", t, "multi")
		}
	}
	if r.terminateAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_after", r.terminateAfter, "")
	}
	if r.stats != nil {
		t := *r.stats
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stats", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stats", t, "multi")
		}
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.requestCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_cache", r.requestCache, "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	} else {
		var defaultValue string = "1m"
		r.timeout = &defaultValue
	}
	if r.waitForActiveShards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_active_shards", r.waitForActiveShards, "")
	} else {
		var defaultValue string = "1"
		r.waitForActiveShards = &defaultValue
	}
	if r.scrollSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scroll_size", r.scrollSize, "")
	} else {
		var defaultValue int32 = 100
		r.scrollSize = &defaultValue
	}
	if r.waitForCompletion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_completion", r.waitForCompletion, "")
	} else {
		var defaultValue bool = true
		r.waitForCompletion = &defaultValue
	}
	if r.requestsPerSecond != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requests_per_second", r.requestsPerSecond, "")
	} else {
		var defaultValue int32 = 0
		r.requestsPerSecond = &defaultValue
	}
	if r.slices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slices", r.slices, "")
	} else {
		var defaultValue string = "1"
		r.slices = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIUpdateByQueryRethrottleRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	requestsPerSecond *int32
}

// The throttle for this request in sub-requests per second. -1 means no throttle.
func (r DefaultAPIUpdateByQueryRethrottleRequest) RequestsPerSecond(requestsPerSecond int32) DefaultAPIUpdateByQueryRethrottleRequest {
	r.requestsPerSecond = &requestsPerSecond
	return r
}

func (r DefaultAPIUpdateByQueryRethrottleRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateByQueryRethrottleExecute(r)
}

/*
UpdateByQueryRethrottle Method for UpdateByQueryRethrottle

Changes the number of requests per second for a particular Update By Query operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id to rethrottle.
 @return DefaultAPIUpdateByQueryRethrottleRequest
*/
func (a *DefaultAPIService) UpdateByQueryRethrottle(ctx context.Context, taskId string) DefaultAPIUpdateByQueryRethrottleRequest {
	return DefaultAPIUpdateByQueryRethrottleRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) UpdateByQueryRethrottleExecute(r DefaultAPIUpdateByQueryRethrottleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateByQueryRethrottle")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_update_by_query/{task_id}/_rethrottle"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestsPerSecond == nil {
		return nil, reportError("requestsPerSecond is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "requests_per_second", r.requestsPerSecond, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIUpdateConfigurationRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	dynamicConfig *DynamicConfig
}

func (r DefaultAPIUpdateConfigurationRequest) DynamicConfig(dynamicConfig DynamicConfig) DefaultAPIUpdateConfigurationRequest {
	r.dynamicConfig = &dynamicConfig
	return r
}

func (r DefaultAPIUpdateConfigurationRequest) Execute() (*UpdateConfigurationResponseContent, *http.Response, error) {
	return r.ApiService.UpdateConfigurationExecute(r)
}

/*
UpdateConfiguration Method for UpdateConfiguration

Adds or updates the existing configuration using the REST API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIUpdateConfigurationRequest
*/
func (a *DefaultAPIService) UpdateConfiguration(ctx context.Context) DefaultAPIUpdateConfigurationRequest {
	return DefaultAPIUpdateConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateConfigurationResponseContent
func (a *DefaultAPIService) UpdateConfigurationExecute(r DefaultAPIUpdateConfigurationRequest) (*UpdateConfigurationResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateConfigurationResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/securityconfig/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dynamicConfig == nil {
		return localVarReturnValue, nil, reportError("dynamicConfig is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dynamicConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIUpdateDistinguishedNamesRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	clusterName string
	distinguishedNames *DistinguishedNames
}

func (r DefaultAPIUpdateDistinguishedNamesRequest) DistinguishedNames(distinguishedNames DistinguishedNames) DefaultAPIUpdateDistinguishedNamesRequest {
	r.distinguishedNames = &distinguishedNames
	return r
}

func (r DefaultAPIUpdateDistinguishedNamesRequest) Execute() (*UpdateDistinguishedNamesResponseContent, *http.Response, error) {
	return r.ApiService.UpdateDistinguishedNamesExecute(r)
}

/*
UpdateDistinguishedNames Method for UpdateDistinguishedNames

Adds or updates the specified distinguished names in the cluster’s or node’s allow list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName
 @return DefaultAPIUpdateDistinguishedNamesRequest
*/
func (a *DefaultAPIService) UpdateDistinguishedNames(ctx context.Context, clusterName string) DefaultAPIUpdateDistinguishedNamesRequest {
	return DefaultAPIUpdateDistinguishedNamesRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return UpdateDistinguishedNamesResponseContent
func (a *DefaultAPIService) UpdateDistinguishedNamesExecute(r DefaultAPIUpdateDistinguishedNamesRequest) (*UpdateDistinguishedNamesResponseContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateDistinguishedNamesResponseContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateDistinguishedNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/_plugins/_security/api/nodesdn/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.distinguishedNames
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
